<!DOCTYPE html>
<!-- BR18_FULL_BUILD: 2026-01-28T00:00Z -->
<html lang="da">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>BR18 Komplet System â€“ Full Layout</title>
  <link rel="icon" href="data:,">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css"/>
  <style>
    :root {
      --topbar-h: 64px;
      --bottombar-h: 64px;
    }
    body, html { height: 100%; }
    body { margin: 0; font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    .topbar {
      position: fixed; top: 0; left: 0; right: 0; height: var(--topbar-h);
      display: flex; align-items: center; justify-content: space-between;
      padding: 0 24px; background: #ffffff; border-bottom: 1px solid #e6e8ef; z-index: 10;
    }
    .brand { display: flex; align-items: center; gap: 12px; }
    .brand .logo { width: 32px; height: 32px; border-radius: 8px; background: #db3434; display: inline-block; }
    .brand .titles { line-height: 1.2; }
    .brand .titles .title { font-weight: 700; }
    .brand .titles .subtitle { font-size: 12px; color: #666; }
    .top-actions { display: flex; align-items: center; gap: 12px; }
    .layout {
      position: relative; padding-top: var(--topbar-h);
      height: 100vh; display: flex; flex-direction: column;
    }
    .main {
      flex: 1; display: flex; gap: 16px; padding: 16px 24px; box-sizing: border-box;
    }
    /* Layout balance: make results panel narrower (~25%) */
    .left-panel { flex: 3 1 0; display: flex; flex-direction: column; gap: 12px; }
    .right-panel { flex: 1 1 340px; display: flex; flex-direction: column; gap: 12px; }
    .card { background: #fff; border: 1px solid #e6e8ef; border-radius: 12px; padding: 16px; }
    .accordion { display: flex; flex-direction: column; gap: 8px; }
    .acc-item { border: 1px solid #e6e8ef; border-radius: 8px; overflow: hidden; position: relative; }
    /* Prevent bottom-of-card selects from being clipped/covered by the next accordion item */
    .acc-item.open { overflow: visible; z-index: 5000; }
    /* When a custom select is open, raise its accordion item above any other open items */
    .acc-item.dropdown-host { overflow: visible; z-index: 9000; }
    .acc-header { background: #f8f9fb; padding: 12px 16px; cursor: pointer; font-weight: 600; }
    .acc-content { padding: 12px 16px; display: none; }
    .acc-item.open .acc-content { display: block; }
    .form-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .form-field { display: flex; flex-direction: column; gap: 6px; }
    .form-field label { font-size: 13px; color: #333; }
    .form-field input[type="number"], .form-field input[type="text"], .form-field select { border: 1px solid #e6e8ef; border-radius: 8px; padding: 10px; font-size: 14px; accent-color: #991b1b; }

    /* Step 1: single-column long list layout (scoped) */
    .step1-field-list { display: flex; flex-direction: column; gap: 10px; margin-top: 12px; }
    .step1-field-list .form-field {
      display: grid;
      /* Make the answer/control column noticeably narrower */
      grid-template-columns: 1fr minmax(220px, 360px);
      align-items: center;
      gap: 12px;
      padding: 8px 12px;
      border: 1px solid #e6e8ef;
      border-radius: 12px;
      background: #ffffff;
    }
    .step1-field-list .form-field label { margin: 0; line-height: 1.15; font-size: 15px; font-weight: 700; color: #0f172a; }
    .step1-field-list .form-field input[type="number"],
    .step1-field-list .form-field input[type="text"],
    .step1-field-list .form-field select {
      width: 100%;
      padding: 8px 10px;
    }

    /* Highlight fields mentioned by optimization hints */
    .step1-field-list .form-field.opt-highlight {
      border-color: #f59e0b;
      background: #fffbeb;
      box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.18);
    }
    .step1-field-list .form-field.opt-highlight label {
      color: #92400e;
    }
    .step1-field-list .form-field.opt-highlight input,
    .step1-field-list .form-field.opt-highlight select {
      border-color: #f59e0b;
    }

    /* Green highlight for "optimization": field has a value but should be adjusted */
    .step1-field-list .form-field.opt-highlight.opt-highlight-opt {
      border-color: #10b981;
      background: #ecfdf5;
      box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.16);
    }
    .step1-field-list .form-field.opt-highlight.opt-highlight-opt label {
      color: #065f46;
    }
    .step1-field-list .form-field.opt-highlight.opt-highlight-opt input,
    .step1-field-list .form-field.opt-highlight.opt-highlight-opt select {
      border-color: #10b981;
    }
    @keyframes optPulse {
      0% { box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.0); }
      40% { box-shadow: 0 0 0 6px rgba(245, 158, 11, 0.22); }
      100% { box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.18); }
    }
    .step1-field-list .form-field.opt-highlight.opt-pulse {
      animation: optPulse 0.65s ease-out;
    }
    @media (max-width: 900px) {
      .step1-field-list .form-field { grid-template-columns: 1fr; align-items: stretch; }
    }

    .form-field select:focus { outline: none; border-color: #dc2626; box-shadow: 0 0 0 3px rgba(220, 38, 38, 0.1); }
    .form-field select option { background: #fff !important; background-color: #fff !important; color: #0f172a; padding: 8px; }
    .form-field select option:hover, .form-field select option:focus, .form-field select option:checked { background: #fef2f2 !important; background-color: #fef2f2 !important; color: #991b1b !important; }
    .form-field select option:active { background: #fee2e2 !important; background-color: #fee2e2 !important; color: #991b1b !important; }
    .form-field select:focus option:checked { background: linear-gradient(0deg, #fef2f2 0%, #fef2f2 100%) !important; }
    .tabs { display: flex; gap: 8px; margin-bottom: 8px; }
    .tab-btn { padding: 8px 12px; border: 1px solid #e6e8ef; border-radius: 8px; background: #fff; cursor: pointer; }
    .tab-btn.active { background: #db3434; color: #fff; border-color: #db3434; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    .upload-area { border: 2px dashed #e6e8ef; border-radius: 12px; padding: 16px; text-align: center; background: #fafbfc; }
    .json-textarea { width: 100%; height: 50vh; font-family: 'Monaco','Menlo', monospace; font-size: 13px; padding: 12px; border: 1px solid #e6e8ef; border-radius: 8px; }
    .results-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; }
    .result-card { background: #fff; border: 1px solid #e6e8ef; border-radius: 12px; padding: 16px; text-align: center; }
    .result-value { font-size: 2.4rem; font-weight: 700; margin: 8px 0; }
    .result-description { font-size: 13px; color: #666; }

    /* Compact results list (Step 1 right panel) */
    .results-list { display: flex; flex-direction: column; gap: 10px; margin-top: 10px; }
    .result-row { display: flex; align-items: flex-start; justify-content: space-between; gap: 12px; padding: 12px 14px; border: 1px solid #e6e8ef; border-radius: 12px; background: #ffffff; }
    .result-row .left { flex: 1; min-width: 0; }
    .result-label { font-weight: 800; font-size: 13px; color: #0f172a; }
    .result-help { font-size: 13px; color: #475569; margin-top: 6px; line-height: 1.5; overflow-wrap: anywhere; white-space: pre-wrap; }
    .result-right { display: flex; align-items: center; gap: 10px; }
    .result-value-inline { font-weight: 900; font-size: 16px; color: #0f172a; text-align: right; min-width: 48px; }
    .result-status { width: 22px; height: 22px; border-radius: 999px; display: inline-flex; align-items: center; justify-content: center; font-size: 13px; font-weight: 900; border: 1px solid; user-select: none; }
    .result-status.ok { background: #dcfce7; border-color: #86efac; color: #166534; }
    .result-status.missing { background: #fff7ed; border-color: #fdba74; color: #9a3412; }
    .result-status.pending { background: #f1f5f9; border-color: #cbd5e1; color: #475569; }

    /* Make navigation glyphs and close icons perfectly centered */
    .figure-nav-btn { display: inline-flex; align-items: center; justify-content: center; line-height: 1; }

    /* Pre-step explainer overlay */
    .prestep-overlay {
      position: fixed;
      inset: 0;
      z-index: 20000;
      display: none;
      background: rgba(23, 2, 2, 0.55);
      padding: 24px;
      box-sizing: border-box;
      overflow: auto;
    }
    .prestep-modal {
      max-width: 920px;
      margin: 0 auto;
      background: #ffffff;
      border: 1px solid #e6e8ef;
      border-radius: 16px;
      padding: 18px;
      box-shadow: 0 18px 64px rgba(23, 2, 2, 0.28);
    }
    .prestep-header { display: flex; align-items: flex-start; justify-content: space-between; gap: 12px; }
    .prestep-steps { display: flex; flex-wrap: wrap; gap: 10px; margin: 14px 0 12px; }
    .prestep-step { display: inline-flex; align-items: center; gap: 8px; padding: 8px 10px; border-radius: 999px; border: 1px solid #e6e8ef; background: #f8f9fb; font-size: 13px; color: #334155; }
    .prestep-step.active { border-color: #fca5a5; background: #fef2f2; color: #991b1b; font-weight: 700; }
    .prestep-step.done { border-color: #86efac; background: #dcfce7; color: #166534; }
    .prestep-content { border-top: 1px solid #e6e8ef; padding-top: 14px; }
    .prestep-card { border: 1px solid #e6e8ef; border-radius: 14px; padding: 14px; background: #ffffff; }
    .prestep-kicker { font-size: 12px; color: #64748b; }
    .prestep-value {
      font-size: 2.2rem;
      font-weight: 900;
      margin: 8px 0;
      color: #0f172a;
      letter-spacing: -0.02em;
    }
    .prestep-badge { display: inline-flex; align-items: center; gap: 8px; font-size: 12px; padding: 6px 10px; border-radius: 999px; border: 1px solid; }
    .prestep-badge.ok { background: #dcfce7; border-color: #86efac; color: #166534; }
    .prestep-badge.missing { background: #fff7ed; border-color: #fdba74; color: #9a3412; }
    .prestep-text { margin-top: 10px; color: #334155; line-height: 1.55; }

    /* Bilag input overlay (shown before Step 3 / Krav) */
    .bilag-overlay {
      position: fixed;
      inset: 0;
      z-index: 21000;
      display: none;
      background: rgba(2, 6, 23, 0.55);
      padding: 24px;
      box-sizing: border-box;
      overflow: auto;
    }
    .bilag-modal {
      max-width: 920px;
      margin: 0 auto;
      background: #ffffff;
      border: 1px solid #e6e8ef;
      border-radius: 16px;
      padding: 18px;
      box-shadow: 0 18px 64px rgba(2, 6, 23, 0.28);
    }
    .bilag-header { display: flex; align-items: flex-start; justify-content: space-between; gap: 12px; }
    .bilag-kicker { font-size: 12px; color: #64748b; }
    .bilag-body { border-top: 1px solid #e6e8ef; padding-top: 14px; margin-top: 12px; }
    .bilag-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .bilag-note { background: #f8fafc; border: 1px solid #e6e8ef; border-radius: 12px; padding: 12px; color: #334155; }
    .bilag-note strong { color: #0f172a; }
    .bilag-field { display: flex; flex-direction: column; gap: 6px; }
    .bilag-field label { font-size: 13px; color: #0f172a; font-weight: 700; display:flex; align-items:center; gap:6px; min-height: 18px; }
    .bilag-field .help { font-size: 12px; color: #64748b; line-height: 1.35; min-height: 16px; }
    .bilag-field input[type="number"],
    .bilag-field input[type="text"],
    .bilag-field select {
      border: 1px solid #e6e8ef;
      border-radius: 10px;
      padding: 10px;
      font-size: 14px;
      background: #ffffff;
      accent-color: #991b1b;
    }
    .bilag-field select:focus {
      outline: none;
      border-color: #dc2626;
      box-shadow: 0 0 0 3px rgba(220, 38, 38, 0.1);
    }
    .bilag-field select option {
      background: #fff !important;
      background-color: #fff !important;
      color: #0f172a;
      padding: 8px;
    }
    .bilag-field select option:hover,
    .bilag-field select option:focus,
    .bilag-field select option:checked {
      background: #fef2f2 !important;
      background-color: #fef2f2 !important;
      color: #991b1b !important;
    }
    .bilag-field select option:active {
      background: #fee2e2 !important;
      background-color: #fee2e2 !important;
      color: #991b1b !important;
    }
    .bilag-field select:focus option:checked {
      background: linear-gradient(0deg, #fef2f2 0%, #fef2f2 100%) !important;
    }
    .bilag-field input[readonly] {
      background: #f8fafc;
      color: #334155;
    }
    .bilag-actions { display: flex; justify-content: space-between; align-items: center; gap: 10px; margin-top: 14px; }
    .bilag-actions .right { display:flex; gap:8px; }

    /* (Note popup removed) */
    .bottombar { height: var(--bottombar-h); display: flex; align-items: center; justify-content: space-between; padding: 0 24px; border-top: 1px solid #e6e8ef; background: #fff; }
    .muted { color: #666; font-size: 13px; }
    .btn-primary { padding: 10px 16px; border-radius: 8px; border: 1px solid #db3434; background: #db3434; color: #fff; cursor: pointer; }
    .btn-secondary { padding: 10px 16px; border-radius: 8px; border: 1px solid #d1d5db; background: #f3f4f6; color: #111827; cursor: pointer; }
    .btn-secondary:hover { background: #e5e7eb; border-color: #c7ccd5; }
    .btn-secondary:active { background: #dbe0e8; }

    /* Prestep bilag slide: make download row more harmonious */
    .download-row { margin-top: 12px; padding-top: 12px; border-top: 1px solid #e6e8ef; display:flex; align-items:center; justify-content:space-between; gap: 12px; flex-wrap: wrap; }
    .download-row .download-label { margin: 0; color: #64748b; font-size: 13px; display:flex; align-items:center; min-height: 34px; }
    .download-row .btn-secondary.download-link { padding: 8px 12px; font-size: 13px; line-height: 1; display:inline-flex; align-items:center; justify-content:center; gap: 6px; }
    .download-row .download-icon { font-size: 14px; line-height: 1; transform: translateY(0.5px); }

    /* Step 2 (Brandklasse) compact layout to make room for figures */
    .step2-compact { padding: 14px; background: #ffffff; }
    .step2-status { text-align: center; margin: 2px 0 10px; }
    .step2-status.step2-status--instruction {
      font-size: 26px; /* ~2x the default muted size */
      font-weight: 700;
      color: #dc2626;
      margin: 10px 0 14px;
    }
    .step2-important { max-width: none; margin: 0 0 10px; }
    .step2-important .body { max-height: 120px; overflow: auto; line-height: 1.45; }
    .step2-legend { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; align-items: stretch; max-width: 1200px; margin: 0 auto; }
    .step2-legend--main { flex-wrap: nowrap; justify-content: center; }
    .step2-legend--main .legend-item { min-width: 0; flex: 1 1 0; max-width: 340px; }
    @media (max-width: 900px) {
      .step2-legend--main { flex-wrap: wrap; }
      .step2-legend--main .legend-item { min-width: 220px; flex: 1 1 220px; }
    }
    .legend-item { border: 1px solid #e6e8ef; border-radius: 10px; padding: 8px 10px; background: #fbfdff; min-width: 220px; }
    .legend-label { font-size: 11px; color: #64748b; margin-bottom: 2px; }
    .legend-value { font-weight: 800; color: #0f172a; font-size: 14px; }
    .legend-value.brand { color: #dc2626; font-size: 18px; }
    .legend-desc { display: none; }
    .step2-figures { margin-top: 12px; }
    .step2-figures .muted { font-size: 12px; }

    /* Step 2 figures carousel */
    /* Header text should align with the figure width and be easy to scan */
    .step2-figures .fig-header {
      max-width: 900px;
      margin: 0 auto 10px;
      padding: 10px 12px;
      border: 1px solid #e6e8ef;
      border-radius: 12px;
      background: #ffffff;
    }
    .step2-figures .fig-title {
      font-weight: 600;
      font-size: 13px;
      color: #0f172a;
      line-height: 1.35;
      text-align: justify;
      text-justify: inter-word;
      overflow-wrap: anywhere;
      hyphens: auto;
    }
    .step2-figures .fig-subtitle {
      font-size: 13px;
      color: #475569;
      margin-top: 6px;
      text-align: center;
    }
    .figure-carousel { display: flex; align-items: center; justify-content: center; gap: 12px; }
    .figure-nav-btn {
      width: 44px; height: 44px;
      border-radius: 12px;
      border: 1px solid #dbe3ef;
      background: #ffffff;
      color: #0f172a;
      font-size: 22px;
      font-weight: 900;
      cursor: pointer;
      user-select: none;
    }
    .figure-nav-btn:hover { background: #f8fafc; }
    .figure-nav-btn:active { background: #eef2ff; }
    .figure-nav-btn:disabled { opacity: 0.35; cursor: default; }
    .figure-stage { flex: 1; max-width: 900px; }
    .figure-frame {
      width: 100%;
      height: min(52vh, 520px);
      max-height: 520px;
      border: 1px solid #e6e8ef;
      border-radius: 14px;
      background: #f8fafc;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    .figure-frame img { max-width: 100%; max-height: 100%; object-fit: contain; display: block; }
    .figure-meta { text-align: center; margin-top: 10px; }
    .figure-meta .ref { font-weight: 900; font-size: 14px; color: #0f172a; }
    .figure-meta .count { font-size: 12px; color: #64748b; margin-left: 8px; }
    .figure-caption { margin-top: 6px; font-size: 13px; color: #475569; white-space: pre-wrap; text-align: justify; text-justify: inter-word; hyphens: auto; }
    .info-icon {
      display:inline-block; width:14px; height:14px; line-height:14px; text-align:center;
      border-radius:50%; border:1px solid #dc2626; color:#ffffff; font-size:10px; font-weight:600;
      margin-left:6px; cursor: pointer; background:#dc2626; vertical-align:middle; position:relative; top:1px; opacity:0.95;
    }
    /* Paragraf icons are slightly larger and use the theme blue */
    .info-icon.para-icon {
      width: 21px;
      height: 21px;
      line-height: 21px;
      font-size: 15px;
      border-color: #b91c1c;
      background: #b91c1c;
      margin-left: 10px;
      top: 0;
    }
    /* Disable pseudo-element tooltips; we use a JS-positioned tooltip so it never overflows the viewport. */
    .info-icon::after, .info-icon::before { content: none !important; }

    /* JS tooltip */
    #info-tooltip {
      position: fixed;
      z-index: 30000;
      display: none;
      background: rgba(182, 29, 29, 0.86);
      color: #ffffff;
      border: 1px solid rgba(255, 255, 255, 0.22);
      padding: 8px 14px;
      border-radius: 10px;
      box-shadow: 0 10px 28px rgba(2, 6, 23, 0.18);
      font-size: 12px;
      line-height: 1.35;
      max-width: 560px;
      box-sizing: border-box;
      pointer-events: none;
      white-space: pre-wrap;
    }
    #info-tooltip.visible { display: block; }
    #info-tooltip::after {
      content: '';
      position: absolute;
      left: var(--arrow-left, 16px);
      transform: translateX(-50%);
      width: 0; height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
    }
    #info-tooltip.above::after {
      bottom: -6px;
      border-top: 6px solid rgba(182, 29, 29, 0.86);
    }
    #info-tooltip.below::after {
      top: -6px;
      border-bottom: 6px solid rgba(182, 29, 29, 0.86);
    }
    
    /* Step-based wizard styling */
    .wizard-steps { display: flex; justify-content: center; gap: 24px; margin-bottom: 24px; }
    .wizard-step { display: flex; align-items: center; gap: 8px; }
    .step-number { width: 32px; height: 32px; border-radius: 50%; background: #e6e8ef; display: flex; align-items: center; justify-content: center; font-weight: 600; color: #666; }
    .wizard-step.active .step-number { background: #db3434; color: #fff; }
    .wizard-step.completed .step-number { background: #eeb0b0; color: #fff; }
    .step-label { font-size: 14px; color: #666; }
    .wizard-step.active .step-label { color: #333; font-weight: 600; }

    /* Make the top step indicators clickable */
    .wizard-step { cursor: pointer; user-select: none; }
    .wizard-step[role="button"]:focus-visible { outline: 3px solid #93c5fd; outline-offset: 4px; border-radius: 12px; }
    
    .wizard-content { display: none; }
    .wizard-content.active { display: block; }
    
    .continue-btn-wrapper { display: flex; justify-content: flex-end; margin-top: 16px; padding-top: 16px; border-top: 1px solid #e6e8ef; }
    
    /* =========================
       STEP 3 (Krav) presentation
       ========================= */
    .requirements-section { display: flex; flex-direction: column; gap: 12px; margin-top: 24px; }
    .krav-title-block { border: 1px solid #e6e8ef; border-radius: 14px; background: #ffffff; overflow: hidden; }
    .krav-title-header { padding: 14px 16px; background: #f8fafc; border-bottom: 1px solid #e6e8ef; display:flex; align-items:flex-start; justify-content:space-between; gap: 12px; }
    .krav-title-left { min-width: 0; }
    .krav-title { font-size: 18px; font-weight: 900; color:#0f172a; letter-spacing: -0.01em; display:inline-flex; align-items:center; gap: 8px; }
    .krav-subtitle { font-size: 15px; font-weight: 800; color:#1f2937; margin-top: 6px; display:flex; align-items:center; gap:8px; }
    .krav-subsubtitle { font-size: 15px; font-weight: 800; color:#553333; margin-top: 4px; display:flex; align-items:center; gap:8px; }
    .krav-mini { font-size: 12px; font-weight: 800; color:#694747; margin-top: 4px; text-transform: none; display:flex; align-items:center; gap:8px; }
    .krav-heading-actions { margin-left: auto; display: inline-flex; align-items: center; gap: 8px; }
    .krav-block-body { padding: 12px 16px 14px; }
    .krav-desc { margin: 4px 0 6px; color:#0f172a; }
    .krav-desc .label { font-size: 12px; font-weight: 800; color:#64748b; margin-bottom: 4px; }
    .krav-desc .text { font-style: italic; color:#0f172a; white-space: pre-wrap; line-height: 1.45; }

    .krav-group { padding: 10px 0; border-top: 1px dashed #e6e8ef; }
    .krav-group:first-child { border-top: none; }
    .krav-group-header { display:flex; align-items:center; justify-content:space-between; gap: 10px; }
    .krav-group-meta { display:flex; align-items:center; gap: 10px; flex-wrap: wrap; }
    .krav-id-badge {
      font-size: 11px;
      font-weight: 700;
      color:#8b6464;
      background:#f8fafc;
      border: 1px solid #e6e8ef;
      padding: 3px 8px;
      border-radius: 999px;
      letter-spacing: 0.01em;
    }
    .krav-actions { display:flex; align-items:center; gap: 8px; }
    .krav-check-all-btn {
      font-size: 11px;
      font-weight: 700;
      padding: 5px 10px;
      border-radius: 6px;
      border: 1px solid #16a34a;
      background: #16a34a;
      color: #ffffff;
      cursor: pointer;
      user-select: none;
      transition: all 0.2s ease;
    }
    .krav-check-all-btn:hover { background: #15803d; border-color: #15803d; }
    .krav-check-all-btn:active { background: #166534; border-color: #166534; }
    .krav-pill {
      font-size: 12px;
      font-weight: 800;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid #eb2525;
      background: #eb2525;
      color: #ffffff;
      cursor: pointer;
      user-select: none;
    }
    .krav-pill:hover { background: #d81d1d; border-color: #d81d1d; }
    .krav-pill:active { background: #af1e1e; border-color: #af1e1e; }
    .krav-pill:focus-visible { outline: 2px solid rgba(235, 37, 37, 0.35); outline-offset: 2px; }

    .krav-checklist { list-style: none; padding: 0; margin: 0; display:flex; flex-direction: column; gap: 8px; }
    .krav-check { display:flex; align-items:flex-start; justify-content:space-between; gap: 12px; padding: 10px 12px; border: 1px solid #e6e8ef; border-radius: 12px; background:#ffffff; }
    .krav-check-left { display:flex; align-items:flex-start; gap: 10px; flex: 1; min-width: 0; }
    .krav-check-left input[type="checkbox"] { 
      margin-top: 3px; 
      width: 18px; 
      height: 18px; 
      cursor: pointer;
      accent-color: #10b981;
    }
    .krav-check-text { font-size: 14px; color:#0f172a; line-height: 1.35; overflow-wrap: anywhere; transition: all 0.2s ease; }
    .krav-check.checked .krav-check-text { 
      text-decoration: line-through; 
      text-decoration-color: #10b981;
      text-decoration-thickness: 2px;
      color: #6b7280;
    }

    /* Step 3: Documentation uploads per requirement category */
    .cat-docs { margin: 10px 0 12px; padding: 12px; border: 1px solid #e6e8ef; border-radius: 12px; background: #f8fafc; }
    .cat-docs-header { display:flex; align-items:flex-start; justify-content:space-between; gap: 12px; }
    .cat-docs-title { font-size: 13px; font-weight: 900; color:#0f172a; letter-spacing: 0.02em; }
    .cat-docs-sub { margin-top: 4px; font-size: 12px; color:#64748b; line-height: 1.4; max-width: 720px; }
    .cat-docs-actions { display:flex; align-items:center; gap: 8px; flex-shrink: 0; }
    .cat-docs-list { margin-top: 10px; display:flex; flex-direction: column; gap: 10px; }
    .cat-doc-empty { font-size: 12px; color:#64748b; }
    .cat-doc-item { border: 1px solid #e6e8ef; border-radius: 12px; background: #ffffff; padding: 10px; }
    .cat-doc-item-top { display:flex; align-items:center; justify-content:space-between; gap: 10px; }
    .cat-doc-name { font-size: 13px; font-weight: 800; color:#0f172a; overflow-wrap:anywhere; }
    .cat-doc-fields { margin-top: 8px; display:grid; grid-template-columns: 1fr; gap: 8px; }
    .cat-doc-field-label { font-size: 11px; font-weight: 800; color:#64748b; margin-bottom: 4px; }
    .cat-doc-input, .cat-doc-textarea { width: 100%; border: 1px solid #e6e8ef; border-radius: 10px; padding: 10px 10px; font-size: 13px; font-family: inherit; }
    .cat-doc-textarea { resize: vertical; min-height: 52px; }
    .krav-check-right { display:flex; align-items:center; gap: 8px; }
    .krav-dim-row { display:flex; justify-content:flex-end; margin-top: 6px; }
    .q-icon {
      width: 22px; height: 22px; border-radius: 999px;
      border: 1px solid #dbe3ef; background:#ffffff; color:#0f172a;
      display:inline-flex; align-items:center; justify-content:center;
      font-weight: 900; font-size: 13px; cursor: pointer; user-select: none;
    }
    .q-icon:hover { background: #f8fafc; }
    /* Question icon should visually match the paragraph (Â§) icon when shown on headings */
    .q-icon.q-icon-big {
      width: 21px;
      height: 21px;
      line-height: 21px;
      font-size: 15px;
      border-color: #eb2525;
      background: #eb2525;
      color: #ffffff;
      margin-left: 10px;
    }
    .q-icon.q-icon-big:hover { background: #d81d1d; border-color: #d81d1d; }

    /* Use the existing tooltip system for paragraph icons */
    .para-icon { background: #0f172a; border-color: #0f172a; }

    /* Right panel viewer for figures/tables (Step 3) */
    .krav-viewer-card { min-height: 120px; }
    .krav-viewer-header { display:flex; align-items:center; justify-content:space-between; gap: 10px; margin-bottom: 10px; }
    .krav-viewer-title { font-weight: 900; font-size: 13px; color:#0f172a; letter-spacing: 0.02em; }
    .krav-viewer-body { display:none; }
    .krav-viewer-body.open { display:block; }
    .krav-viewer-slots { position: relative; min-height: 140px; }
    .krav-slot { position: absolute; left: 0; right: 0; }
    .krav-slot-actions {
      position: absolute;
      top: 8px;
      right: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 2;
    }
    .krav-slot-close {
      width: 30px;
      height: 30px;
      border-radius: 999px;
      border: 1px solid #dbe3ef;
      background: rgba(255,255,255,0.92);
      color: #0f172a;
      font-weight: 900;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }
    .krav-slot-close:hover { background: #ffffff; }
    .krav-slot-expand {
      width: 30px;
      height: 30px;
      border-radius: 999px;
      border: 1px solid #dbe3ef;
      background: rgba(255,255,255,0.92);
      color: #0f172a;
      font-weight: 900;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }
    .krav-slot-expand:hover { background: #ffffff; }
    .krav-viewer-placeholder { padding: 22px 12px; color:#64748b; font-size: 13px; text-align:center; }
    .krav-carousel { display:flex; align-items:center; justify-content:center; gap: 12px; }
    .krav-stage { flex: 1; }
    .krav-frame {
      width: 100%;
      border: 1px solid #e6e8ef;
      border-radius: 14px;
      background: #f8fafc;
      display:flex;
      align-items:center;
      justify-content:center;
      overflow: visible;
    }
    .krav-frame img { width: 100%; height: auto; object-fit: contain; display:block; }
    .krav-viewer-meta { text-align:center; margin-top: 10px; }
    .krav-viewer-meta .ref { font-weight: 900; font-size: 14px; color:#0f172a; }
    .krav-viewer-meta .count { font-size: 12px; color:#64748b; margin-left: 8px; }
    .krav-viewer-caption { margin-top: 6px; font-size: 13px; color:#475569; white-space: pre-wrap; }
    .krav-viewer-missing { margin-top: 8px; font-size: 12px; color:#ef4444; white-space: pre-wrap; }

    /* Fullscreen / expanded image viewer */
    .lightbox-overlay {
      position: fixed;
      inset: 0;
      z-index: 40000;
      display: none;
      padding: 20px;
      box-sizing: border-box;
      background: rgba(2, 6, 23, 0.78);
      align-items: center;
      justify-content: center;
    }
    .lightbox-overlay.open { display: flex; }
    .lightbox-modal {
      width: min(1280px, calc(100vw - 40px));
      height: min(92vh, 980px);
      background: #ffffff;
      border: 1px solid #e6e8ef;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 22px 70px rgba(2, 6, 23, 0.35);
      display: flex;
      flex-direction: column;
    }
    .lightbox-toolbar {
      padding: 10px;
      border-bottom: 1px solid #e6e8ef;
      background: #f8fafc;
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }
    .lightbox-btn {
      width: 36px;
      height: 36px;
      border-radius: 999px;
      border: 1px solid #dbe3ef;
      background: #ffffff;
      color: #0f172a;
      font-weight: 900;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      user-select: none;
    }
    .lightbox-btn:hover { background: #f8fafc; }
    .lightbox-stage {
      position: relative;
      flex: 1;
      background: #f8fafc;
      overflow: auto;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding: 14px;
      box-sizing: border-box;
    }
    .lightbox-stage img { width: 100%; height: auto; display: block; object-fit: contain; }
    .lightbox-nav {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 46px;
      height: 46px;
      border-radius: 14px;
      border: 1px solid #dbe3ef;
      background: rgba(255,255,255,0.92);
      color: #0f172a;
      font-size: 24px;
      font-weight: 900;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      user-select: none;
    }
    .lightbox-nav:hover { background: #ffffff; }
    .lightbox-nav:disabled { opacity: 0.35; cursor: default; }
    .lightbox-nav.prev { left: 12px; }
    .lightbox-nav.next { right: 12px; }
    .lightbox-meta {
      padding: 10px 12px;
      border-top: 1px solid #e6e8ef;
      background: #ffffff;
      text-align: center;
    }
    .lightbox-count { font-size: 12px; color: #64748b; font-weight: 700; }
    .lightbox-caption { margin-top: 6px; font-size: 13px; color: #475569; white-space: pre-wrap; }

    /* Lockable, draggable detail panel (Krav_Korrekt_Dimensionering) */
    #krav-dim-panel {
      position: fixed;
      z-index: 31000;
      display: none;
      width: min(720px, calc(100vw - 24px));
      max-height: min(70vh, 560px);
      overflow: hidden;
      border: 1px solid #e6e8ef;
      border-radius: 14px;
      background: #ffffff;
      box-shadow: 0 18px 64px rgba(2, 6, 23, 0.28);
    }
    .dim-header {
      background: #0f172a;
      color: #ffffff;
      padding: 10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      cursor: move;
      user-select: none;
    }
    .dim-title { font-weight: 900; font-size: 13px; }
    .dim-actions { display:flex; gap: 8px; align-items:center; }
    .dim-btn {
      font-size: 12px;
      font-weight: 800;
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.22);
      background: rgba(255,255,255,0.12);
      color:#ffffff;
      cursor: pointer;
    }
    .dim-btn:hover { background: rgba(255,255,255,0.18); }
    .dim-body { padding: 12px; overflow: auto; max-height: calc(min(70vh, 560px) - 44px); }
    .dim-body p { margin: 0 0 10px; white-space: pre-wrap; line-height: 1.45; color:#0f172a; }
    .dim-body p:last-child { margin-bottom: 0; }
    /* Small popup for tab rename */
    .mini-popup { position: fixed; z-index: 1000; background:#ffffff; border:1px solid #e6e8ef; box-shadow:0 8px 24px rgba(2,6,23,0.15); border-radius:8px; padding:8px; display:flex; align-items:center; gap:8px; }
    .mini-popup input { padding:6px 8px; border:1px solid #e6e8ef; border-radius:6px; min-width:200px; }
    .mini-popup .actions { display:flex; gap:6px; }
    
    /* Validation Modal */
    .validation-modal { 
      position: fixed; 
      top: 0; left: 0; right: 0; bottom: 0; 
      background: rgba(0,0,0,0.5); 
      /* Must stay above other overlays (lightbox, bilag overlay, dim panel, etc.) */
      z-index: 60000; 
      display: none; 
      align-items: center; 
      justify-content: center;
      padding: 20px;
    }
    .validation-modal.show { display: flex; }
    .validation-content { 
      background: white; 
      border-radius: 16px; 
      width: 90%; 
      max-width: 1400px; 
      max-height: 90vh; 
      display: flex; 
      flex-direction: column;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }
    .validation-header { 
      padding: 24px; 
      border-bottom: 1px solid #e6e8ef; 
      display: flex; 
      align-items: center; 
      justify-content: space-between;
    }
    .validation-header h2 { margin: 0; color: #ef4444; }
    .validation-body { 
      flex: 1; 
      overflow-y: auto; 
      padding: 24px;
    }
    .validation-footer {
      padding: 16px 24px;
      border-top: 1px solid #e6e8ef;
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }
    .validation-tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 24px;
      border-bottom: 2px solid #e6e8ef;
    }
    .validation-tab {
      padding: 12px 20px;
      background: none;
      border: none;
      border-bottom: 3px solid transparent;
      cursor: pointer;
      font-weight: 600;
      color: #64748b;
      transition: all 0.2s;
    }
    .validation-tab.active {
      color: #ef4444;
      border-bottom-color: #ef4444;
    }
    .validation-tab:hover {
      color: #dc2626;
    }
    .validation-section {
      display: none;
    }
    .validation-section.active {
      display: block;
    }
    .validation-item {
      border: 1px solid #e6e8ef;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 12px;
      background: #f8fafc;
    }
    .validation-item-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
    }
    .validation-item-title {
      font-weight: 600;
      color: #0f172a;
      flex: 1;
    }
    .validation-checkbox {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .validation-checkbox input[type="checkbox"] {
      width: 20px;
      height: 20px;
      accent-color: #10b981;
      cursor: pointer;
    }
    .validation-checkbox label {
      font-weight: 600;
      color: #10b981;
      cursor: pointer;
    }
    .validation-comment {
      width: 100%;
      min-height: 60px;
      padding: 8px 12px;
      border: 1px solid #e6e8ef;
      border-radius: 8px;
      font-family: inherit;
      font-size: 14px;
      margin-top: 8px;
    }
    .validation-comment:focus {
      outline: none;
      border-color: #f63b3b;
    }
    
    /* Custom Dropdown Styles */
    .custom-select-wrapper {
      position: relative;
      width: 100%;
    }
    .custom-select-wrapper select {
      display: none;
    }
    .custom-select {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px;
      border: 1px solid #e6e8ef;
      border-radius: 8px;
      background: #fff;
      cursor: pointer;
      user-select: none;
      font-size: 14px;
      min-height: 42px;
    }
    .custom-select:hover {
      border-color: #cbd5e1;
    }
    .custom-select.open {
      border-color: #dc2626;
      box-shadow: 0 0 0 3px rgba(220, 38, 38, 0.1);
      z-index: 6000;
    }
    .custom-select-trigger {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      gap: 8px;
    }
    .custom-select-value {
      flex: 1;
      color: #0f172a;
    }
    .custom-select-value.placeholder {
      color: #94a3b8;
    }
    .custom-select-arrow {
      width: 0;
      height: 0;
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
      border-top: 5px solid #64748b;
      transition: transform 0.2s ease;
    }
    .custom-select.open .custom-select-arrow {
      transform: rotate(180deg);
    }
    .custom-select-dropdown {
      position: absolute;
      top: calc(100% + 4px);
      left: 0;
      right: 0;
      background: #fff;
      border: 1px solid #e6e8ef;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      max-height: 300px;
      overflow-y: auto;
      z-index: 6001;
      display: none;
    }
    .custom-select.open .custom-select-dropdown {
      display: block;
    }
    .custom-option {
      padding: 10px 12px;
      cursor: pointer;
      transition: background-color 0.15s ease;
      font-size: 14px;
      color: #0f172a;
    }
    .custom-option:hover {
      background-color: #fef2f2;
      color: #991b1b;
    }
    .custom-option.selected {
      background-color: #fee2e2;
      color: #991b1b;
      font-weight: 600;
    }
    .custom-option.disabled {
      color: #94a3b8;
      cursor: default;
      font-style: italic;
    }
    .custom-option.disabled:hover {
      background-color: transparent;
      color: #94a3b8;
    }
    .custom-option-group-label {
      padding: 8px 12px;
      font-weight: 700;
      font-size: 13px;
      color: #475569;
      background: #f8fafc;
      cursor: default;
    }
    .custom-option-group-item {
      padding-left: 24px;
    }
    
    /* Confirmation modal */
    .confirm-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      padding: 24px;
    }
    .confirm-modal {
      background: white;
      border-radius: 12px;
      padding: 24px;
      max-width: 400px;
      width: 100%;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }
    .confirm-header {
      font-size: 18px;
      font-weight: 700;
      margin-bottom: 12px;
      color: #0f172a;
    }
    .confirm-message {
      color: #475569;
      margin-bottom: 24px;
      line-height: 1.5;
    }
    .confirm-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }
    .confirm-actions button {
      padding: 10px 20px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      border: 1px solid;
    }
    .confirm-btn-cancel {
      background: white;
      border-color: #cbd5e1;
      color: #475569;
    }
    .confirm-btn-cancel:hover {
      background: #f1f5f9;
    }
    .confirm-btn-confirm {
      background: #ef4444;
      border-color: #ef4444;
      color: white;
    }
    .confirm-btn-confirm:hover {
      background: #dc2626;
    }
    
    .decision-table {
      background: white;
      border: 1px solid #e6e8ef;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 8px;
    }
    .decision-rule {
      background: #f1f5f9;
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 8px;
    }
    .decision-rule:last-child {
      margin-bottom: 0;
    }
    .rule-conditions {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 8px;
      margin-bottom: 8px;
    }
    .rule-condition {
      font-size: 13px;
      padding: 6px 10px;
      background: white;
      border-radius: 6px;
      border: 1px solid #e2e8f0;
    }
    .rule-result {
      background: #dbeafe;
      padding: 8px 12px;
      border-radius: 6px;
      font-weight: 600;
      color: #af1e1e;
    }

    /* Step 4 documentation: split view (left inputs, right live draft) */
    .doc-overlay-grid {
      display: grid;
      grid-template-columns: 1fr 1.15fr;
      gap: 20px;
      align-items: start;
      min-height: 0;
    }
    .doc-overlay-top {
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 18px;
    }
    .doc-overlay-left {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .doc-overlay-left-card {
      background: #ffffff;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      padding: 20px;
    }
    .doc-overlay-preview {
      background: #ffffff;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      padding: 16px;
    }
    .doc-overlay-textarea {
      width: 100%;
      min-height: 520px;
      resize: vertical;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      padding: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12.5px;
      line-height: 1.45;
      background: #f8fafc;
      color: #0f172a;
      white-space: pre;
      overflow: auto;
    }

    /* Ensure the documentation overlay never grows beyond viewport */
    #doc-generator-overlay .bilag-modal {
      max-height: calc(100vh - 48px);
      display: flex;
      flex-direction: column;
    }
    #doc-generator-overlay .bilag-body {
      flex: 1 1 auto;
      min-height: 0;
      overflow: auto;
    }
    #doc-generator-overlay .bilag-actions {
      flex: 0 0 auto;
    }

    .doc-placeholder-fields {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    .doc-placeholder-fields .form-field label {
      font-weight: 600;
    }
    .doc-placeholder-fields textarea {
      min-height: 84px;
      resize: vertical;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      padding: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12.5px;
      line-height: 1.45;
      background: #ffffff;
      color: #0f172a;
    }

    .doc-attachment-box {
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 10px;
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      background: #ffffff;
    }
    .doc-attachment-row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    .doc-attachment-row input[type="file"] {
      max-width: 100%;
    }
    .doc-attachment-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .doc-attachment-item {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
      padding: 10px;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      background: #f8fafc;
    }
    .doc-attachment-meta {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      font-size: 12.5px;
      color: #0f172a;
    }
    .doc-attachment-meta .muted {
      color: #64748b;
    }
    .doc-attachment-item input[type="text"] {
      width: 100%;
    }
    @media (max-width: 1100px) {
      .doc-overlay-grid { grid-template-columns: 1fr; }
      .doc-overlay-textarea { min-height: 420px; }
    }
    #validation-btn:hover {
      background: #dc2626;
    }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="brand" style="cursor: pointer;" onclick="goToStep(1);" title="Tilbage til forsiden">
      <span class="logo"></span>
      <div class="titles">
        <div class="title">BR18 Komplet System</div>
        <div class="subtitle">Anvendelseskategori â†’ Risikoklasse â†’ Brandklasse</div>
      </div>
    </div>
    <div class="top-actions">
      <div id="validation-status-badge" style="display:none; padding: 6px 12px; background: #10b981; color: white; border-radius: 8px; font-size: 13px; font-weight: 600;">
        âœ“ System Valideret
      </div>
      <button id="save-project-btn" class="btn-secondary" style="padding: 8px 16px; font-weight: 600;">
        ðŸ’¾ Gem Projekt
      </button>
      <label for="load-project-input" class="btn-secondary" style="padding: 8px 16px; font-weight: 600; cursor: pointer; margin: 0;">
        ðŸ“‚ IndlÃ¦s Projekt
      </label>
      <input type="file" id="load-project-input" accept=".json" style="display: none;" />
      <button id="validation-btn" style="background: #ef4444; color: white; border: none; padding: 8px 16px; border-radius: 8px; font-weight: 600; cursor: pointer; transition: background 0.2s;">
        BrandrÃ¥dgiver Validering
      </button>
      <a href="#" class="muted">HjÃ¦lp</a>
    </div>
  </div>

  

  <div class="layout">
    <!-- Wizard Steps Indicator -->
    <div style="padding: 16px 24px 0 24px;">
      <div class="wizard-steps">
        <div class="wizard-step active" id="step-indicator-1">
          <div class="step-number">1</div>
          <div class="step-label">GrundlÃ¦ggende data</div>
        </div>
        <div class="wizard-step" id="step-indicator-2">
          <div class="step-number">2</div>
          <div class="step-label">Brandklasse</div>
        </div>
        <div class="wizard-step" id="step-indicator-3">
          <div class="step-number">3</div>
          <div class="step-label">Krav</div>
        </div>
        <div class="wizard-step" id="step-indicator-4">
          <div class="step-number">4</div>
          <div class="step-label">Opsummering</div>
        </div>
      </div>
      <!-- Current section name display -->
      <div id="current-section-name" style="text-align: center; margin-top: 12px; font-size: 45px; font-weight: 600; color: #dc2626;">
        Bygningsafsnit 1
      </div>
    </div>
    
    <div class="main" id="wizard-step-1">
      <!-- LEFT PANEL: Bygningsdata form (accordion) -->
      <div class="left-panel">
        <div class="card">
          <div style="display:flex; align-items:center; justify-content:space-between;">
            <h2 style="margin:0;">Bygningsdata</h2>
          </div>

          <!-- Continue Button (top) -->
          <div class="continue-btn-wrapper" style="margin-top: 12px; padding-top: 0; border-top: 0;">
            <button id="btn-continue-step1-top" class="btn-primary" style="padding: 12px 24px; font-size: 15px;">
              FortsÃ¦t til brandklasse â†’
            </button>
          </div>

          <!-- Step 1: flattened, ordered long list of fields (DOM moved here by JS) -->
          <div id="step1-field-list" class="step1-field-list"></div>

          <div class="accordion" id="data-accordion">
            <div class="acc-item open">
              <div class="acc-header">1. Generelt</div>
              <div class="acc-content">
                <div class="form-grid">
                  <div class="form-field">
                    <label>Bygningstype <span class="info-icon" title="VÃ¦lg den type bygning der bedst matcher projektet">i</span></label>
                    <select id="fld_bygningstype"></select>
                  </div>
                  <div class="form-field">
                    <label>Areal af bygningsafsnit [mÂ²] <span class="info-icon" title="Samlet bruttoareal for det aktuelle bygningsafsnit">i</span></label>
                    <input type="number" id="fld_area_BA" />
                  </div>
                  <div class="form-field">
                    <label>Er bygningen brandmÃ¦ssigt fritliggende? <span class="info-icon" title="En brandmÃ¦ssigt fritliggende bygning er en bygning, der ligger sÃ¥ langt fra andre bygninger, at en brand ikke forventes at kunne sprede sig til nabobygninger. To bygningsafsnit betragtes som brandmÃ¦ssigt fritliggende, hvis afstanden mellem de to bygningsafsnit svarer til mindst summen af de to bygningsafsnits afstandskrav til naboskel. Eksempelvis skal et enfamiliehus med facader udfÃ¸rt som beklÃ¦dning klasse K1 10 / D-s2,d2 [Klasse 2-beklÃ¦dning] og tagdÃ¦kning udfÃ¸rt som tagdÃ¦kning BROOF (t2) [Klasse T-tagdÃ¦kning] have en afstand pÃ¥ mindst 2,5 m til naboskel. For at to sÃ¥danne enfamiliehuse er brandmÃ¦ssigt fritliggende, skal afstanden mellem enfamiliehusene mindst vÃ¦re 2,5 m + 2,5 m = 5,0 m.">i</span></label>
                    <select id="fld_fritliggende_BA"><option value="" selected disabled>VÃ¦lgâ€¦</option><option value="true">Ja</option><option value="false">Nej</option></select>
                  </div>
                  <div class="form-field">
                    <label>Total bygningsareal (hele bygningen) [mÂ²] <span class="info-icon" title="Samlet bruttoareal for hele bygningen">i</span></label>
                    <input type="number" id="fld_area_total" />
                  </div>
                  <div class="form-field"><label>Er der direkte udgange? <span class="info-icon" title="Angiv om der findes direkte adgang til det fri fra alle opholdsrum i bygningsafsnittet">i</span></label><select id="fld_direkte_udgange"><option value="true" selected>Ja</option><option value="false">Nej</option></select></div>
                  <div class="form-field"><label>Er der direkte udgange fra soverummene? <span class="info-icon" title="Angiv om soverum har direkte udgang til det fri.">i</span></label><select id="fld_direkte_udgange_soverum"><option value="true" selected>Ja</option><option value="false">Nej</option></select></div>
                </div>
              </div>
            </div>
            <div class="acc-item">
              <div class="acc-header">2. Anvendelseskategori</div>
              <div class="acc-content">
                <div class="form-grid">
                  <div class="form-field"><label>Er der overnatning i bygningsafsnittet? <span class="info-icon" title="Angiv om brugerne forventes at sove eller opholde sig natten over i afsnittet">i</span></label><select id="fld_overnatning"><option value="" disabled selected>VÃ¦lgâ€¦</option><option value="true">Ja</option><option value="false">Nej</option></select></div>
                  <div class="form-field"><label>Har brugerne kendskab til flugtvejene? <span class="info-icon" title="Angiv om brugerne er bekendt med flugtveje og nÃ¸dudgange">i</span></label><select id="fld_kendskab_flugtveje"><option value="" disabled selected>VÃ¦lgâ€¦</option><option value="false">Nej</option><option value="true">Ja</option></select></div>
                  <div class="form-field"><label>Er brugerne selvhjulpne? <span class="info-icon" title="Angiv om brugerne kan evakuere pÃ¥ egen hÃ¥nd uden assistance">i</span></label><select id="fld_selvhjulpen"><option value="" disabled selected>VÃ¦lgâ€¦</option><option value="true">Ja</option><option value="false">Nej</option></select></div>
                  <div class="form-field"><label>Hvor mange personer forventes at bruge bygningsafsnittet? <span class="info-icon" title="Angiv hvor mange personer der maksimalt forventes at bruge bygningsafsnittet pÃ¥ samme tid">i</span></label><input type="number" id="fld_antal_personer_BA" value="55"/></div>
                </div>
              </div>
            </div>
            <div class="acc-item">
              <div class="acc-header">3. Bygning & etager</div>
              <div class="acc-content">
                <div class="form-grid">
                  <div class="form-field"><label>Hvor mange etager er der over terrÃ¦n i bygningsafsnittet? <span class="info-icon" title="Antal etager der ligger over terrÃ¦n-niveau">i</span></label><input type="number" id="fld_antal_etager_over_terraen_BA" value="1"/></div>
                  <div class="form-field"><label>Hvor mange etager under terrÃ¦n er der i bygningsafsnittet? <span class="info-icon" title="Antal etager der ligger under terrÃ¦n-niveau">i</span></label><input type="number" id="fld_antal_etager_under_terraen_BA" value="1"/></div>
                  <div class="form-field"><label>Hvad er Ã¸verste etages gulvhÃ¸jde for hele bygningen? [m] <span class="info-icon" title="GulvhÃ¸jde for den Ã¸verste etage i hele bygningen, mÃ¥lt fra terrÃ¦n">i</span></label><input type="number" id="fld_etage_hoejde" /></div>
                  <div class="form-field"><label>Hvad er Ã¸verste etages gulvhÃ¸jde i dette bygningsafsnit? [m] <span class="info-icon" title="GulvhÃ¸jde for den Ã¸verste etage i dette bygningsafsnit, mÃ¥lt fra terrÃ¦n">i</span></label><input type="number" id="fld_etage_hoejde_BA" value="9"/></div>
                  <div class="form-field"><label>Hvad er bygningsafsnittets dybde under terrÃ¦n? [m] <span class="info-icon" title="GulvhÃ¸jde af nederste kÃ¦lderetage i bygningsafsnittet under terrÃ¦n, mÃ¥lt fra terrÃ¦n">i</span></label><input type="number" id="fld_etage_dybde_BA" value="4.9"/></div>
                  <div class="form-field"><label>Hvor mange etager er der i bygningsafsnittet? <span class="info-icon" title="Samlet antal etager i det pÃ¥gÃ¦ldende bygningsafsnit.">i</span></label><input type="number" id="fld_antal_etager_BA" value="2"/></div>
                </div>
              </div>
            </div>
            <div class="acc-item">
              <div class="acc-header">4. Brandbelastning</div>
              <div class="acc-content">
                <div class="form-grid">
                  <div class="form-field"><label>Hvad er bygningens brandbelastning? [MJ/mÂ²] <span class="info-icon" title="Forventet brandbelastning pr. kvadratmeter. Kan udregnes, men opdeles ogsÃ¥ i fÃ¸lgende grupper (SÃ¥fremt byggeriet ikke indebÃ¦rer risiko for hÃ¸j brandbelastning, sÃ¥som visse lagerbygninger med stort inventar, kan der blot angives en estimeret vÃ¦rdi inden for den lave brandbelastningsgruppe):&#10;â€¢ Ultra lav brandbelastning: HÃ¸jst 50 MJ/mÂ²&#10;â€¢ Meget lav brandbelastning: Fra 50 MJ/mÂ² og hÃ¸jst 250 MJ/mÂ²&#10;â€¢ Lav brandbelastning: Fra 250 MJ/mÂ² og hÃ¸jst 800 MJ/mÂ²&#10;â€¢ Stor brandbelastning: Fra 800 MJ/mÂ² og hÃ¸jst 1.600 MJ/mÂ²&#10;â€¢ Meget stor brandbelastning: StÃ¸rre end 1.600 MJ/mÂ²">i</span></label><input type="number" id="fld_brandbelastning_BA" value="1500"/></div>
                </div>
              </div>
            </div>
            <div class="acc-item">
              <div class="acc-header">5. SÃ¦rlige forhold</div>
              <div class="acc-content">
                <div class="form-grid">
                  <div class="form-field">
                    <label>Er der en tilbygning? <span class="info-icon" title="Angiv om der er en tilbygning.">i</span></label>
                    <select id="fld_med_tilbygning"><option value="" selected disabled>VÃ¦lgâ€¦</option><option value="false">Nej</option><option value="true">Ja</option></select>
                  </div>
                  <div class="form-field">
                    <label>Er der erhvervssammenbygning? <span class="info-icon" title="Angiv om bygningen er sammenbygget med erhverv">i</span></label>
                    <select id="fld_med_erhvervssammenbygning"><option value="" selected disabled>VÃ¦lgâ€¦</option><option value="false">Nej</option><option value="true">Ja</option></select>
                  </div>
                  <div class="form-field">
                    <label>Antal fravigelser fra prÃ¦-accepterede <span class="info-icon" title="Hvis byggeriet ikke kan henfÃ¸res til en prÃ¦-accepteret lÃ¸sning, indplaceres det i brandklasse 2, sÃ¥ lÃ¦nge der er fÃ¦rre end fem vÃ¦sentlige fravigelser. Dette krÃ¦ver, at en certificeret brandrÃ¥dgiver (BK2) inddrages. Som udgangspunkt angives 0, men vÃ¦r opmÃ¦rksom pÃ¥, at et stÃ¸rre antal fravigelser har betydning og vil krÃ¦ve yderligere brandrÃ¥dgivning ud over dette vÃ¦rktÃ¸j">i</span></label>
                    <input type="number" id="fld_antal_fravigelser_fra_praeaccepterede" />
                  </div>
                  <div class="form-field"><label>Er nogle af bygningsafnittene i risikoklasse 4? <span class="info-icon" title="Angiv om dele af bygningen klassificeres som risikoklasse 4.">i</span></label><select id="fld_bygningsafsnit_i_RK4"><option value="false" selected>Nej</option><option value="true">Ja</option></select></div>
                  <div class="form-field"><label>Hvor mange overnattende forventes der? <span class="info-icon" title="Angiv antal personer der overnatter i afsnittet.">i</span></label><input type="number" id="fld_antal_overnattende" value="5"/></div>
                </div>
              </div>
            </div>
            <div class="acc-item">
            </div>
          </div>
          
          <!-- Continue Button -->
          <div class="continue-btn-wrapper">
            <button id="btn-continue-step1" class="btn-primary" style="padding: 12px 24px; font-size: 15px;">
              FortsÃ¦t til brandklasse â†’
            </button>
          </div>
        </div>
      </div>

      <!-- RIGHT PANEL: Tabs JSON / Resultater -->
      <div class="right-panel">
        <div class="card">
          <div class="accordion" id="right-accordion">
            <div class="acc-item open" id="acc-json">
              <div class="acc-header">JSON</div>
              <div class="acc-content">
                <div style="border:1px solid #e6e8ef; border-radius:10px; padding:12px; background:#fafbfc;">
                  <div style="font-weight:600; margin-bottom:6px;">Fast track (upload/download)</div>
                  <div class="muted" style="margin-bottom:10px;">
                    Hvis du allerede kender felterne, kan du hente en tom JSON-skabelon, udfylde den og uploade den.
                    Du kan ogsÃ¥ uploade en delvist udfyldt JSON â€” felter der er tomme (null/"") overskriver ikke formularen.
                  </div>
                  <input type="file" id="file-input" accept=".json" style="display:none;" />
                  <div style="display:flex; flex-wrap:wrap; gap:8px;">
                    <button id="btn-download-template" class="btn-secondary">Hent JSON-skabelon</button>
                    <button id="btn-upload-json" class="btn-secondary">Upload JSONâ€¦</button>
                    <button id="btn-toggle-json" class="btn-secondary">Vis avanceret JSON</button>
                    <button id="load-example" class="btn-secondary">IndlÃ¦s eksempel</button>
                  </div>
                </div>

                <div id="json-advanced" style="display:none; margin-top:10px;">
                  <div class="upload-area" id="upload-area" style="padding:14px;">
                    <div style="font-size: 1.1rem;">ðŸ“ Drag/drop JSON her (eller klik)</div>
                  </div>
                  <textarea id="json-textarea" class="json-textarea"></textarea>
                </div>
              </div>
            </div>
            <div class="acc-item open" id="acc-results">
              <div class="acc-header">Resultater</div>
              <div class="acc-content">
                <h3 id="headline-results" style="margin-top:0;">Resultater</h3>
                <div class="muted" style="margin-top: -6px;">Status viser om der er nok data til at beregne feltet.</div>
                <div class="results-list" id="results-list-step1">
                  <div class="result-row" data-key="anvendelse" data-result-row="anvendelse">
                    <div class="left">
                      <div class="result-label">Anvendelseskategori</div>
                      <div id="result-anvendelse-desc" class="result-help"></div>
                    </div>
                    <div class="result-right">
                      <div id="result-anvendelse" class="result-value-inline result-value">-</div>
                      <span id="result-anvendelse-status" class="result-status missing" aria-label="Mangler data" style="display:none;">!</span>
                    </div>
                  </div>

                  <div class="result-row" data-key="risiko" data-result-row="risiko">
                    <div class="left">
                      <div class="result-label">Risikoklasse</div>
                      <div id="result-risiko-desc" class="result-help"></div>
                    </div>
                    <div class="result-right">
                      <div id="result-risiko" class="result-value-inline result-value">-</div>
                      <span id="result-risiko-status" class="result-status missing" aria-label="Mangler data" style="display:none;">!</span>
                    </div>
                  </div>

                  <div class="result-row" data-key="bilag" data-result-row="bilag">
                    <div class="left">
                      <div class="result-label">Relevant bilag</div>
                      <div id="result-bilag-desc" class="result-help"></div>
                    </div>
                    <div class="result-right">
                      <div id="result-bilag" class="result-value-inline result-value">-</div>
                      <span id="result-bilag-status" class="result-status missing" aria-label="Mangler data" style="display:none;">!</span>
                    </div>
                  </div>

                  <div class="result-row" data-key="brand" data-result-row="brandklasse">
                    <div class="left">
                      <div class="result-label">Brandklasse</div>
                      <div id="result-brand-desc" class="result-help"></div>
                    </div>
                    <div class="result-right">
                      <div id="result-brand" class="result-value-inline result-value">-</div>
                      <span id="result-brand-status" class="result-status missing" aria-label="Mangler data" style="display:none;">!</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- STEP 2: Bilag & Brandklasse -->
    <div class="main wizard-content" id="wizard-step-2" style="display:none;">
      <div class="left-panel" style="flex: 1;">
        <div class="card">
          <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom: 12px;">
            <h2 style="margin:0;">Brandklasse</h2>
            <button id="btn-back-step2" class="btn-secondary">â† Tilbage til input</button>
          </div>

          <div class="card step2-compact">
            <div id="step2-bk-status" class="muted step2-status">Udfyld input pÃ¥ side 1. Brandklasse beregnes der og vises her.</div>

            <!-- Vigtig information (centered at top, kept compact) -->
            <div id="step2-out-important" class="card step2-important" style="display:none; background:#eff6ff; border: 1px solid #bfdbfe;">
              <div style="font-weight: 850; color:#1e3a8a; margin-bottom: 6px; text-align:center;">Vigtig information</div>
              <div id="step2-out-important-text" class="body" style="color:#0f172a;"></div>
            </div>

            <!-- Legend-style outputs (left aligned, small boxes) -->
            <div id="step2-outputs" style="display:none;">
              <div class="step2-legend step2-legend--main">
                <div id="step2-bk-inline" class="legend-item" style="display:none;">
                  <div class="legend-label">Hvilken brandklasse:</div>
                  <div id="step2-bk-inline-value" class="legend-value brand">-</div>
                  <div id="step2-bk-inline-desc" class="legend-desc"></div>
                </div>
                <div class="legend-item">
                  <div class="legend-label">Er der krav til brandrÃ¥dgiver?</div>
                  <div id="step2-out-brandraadgiver" class="legend-value">-</div>
                </div>
                <div class="legend-item">
                  <div class="legend-label">Hvilket certificeringsniveau skal brandrÃ¥dgiveren have?</div>
                  <div id="step2-out-cert" class="legend-value">-</div>
                </div>
                <div class="legend-item">
                  <div class="legend-label">Er der yderligere krav?</div>
                  <div id="step2-out-krav" class="legend-value">-</div>
                </div>
              </div>
            </div>

            <!-- Figures get the remaining space below -->
            <div id="step2-out-figures" class="card step2-figures" style="padding: 12px; margin-top: 12px; display:none;">
              <div class="fig-header">
                <div id="step2-fig-title" class="fig-title" style="white-space: normal; line-height: 1.2; display:none;"></div>
                <div id="step2-fig-subtitle" class="fig-subtitle" style="display:none;"></div>
              </div>
              <div id="step2-figures-debug" class="muted" style="display:none; margin-bottom: 10px; white-space: pre-wrap;"></div>

              <div id="step2-figure-carousel" class="figure-carousel" style="display:none;">
                <button id="step2-fig-prev" class="figure-nav-btn" type="button" aria-label="Forrige figur">â€¹</button>
                <div class="figure-stage">
                  <div class="figure-frame">
                    <img id="step2-fig-img" alt="" />
                  </div>
                  <div class="figure-meta">
                    <div>
                      <span id="step2-fig-ref" class="ref" style="display:none;">-</span>
                      <span id="step2-fig-count" class="count"></span>
                    </div>
                    <div id="step2-fig-caption" class="figure-caption" style="display:none;"></div>
                    <div id="step2-fig-missing" class="muted" style="display:none; margin-top: 6px; white-space: pre-wrap;"></div>
                  </div>
                </div>
                <button id="step2-fig-next" class="figure-nav-btn" type="button" aria-label="NÃ¦ste figur">â€º</button>
              </div>
            </div>
          </div>

          <div class="continue-btn-wrapper">
            <button id="btn-continue-step2" class="btn-primary" style="padding: 12px 24px; font-size: 15px;" disabled>FortsÃ¦t til krav â†’</button>
          </div>
        </div>
      </div>
    </div>

    <!-- STEP 3: Krav & resultater -->
    <div class="main wizard-content" id="wizard-step-3" style="display:none;">
      <div class="left-panel">
        <div class="card">
          <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom: 16px;">
            <h2 style="margin:0;">ðŸ“‹ Krav for dit projekt</h2>
            <div style="display: flex; gap: 12px; align-items: center;">
              <button id="btn-back-step3" class="btn-secondary">â† Tilbage til brandklasse</button>
              <button id="btn-continue-step3-top" class="btn-primary" style="padding: 10px 20px; font-size: 14px;">
                GÃ¥ til opsummering â†’
              </button>
            </div>
          </div>
          
          <div style="background: #f0f9ff; border: 1px solid #3498db; border-radius: 8px; padding: 12px 16px; margin-bottom: 16px;">
            <div style="display: flex; gap: 16px; align-items: center;">
              <div style="flex: 1;">
                <div style="font-size: 13px; color: #666; margin-bottom: 4px;">Relevant bilag</div>
                <div style="font-weight: 600; font-size: 16px;" id="display-bilag">-</div>
              </div>
              <div style="flex: 1;">
                <div style="font-size: 13px; color: #666; margin-bottom: 4px;">Anvendelseskategori</div>
                <div style="font-weight: 600; font-size: 16px;" id="display-ak">-</div>
              </div>
              <div style="flex: 1;">
                <div style="font-size: 13px; color: #666; margin-bottom: 4px;">Risikoklasse</div>
                <div style="font-weight: 600; font-size: 16px;" id="display-rk">-</div>
              </div>
              <div style="flex: 1;">
                <div style="font-size: 13px; color: #666; margin-bottom: 4px;">Brandklasse</div>
                <div style="font-weight: 600; font-size: 20px; color: #3498db;" id="display-bk">-</div>
              </div>
            </div>
          </div>
          
          <div class="requirements-section" id="requirements-container">
            <!-- Dynamically populated requirements -->
            <div style="text-align: center; padding: 48px; color: #999;">
              <div style="font-size: 48px; margin-bottom: 16px;">ðŸ“‹</div>
              <div>Krav vises nÃ¥r brandklassen er bestemt</div>
            </div>
          </div>
          
          <div class="continue-btn-wrapper" style="margin-top: 24px;">
            <button id="btn-continue-step3" class="btn-primary" style="padding: 12px 24px; font-size: 15px;">
              GÃ¥ til opsummering â†’
            </button>
          </div>
          
        </div>
      </div>
      
      <div class="right-panel">
        <div class="card krav-viewer-card">
          <div class="krav-viewer-header">
            <div id="krav-viewer-title" class="krav-viewer-title">RELEVANTE FIGURER / TABELLER</div>
            <button id="krav-viewer-minimize" class="btn-secondary" type="button" style="padding: 8px 12px;">Vis</button>
          </div>
          <div id="krav-viewer-body" class="krav-viewer-body">
            <div id="krav-viewer-slots" class="krav-viewer-slots">
              <div id="krav-viewer-placeholder" class="krav-viewer-placeholder">Klik â€œSe figur(er)â€ eller â€œSe tabel(ler)â€ ved et krav for at fÃ¥ vist materialet her.</div>
            </div>

            <div id="krav-viewer-carousel" class="krav-carousel" style="display:none;">
              <button id="krav-viewer-prev" class="figure-nav-btn" type="button" aria-label="Forrige">â€¹</button>
              <div class="krav-stage">
                <div class="krav-frame">
                  <img id="krav-viewer-img" alt="" />
                </div>
                <div class="krav-viewer-meta">
                  <div>
                    <span id="krav-viewer-ref" class="ref" style="display:none;">-</span>
                    <span id="krav-viewer-count" class="count"></span>
                  </div>
                  <div id="krav-viewer-caption" class="krav-viewer-caption" style="display:none;"></div>
                  <div id="krav-viewer-missing" class="krav-viewer-missing" style="display:none;"></div>
                </div>
              </div>
              <button id="krav-viewer-next" class="figure-nav-btn" type="button" aria-label="NÃ¦ste">â€º</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- STEP 4: Opsummering -->
    <div class="main wizard-content" id="wizard-step-4" style="display:none;">
      <div class="card" style="max-width: 1400px; margin: 0 auto;">
        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom: 24px;">
          <div>
            <h2 style="margin:0 0 8px 0;">ðŸ“Š Samlet opsummering</h2>
            <p style="margin:0; color:#666;">Overblik over alle bygningsafsnit og deres brandklassificering</p>
          </div>
          <button id="btn-back-step4" class="btn-secondary">â† Tilbage til krav</button>
        </div>

        <!-- Project summary header -->
        <div style="background:#ffffff; border:1px solid #e6e8ef; border-radius: 12px; padding: 18px 20px; margin-bottom: 24px; color:#0f172a;">
          <div style="display:flex; justify-content:space-between; align-items:flex-start; gap: 16px;">
            <div>
              <div style="font-size: 12px; font-weight: 700; color:#64748b; margin-bottom: 6px;">Projekt</div>
              <div style="font-size: 22px; font-weight: 800;" id="summary-project-name">Bygningsprojekt</div>
            </div>
            <div style="text-align: right;">
              <div style="font-size: 12px; font-weight: 700; color:#64748b; margin-bottom: 6px;">Status</div>
              <div style="display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border:1px solid #e6e8ef; border-radius:999px; background:#f8fafc; font-size: 12px; font-weight: 800;">
                <span id="summary-completed-count">0</span>/<span id="summary-total-count">0</span>
                <span style="font-weight:700; color:#64748b;">fÃ¦rdige</span>
              </div>
            </div>
          </div>
        </div>

        <!-- Sections overview -->
        <div id="final-overview" style="display: flex; flex-direction: column; gap: 12px;">
          <!-- Populated by renderFinalOverview() -->
        </div>

        <div id="final-summary" style="margin-top: 24px; padding: 14px 16px; background: #f8fafc; border: 1px solid #e6e8ef; border-radius: 10px; color: #334155; font-size: 14px; text-align: center;">
          <!-- Summary text -->
        </div>

        <!-- Next steps guide based on brandklasse -->
        <div id="next-steps-guide" style="display: none; margin-top: 32px;">
          <!-- Content will be dynamically generated based on brandklasse -->
        </div>

        <!-- Export actions -->
        <div style="display: flex; gap: 12px; margin-top: 32px; padding-top: 24px; border-top: 1px solid #e6e8ef; justify-content: center;">
          <button id="btn-export-pdf" class="btn-secondary" style="padding: 12px 24px;">
            ðŸ“„ Eksporter til PDF
          </button>
          <button id="btn-export-json" class="btn-secondary" style="padding: 12px 24px;">
            ðŸ’¾ Download JSON
          </button>
          <button id="btn-new-project" class="btn-primary" style="padding: 12px 24px;">
            âž• Start nyt projekt
          </button>
        </div>
      </div>
    </div>

    <!-- Building + Section Tabs Footer -->
    <div id="building-tabs" style="display:flex; flex-wrap:wrap; gap:8px; align-items:center; padding:8px 24px; border-top:1px solid #e6e8ef; background:#f8fafc;"></div>
    <div id="section-tabs" style="display:flex; flex-wrap:wrap; gap:8px; align-items:center; padding:8px 24px; border-top:1px solid #e6e8ef; background:#fafafa;"></div>

    <!-- BOTTOM ACTION BAR -->
    <div class="bottombar">
      <div id="status-line" class="muted">Sidst opdateret: â€“</div>
      <div style="display:flex; gap:8px;"></div>
    </div>
  </div>

  <!-- Pre-step explainer overlay (shown before Step 2) -->
  <div id="prestep-overlay" class="prestep-overlay" aria-hidden="true">
    <div class="prestep-modal">
      <div class="prestep-header">
        <div>
          <div class="prestep-kicker">Overblik fÃ¸r du gÃ¥r videre</div>
          <h2 id="prestep-title" style="margin: 2px 0 0;">Forklaring af resultater</h2>
        </div>
        <button id="prestep-close" class="btn-secondary" type="button">Luk</button>
      </div>
      <div id="prestep-steps" class="prestep-steps"></div>
      <div id="prestep-content" class="prestep-content"></div>
      <div class="continue-btn-wrapper" style="justify-content: space-between;">
        <button id="prestep-back" class="btn-secondary" type="button">â† Tilbage</button>
        <div style="display:flex; gap:8px;">
          <button id="prestep-skip" class="btn-secondary" type="button">Spring over</button>
          <button id="prestep-next" class="btn-primary" type="button">NÃ¦ste â†’</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Documentation Generator Overlay (Step 4) -->
  <div id="doc-generator-overlay" class="bilag-overlay" aria-hidden="true" style="display: none;">
    <div class="bilag-modal" style="max-width: 1280px;">
      <div class="bilag-header">
        <div>
          <div class="bilag-kicker">Brandklasse 1 Dokumentation</div>
          <h2 style="margin: 2px 0 0;">Generer dokumentation til kommunalbestyrelsen</h2>
          <div class="muted" style="margin-top:6px;">Udfyld projektinformation nedenfor. VÃ¦rktÃ¸jet genererer automatisk den tekniske information.</div>
        </div>
        <button id="doc-gen-close" class="btn-secondary" type="button">Luk</button>
      </div>

      <div class="bilag-body" style="padding: 24px;">

        <div class="doc-overlay-top">
          <h3 style="margin: 0 0 12px 0; font-size: 16px; font-weight: 600; color: #0f172a;">Teknisk information (genereres automatisk)</h3>
          <div style="display: grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap: 12px; font-size: 14px;">
            <div>
              <span style="color: #64748b;">Dato:</span>
              <strong style="color: #0f172a; margin-left: 8px;" id="doc-preview-dato"></strong>
            </div>
            <div>
              <span style="color: #64748b;">Version:</span>
              <strong style="color: #0f172a; margin-left: 8px;">1.0</strong>
            </div>
            <div>
              <span style="color: #64748b;">Bygningstype:</span>
              <strong style="color: #0f172a; margin-left: 8px;" id="doc-preview-bygningstype"></strong>
            </div>
            <div>
              <span style="color: #64748b;">Forudsat brandklasse:</span>
              <strong style="color: #0f172a; margin-left: 8px;">1</strong>
            </div>
            <div>
              <span style="color: #64748b;">Anvendelseskategori:</span>
              <strong style="color: #0f172a; margin-left: 8px;" id="doc-preview-ak"></strong>
            </div>
            <div>
              <span style="color: #64748b;">Risikoklasse:</span>
              <strong style="color: #0f172a; margin-left: 8px;" id="doc-preview-rk"></strong>
            </div>
          </div>
        </div>

        <div class="doc-overlay-grid">
          <!-- LEFT: inputs + technical preview -->
          <div class="doc-overlay-left">
            <div class="doc-overlay-left-card">
              <h3 style="margin: 0 0 10px 0; font-size: 16px; font-weight: 600; color: #0f172a;">Projektinformation og dokumentfelter</h3>
              <div class="muted" style="margin-top: 10px; line-height: 1.55;">
                Der skal udarbejdes dokumentation for brandforhold, som redegÃ¸r for, hvordan brandsikkerheden i enfamiliehuset pÃ¥tÃ¦nkes udfÃ¸rt, og som dokumenterer, at byggeriet er i overensstemmelse med de prÃ¦-accepterede lÃ¸sninger. For byggeri omfattet af brandklasse 1 skal dokumentationen for brandforhold omfatte alt relevant materiale for byggeriet. Dette inkluderer overordnede beskrivelser og forudsÃ¦tninger, en redegÃ¸relse for valg af brandklasse samt oplysninger om og dokumentation for byggeriets indsatsmÃ¦ssige forhold.
              </div>

              <div style="margin-top: 16px;">
                <div class="form-grid" style="gap: 16px;">
                  <div class="form-field">
                    <label for="doc-projektnavn" style="font-weight: 600;">Projektnavn *</label>
                    <input type="text" id="doc-projektnavn" placeholder="F.eks. Nyt enfamiliehus, Storegade 123" required>
                  </div>
                  <div class="form-field">
                    <label for="doc-adresse" style="font-weight: 600;">Adresse og matrikel *</label>
                    <input type="text" id="doc-adresse" placeholder="F.eks. Storegade 123, 8000 Aarhus C, Matr.nr. 12a" required>
                  </div>
                  <div class="form-field">
                    <label for="doc-bygherre" style="font-weight: 600;">Bygherre *</label>
                    <input type="text" id="doc-bygherre" placeholder="F.eks. Jens Jensen" required>
                  </div>
                  <div class="form-field">
                    <label for="doc-raadgiver" style="font-weight: 600;">RÃ¥dgiver *</label>
                    <input type="text" id="doc-raadgiver" placeholder="F.eks. ABC Arkitekter ApS" required>
                  </div>
                </div>
              </div>

              <div style="height: 1px; background: #e2e8f0; margin: 18px 0;"></div>

              <div style="display:flex; align-items:baseline; justify-content:space-between; gap: 12px; flex-wrap: wrap;">
                <h3 style="margin: 0; font-size: 16px; font-weight: 600; color: #0f172a;">Dokumentfelter</h3>
                <div id="doc-placeholder-summary" class="muted" style="font-size: 13px;"></div>
              </div>
              <div id="doc-placeholder-fields" class="doc-placeholder-fields" style="margin-top: 14px;"></div>
            </div>

          </div>

          <!-- RIGHT: live editable draft -->
          <div class="doc-overlay-preview">
            <div style="display:flex; align-items:flex-start; justify-content:space-between; gap: 12px;">
              <div>
                <div style="font-weight:700; color:#0f172a;">Dokument (udkast)</div>
                <div class="muted" style="margin-top:4px;">Du kan skrive direkte her. â€œGenerer dokumentâ€ downloader teksten som den ser ud nu.</div>
              </div>
              <button id="doc-gen-refresh" class="btn-secondary" type="button" style="padding: 10px 14px;">â†» Opdater udkast</button>
            </div>
            <div style="margin-top: 12px;">
              <textarea id="doc-live-text" class="doc-overlay-textarea" spellcheck="false" placeholder="Udkast genereres nÃ¥r du Ã¥bner denne dialog..."></textarea>
            </div>
          </div>
        </div>
      </div>

      <div class="bilag-actions">
        <button id="doc-gen-cancel" class="btn-secondary" type="button">Annuller</button>
        <button id="doc-gen-export-pdf" class="btn-secondary" type="button">ðŸ“„ PDF</button>
        <button id="doc-gen-export-html" class="btn-secondary" type="button">ðŸ–¨ï¸ Print (HTML)</button>
        <button id="doc-gen-export-docx" class="btn-secondary" type="button">ðŸ“ Word (DOCX)</button>
        <button id="doc-gen-generate" class="btn-primary" type="button">ðŸ“„ TXT</button>
      </div>
    </div>
  </div>

  <!-- Bilag input overlay (shown before Step 3) -->
  <div id="bilag-overlay" class="bilag-overlay" aria-hidden="true">
    <div class="bilag-modal">
      <div class="bilag-header">
        <div>
          <div class="bilag-kicker">Ekstra oplysninger fÃ¸r krav</div>
          <h2 id="bilag-title" style="margin: 2px 0 0;">Udfyld bilag-specifikke oplysninger</h2>
          <div id="bilag-subtitle" class="muted" style="margin-top:6px;">Disse spÃ¸rgsmÃ¥l afhÃ¦nger af dit relevante bilag og bruges til at finde de korrekte krav.</div>
        </div>
        <button id="bilag-close" class="btn-secondary" type="button">Luk</button>
      </div>

      <div id="bilag-body" class="bilag-body"></div>

      <div class="bilag-actions">
        <button id="bilag-reset" class="btn-secondary" type="button">Nulstil bilag-svar</button>
        <div class="right">
          <button id="bilag-skip" class="btn-secondary" type="button">Spring over</button>
          <button id="bilag-save" class="btn-primary" type="button">Gem og fortsÃ¦t â†’</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Fullscreen / expanded image viewer (figures & tables) -->
  <div id="image-lightbox" class="lightbox-overlay" aria-hidden="true">
    <div class="lightbox-modal" role="dialog" aria-modal="true" aria-label="Udvidet figurvisning">
      <div class="lightbox-toolbar">
        <button id="lightbox-close" class="lightbox-btn" type="button" aria-label="Luk">Ã—</button>
      </div>
      <div class="lightbox-stage">
        <button id="lightbox-prev" class="lightbox-nav prev" type="button" aria-label="Forrige">â€¹</button>
        <img id="lightbox-img" alt="" />
        <button id="lightbox-next" class="lightbox-nav next" type="button" aria-label="NÃ¦ste">â€º</button>
      </div>
      <div class="lightbox-meta">
        <div id="lightbox-count" class="lightbox-count"></div>
        <div id="lightbox-caption" class="lightbox-caption" style="display:none;"></div>
        <div id="lightbox-missing" class="krav-viewer-missing" style="display:none;"></div>
      </div>
    </div>
  </div>

  <!-- Lockable, draggable detail panel for Krav_Korrekt_Dimensionering -->
  <div id="krav-dim-panel" aria-hidden="true">
    <div class="dim-header" id="krav-dim-header">
      <div class="dim-title" id="krav-dim-title">Uddybning (korrekt dimensionering)</div>
      <div class="dim-actions">
        <button id="krav-dim-pin" class="dim-btn" type="button">LÃ¥s</button>
        <button id="krav-dim-close" class="dim-btn" type="button">Luk</button>
      </div>
    </div>
    <div class="dim-body" id="krav-dim-body"></div>
  </div>

  <script>
    const API_BASE = "http://127.0.0.1:8000";
    let jsonManualEdit = false;
    let syncingFromJson = false;
    let currentStep = 1;
    let latestEvaluation = null;

    // Helper function to format checklist items in a natural way
    function formatChecklistItem(field, name, value, condition) {
      const numValue = parseFloat(value);
      const isNumber = !isNaN(numValue);
      
      // Handle bygningstype
      if (field === 'bygningstype') {
        const typeMap = {
          'RÃ¦kkehus': 'et rÃ¦kkehus',
          'Fritliggende enfamiliehus': 'et fritliggende enfamiliehus',
          'Etagebolig': 'en etagebolig',
          'Butik': 'en butik',
          'Kontor': 'et kontor',
          'Museum': 'et museum',
          'Restaurant': 'en restaurant',
          'Biograf': 'en biograf',
          'Hotel': 'et hotel',
          'Hospital': 'et hospital',
          'Plejehjem': 'et plejehjem',
          'FÃ¦ngsel': 'et fÃ¦ngsel',
          'Kaserne': 'en kaserne',
          'IdrÃ¦tshal': 'en idrÃ¦tshal',
          'Forsamlingslokale': 'et forsamlingslokale'
        };
        const article = typeMap[value] || value.toLowerCase();
        return `Det er ${article}`;
      }

      // Handle fravigelser (deviations)
      if (field.includes('fravigelse') || name.toLowerCase().includes('fravigelse')) {
        const num = parseInt(value);
        if (num === 0) {
          return `Der er ingen fravigelser fra de prÃ¦-accepterede lÃ¸sninger`;
        } else if (num === 1) {
          return `Der er 1 fravigelse fra de prÃ¦-accepterede lÃ¸sninger`;
        }
        return `Der er ${value} fravigelser fra de prÃ¦-accepterede lÃ¸sninger`;
      }

      // Handle gulvhÃ¸jde (floor height)
      if (field.includes('gulvhoejde') || field.includes('gulvhÃ¸jde') || name.toLowerCase().includes('gulvhÃ¸jde')) {
        return `GulvhÃ¸jden pÃ¥ Ã¸verste etage er ${value} m`;
      }

      // Handle totalhÃ¸jde (total height)
      if (field.includes('totalhoejde') || field.includes('totalhÃ¸jde') || name.toLowerCase().includes('totalhÃ¸jde')) {
        return `Bygningens totalhÃ¸jde er ${value} m`;
      }

      // Handle etager (floors)
      if (field.includes('etager_over_terraen') || name.toLowerCase().includes('etager over terrÃ¦n')) {
        const num = parseInt(value);
        if (num === 1) {
          return `Der er 1 etage over terrÃ¦n i bygningsafsnittet`;
        }
        return `Der er ${value} etager over terrÃ¦n i bygningsafsnittet`;
      }

      if (field.includes('etager_under_terraen') || name.toLowerCase().includes('etager under terrÃ¦n')) {
        const num = parseInt(value);
        if (num === 1) {
          return `Der er 1 etage under terrÃ¦n i bygningsafsnittet`;
        }
        return `Der er ${value} etager under terrÃ¦n i bygningsafsnittet`;
      }

      if (field.includes('antal_etager') && !field.includes('over') && !field.includes('under')) {
        const num = parseInt(value);
        if (num === 1) {
          return `Der er i alt 1 etage i bygningsafsnittet`;
        }
        return `Der er i alt ${value} etager i bygningsafsnittet`;
      }

      // Handle areal (area)
      if (field.includes('areal') || field.includes('area')) {
        if (field === 'area_BA') {
          return `Arealet af bygningsafsnittet er ${value} mÂ²`;
        }
        if (field === 'area_total') {
          return `Det totale areal af bygningen er ${value} mÂ²`;
        }
        if (field.includes('bygningsafsnit')) {
          return `Bygningsafsnittet har et areal pÃ¥ ${value} mÂ²`;
        }
        return `Arealet er ${value} mÂ²`;
      }

      // Handle boolean values
      if (condition === 'true' || condition === 'ja' || condition === true) {
        if (field === 'overnatning') return 'Der foregÃ¥r overnatning';
        if (field === 'kendskab_flugtveje') return 'Brugerne er bekendt med flugtvejene';
        if (field === 'selvhjulpen') return 'Personerne er selvhjulpne';
        if (field === 'simpelt_bygningsafsnit') return 'Bygningen er simpelt';
        if (field === 'tilbygning' || field === 'med_tilbygning') return 'Der er en tilbygning';
        if (field === 'erhvervssammenbygning' || field === 'med_erhvervssammenbygning') return 'Der er erhvervssammenbygning';
      } else if (condition === 'false' || condition === 'nej' || condition === false) {
        if (field === 'overnatning') return 'Der foregÃ¥r ikke overnatning';
        if (field === 'kendskab_flugtveje') return 'Brugerne er ikke bekendt med flugtvejene';
        if (field === 'selvhjulpen') return 'Personerne er ikke selvhjulpne';
        if (field === 'simpelt_bygningsafsnit') return 'Bygningen er ikke simpelt';
        if (field === 'tilbygning' || field === 'med_tilbygning') return 'Der er ikke en tilbygning';
        if (field === 'erhvervssammenbygning' || field === 'med_erhvervssammenbygning') return 'Der er ikke erhvervssammenbygning';
      }

      // Don't show comparison operators - they're already validated by the system
      // Just show the clean value in natural language

      // Fallback to original format
      return `${name}: ${value}`;
    }

    // Pre-step explainer state (shown when user clicks "FortsÃ¦t til brandklasse")
    const PRESTEP_EXPLANATIONS = {
      anvendelseskategori: {
        default: 'Her kan du forklare hvorfor dit input lander i denne anvendelseskategori (anmeldelseskriterier) og hvad det betyder for resten af processen.'
      },
      risikoklasse: {
        default: 'Her kan du forklare hvad risikoklassen betyder, og hvorfor denne risikoklasse passer til de indtastede forhold.'
      },
      brandklasse: {
        default: 'Her kan du forklare hvad brandklassen betyder, og hvilke typiske konsekvenser den har for dokumentation og rÃ¥dgivning.'
      },
      bilag: {
        default: 'Her kan du forklare hvad dette bilag indeholder, og hvorfor det er relevant for projektet.'
      }
    };
    const prestepState = { open: false, index: 0, pages: [] };

    // Bilag-input overlay state (shown when user clicks "FortsÃ¦t til krav")
    const bilagState = {
      open: false,
      bilagId: null,
      template: null,
      fields: [],
    };

    const BILAG_FIELD_DEFAULT_INFO = {
      'med_altan': 'Angiv om bygningen har altan/altaner',
      'sammenbygget': 'BestÃ¥r bygningen af flere sammenbyggede enheder (eksempelvis rÃ¦kkehuse), hvor der deles ydervÃ¦gge)',
      'med_straatag': 'Angiv om der er strÃ¥tag pÃ¥ bygningen',
      'med_integreret-bygning': 'Er bygningen integreret med en anden bygning (fx garage, carport eller lignende)',
      'B11_gronnetage': 'Er der tagflader med vegetation (grÃ¸nne tage)',
      'B11_flere_primaere_boligenheder': 'Angiv om der er flere boligenheder pÃ¥ grunden som anses for at vÃ¦re primÃ¦re bygninger',
    };

    function normalizeBilagId(raw){
      if (raw === null || raw === undefined) return '';
      const s = String(raw).trim().replace(',', '.');
      return s;
    }

    function getBilagValueFromEvaluation(evalRes){
      if (!evalRes) return '';
      const rb = evalRes.relevant_bilag;
      // New/desired shape: { value, matched_rule_id, description }
      if (rb && typeof rb === 'object' && ('value' in rb)) {
        const v = rb.value;
        return (v === null || v === undefined) ? '' : String(v).trim();
      }
      // Legacy/transition shapes
      if (rb !== null && rb !== undefined) return String(rb).trim();
      if (evalRes.bilag !== null && evalRes.bilag !== undefined) return String(evalRes.bilag).trim();
      return '';
    }

    function getBilagTitleFromEvaluation(evalObj){
      if (!evalObj) return '';
      // Preferred: explicit title field
      const bt = evalObj.bilag_titel;
      if (bt && typeof bt === 'object' && ('value' in bt)) {
        const v = bt.value;
        return (v === null || v === undefined) ? '' : String(v).trim();
      }
      if (bt !== null && bt !== undefined) return String(bt).trim();

      // Fallback: some payloads include a human description on relevant_bilag
      const rb = evalObj.relevant_bilag;
      if (rb && typeof rb === 'object') {
        const d = rb.description ?? rb.title ?? rb.label;
        if (d !== null && d !== undefined) return String(d).trim();
      }
      return '';
    }

    function getCurrentBilagId(){
      const evalRes = getActiveEvaluation();
      const raw = getBilagValueFromEvaluation(evalRes);
      return normalizeBilagId(raw);
    }

    function getBilagPassThrough(){
      const bilagId = getCurrentBilagId();
      return {
        Relevant_bilag: bilagId || null,
        antal_etager_over_terraen_BA: asNum('fld_antal_etager_over_terraen_BA'),
        area_BA: asNum('fld_area_BA'),
        bygningstype: (()=>{
          const raw = asStr('fld_bygningstype');
          return raw ? String(raw).trim() : '';
        })(),
      };
    }

    function getBilagTemplateUrl(bilagId){
      if (bilagId === '1') return `${API_BASE}/inputB1.json`;
      if (bilagId === '1.1') return `${API_BASE}/inputB11.json`;
      return '';
    }

    function buildBilagFieldsFromTemplate(bilagId, templateObj){
      const keys = (templateObj && typeof templateObj === 'object') ? Object.keys(templateObj) : [];
      const hasKey = (k)=> keys.includes(k);
      const fields = [];

      // Pass-through fields (read-only display)
      const pass = getBilagPassThrough();
      fields.push({ key: 'Relevant_bilag', label: 'Relevant bilag', type: 'readonly', value: pass.Relevant_bilag });
      fields.push({ key: 'bygningstype', label: 'Bygningstype', type: 'readonly', value: pass.bygningstype });
      fields.push({ key: 'area_BA', label: 'Areal af bygningsafsnit [mÂ²]', type: 'readonly', value: pass.area_BA });
      fields.push({ key: 'antal_etager_over_terraen_BA', label: 'Antal etager over terrÃ¦n', type: 'readonly', value: pass.antal_etager_over_terraen_BA });

      // Bilag-specific inputs
      if (bilagId === '1'){
        if (hasKey('B1_med_altan')) fields.push({ key: 'B1_med_altan', label: 'Er der altan?', type: 'bool', mapTo: 'med_altan' });
        if (hasKey('B1_sammenbygget')) fields.push({ key: 'B1_sammenbygget', label: 'Er byggeriet sammenbygget?', type: 'bool', mapTo: 'sammenbygget' });
        if (hasKey('straatag')) fields.push({ key: 'straatag', label: 'Er der strÃ¥tag?', type: 'bool', mapTo: 'med_straatag' });
        if (hasKey('B1_med_integreret-bygning')) fields.push({ key: 'B1_med_integreret-bygning', label: 'Er der integreret bygning?', type: 'bool', mapTo: 'med_integreret-bygning' });
      }
      if (bilagId === '1.1'){
        if (hasKey('straatag')) fields.push({ key: 'straatag', label: 'Er der strÃ¥tag?', type: 'bool', mapTo: 'med_straatag' });
        if (hasKey('B11_gronnetage')) fields.push({ key: 'B11_gronnetage', label: 'Er der grÃ¸nne tage?', type: 'bool' });
        if (hasKey('B11_flere_primaere_boligenheder')) fields.push({ key: 'B11_flere_primaere_boligenheder', label: 'Er der flere primÃ¦re boligenheder?', type: 'bool' });
      }

      // Fallback: if template is missing or unknown bilag, still show a minimal message
      if (!fields.some(f => f.type !== 'readonly')){
        fields.push({ key: '__info__', label: 'Ingen ekstra spÃ¸rgsmÃ¥l fundet', type: 'info', value: bilagId ? `Der er pt. ingen bilag-specifikke felter for bilag ${bilagId}.` : 'Relevant bilag er ikke bestemt endnu.' });
      }
      return fields;
    }

    function readBilagFieldValue(field, el){
      if (!field || !el) return null;
      if (field.type === 'bool'){
        const v = String(el.value || '').trim();
        if (v === 'true') return true;
        if (v === 'false') return false;
        return null;
      }
      if (field.type === 'number'){
        const raw = String(el.value ?? '').trim();
        if (raw === '') return null;
        const n = Number(raw);
        return Number.isFinite(n) ? n : null;
      }
      if (field.type === 'text'){
        const raw = String(el.value ?? '').trim();
        return raw === '' ? null : raw;
      }
      return null;
    }

    function setBilagOverlayOpen(open){
      const overlay = document.getElementById('bilag-overlay');
      if (!overlay) return;
      bilagState.open = !!open;
      overlay.style.display = open ? 'block' : 'none';
      overlay.setAttribute('aria-hidden', open ? 'false' : 'true');
    }

    function renderBilagOverlay(){
      const body = document.getElementById('bilag-body');
      const title = document.getElementById('bilag-title');
      if (!body) return;
      body.innerHTML = '';

      const bilagId = bilagState.bilagId || '';
      if (title) title.textContent = bilagId ? `Udfyld bilag-specifikke oplysninger (Bilag ${bilagId})` : 'Udfyld bilag-specifikke oplysninger';

      const note = document.createElement('div');
      note.className = 'bilag-note';
      note.innerHTML = `<strong>Tip:</strong> Hvis du Ã¦ndrer grunddata, sÃ¥ gÃ¥ evt. tilbage og beregn igen. Denne side gemmer kun bilag-svar pr. bygningsafsnit.`;
      body.appendChild(note);

      const fields = bilagState.fields || [];
      const passThroughWrap = document.createElement('div');
      passThroughWrap.style.marginTop = '12px';
      passThroughWrap.innerHTML = `<div style="font-weight:900; color:#0f172a; margin-bottom:8px;">Videresendte felter (fra side 1)</div>`;
      const passGrid = document.createElement('div');
      passGrid.className = 'bilag-grid';
      passThroughWrap.appendChild(passGrid);
      body.appendChild(passThroughWrap);

      const qWrap = document.createElement('div');
      qWrap.style.marginTop = '14px';
      qWrap.innerHTML = `<div style="font-weight:900; color:#0f172a; margin-bottom:8px;">Bilag-spÃ¸rgsmÃ¥l</div>`;
      const qGrid = document.createElement('div');
      qGrid.className = 'bilag-grid';
      qWrap.appendChild(qGrid);
      body.appendChild(qWrap);

      const extras = getActiveBilagExtras();

      fields.forEach((f)=>{
        if (f.type === 'readonly'){
          const wrap = document.createElement('div');
          wrap.className = 'bilag-field';
          const lab = document.createElement('label');
          lab.textContent = f.label;
          const input = document.createElement('input');
          input.type = 'text';
          input.readOnly = true;
          const v = (f.value === null || f.value === undefined || String(f.value).trim() === '') ? '-' : String(f.value);
          input.value = v;
          wrap.appendChild(lab);
          wrap.appendChild(input);
          passGrid.appendChild(wrap);
          return;
        }

        if (f.type === 'info'){
          const info = document.createElement('div');
          info.className = 'bilag-note';
          info.style.gridColumn = '1 / -1';
          info.textContent = String(f.value || '');
          qGrid.appendChild(info);
          return;
        }

        const wrap = document.createElement('div');
        wrap.className = 'bilag-field';
        const lab = document.createElement('label');
        const labelText = document.createElement('span');
        labelText.textContent = f.label;
        lab.appendChild(labelText);

        const info = document.createElement('span');
        info.className = 'info-icon';
        info.textContent = 'i';
        const infoKey = (f.mapTo || f.key);
        const defaultInfo = BILAG_FIELD_DEFAULT_INFO[infoKey] || BILAG_FIELD_DEFAULT_INFO[f.key] || '';
        if (defaultInfo && defaultInfo.trim()) info.setAttribute('data-tip', defaultInfo);
        lab.appendChild(info);
        wrap.appendChild(lab);
        // Always reserve space for helper text so the grid aligns vertically
        const help = document.createElement('div');
        help.className = 'help';
        if (f.help){
          help.textContent = f.help;
        } else {
          help.textContent = ' '; // reserve height
          help.style.visibility = 'hidden';
        }
        wrap.appendChild(help);

        let input;
        if (f.type === 'bool'){
          input = document.createElement('select');
          const opt0 = document.createElement('option'); opt0.value = ''; opt0.textContent = 'VÃ¦lgâ€¦';
          const opt1 = document.createElement('option'); opt1.value = 'true'; opt1.textContent = 'Ja';
          const opt2 = document.createElement('option'); opt2.value = 'false'; opt2.textContent = 'Nej';
          input.appendChild(opt0); input.appendChild(opt1); input.appendChild(opt2);
          const existing = (extras[f.mapTo || f.key] !== undefined) ? extras[f.mapTo || f.key] : extras[f.key];
          if (existing === true) input.value = 'true';
          else if (existing === false) input.value = 'false';
          else input.value = '';
        } else if (f.type === 'number'){
          input = document.createElement('input');
          input.type = 'number';
          input.step = 'any';
          const existing = (extras[f.mapTo || f.key] !== undefined) ? extras[f.mapTo || f.key] : extras[f.key];
          if (existing !== undefined && existing !== null && String(existing).trim() !== '') input.value = String(existing);
        } else {
          input = document.createElement('input');
          input.type = 'text';
          const existing = (extras[f.mapTo || f.key] !== undefined) ? extras[f.mapTo || f.key] : extras[f.key];
          if (existing !== undefined && existing !== null && String(existing).trim() !== '') input.value = String(existing);
        }

        input.setAttribute('data-bilag-field', f.key);
        wrap.appendChild(input);
        qGrid.appendChild(wrap);
      });
      
      // Re-initialize custom selects after bilag overlay is rendered
      setTimeout(() => {
        if (typeof initCustomSelects === 'function') initCustomSelects();
      }, 50);
    }

    async function openBilagOverlay(){
      const bilagId = getCurrentBilagId();
      bilagState.bilagId = bilagId;
      bilagState.template = null;

      const url = getBilagTemplateUrl(bilagId);
      if (url){
        try {
          const resp = await fetch(url, { cache: 'no-store' });
          if (resp.ok) bilagState.template = await resp.json();
        } catch(_) {
          bilagState.template = null;
        }
      }

      // If template can't be loaded, use a minimal synthetic template to still show questions
      if (!bilagState.template){
        if (bilagId === '1') bilagState.template = { Relevant_bilag:null, antal_etager_over_terraen_BA:null, area_BA:null, B1_med_altan:null, bygningstype:null, B1_sammenbygget:null, straatag:null, 'B1_med_integreret-bygning': null };
        else if (bilagId === '1.1') bilagState.template = { Relevant_bilag:null, antal_etager_over_terraen_BA:null, area_BA:null, bygningstype:null, straatag:null, B11_gronnetage:null, B11_flere_primaere_boligenheder:null };
        else bilagState.template = { Relevant_bilag:null, antal_etager_over_terraen_BA:null, area_BA:null, bygningstype:null };
      }

      bilagState.fields = buildBilagFieldsFromTemplate(bilagId, bilagState.template);
      setBilagOverlayOpen(true);
      renderBilagOverlay();
      
      // Re-initialize custom selects after overlay is opened and rendered
      setTimeout(() => {
        if (typeof initCustomSelects === 'function') initCustomSelects();
      }, 100);
    }

    function closeBilagOverlay(){
      setBilagOverlayOpen(false);
    }

    function resetBilagAnswers(){
      const bilagId = bilagState.bilagId || getCurrentBilagId();
      const clearKeys = [];
      if (bilagId === '1'){
        clearKeys.push('B1_med_altan', 'B1_sammenbygget', 'straatag', 'B1_med_integreret-bygning');
        clearKeys.push('med_altan', 'sammenbygget', 'med_straatag', 'med_integreret-bygning');
      } else if (bilagId === '1.1'){
        clearKeys.push('straatag', 'B11_gronnetage', 'B11_flere_primaere_boligenheder');
        clearKeys.push('med_straatag');
      }
      clearKeys.forEach(k => setActiveBilagExtra(k, undefined));
      try { renderBilagOverlay(); } catch(_) {}
    }

    function saveBilagAnswers(){
      const body = document.getElementById('bilag-body');
      if (!body) return;
      const inputs = Array.from(body.querySelectorAll('[data-bilag-field]'));
      const fieldsByKey = new Map((bilagState.fields || []).map(f => [f.key, f]));
      inputs.forEach(el => {
        const key = el.getAttribute('data-bilag-field');
        const field = fieldsByKey.get(key);
        if (!field) return;
        const value = readBilagFieldValue(field, el);

        // Always store the raw template key
        setActiveBilagExtra(key, value);

        // Also store mapped key used by Krav.json (if any)
        if (field.mapTo && field.mapTo !== key){
          setActiveBilagExtra(field.mapTo, value);
        }
      });

      // Ensure pass-through fields are present as well (harmless if unused)
      const pass = getBilagPassThrough();
      setActiveBilagExtra('Relevant_bilag', pass.Relevant_bilag);
      setActiveBilagExtra('antal_etager_over_terraen_BA', pass.antal_etager_over_terraen_BA);
      setActiveBilagExtra('area_BA', pass.area_BA);
      setActiveBilagExtra('bygningstype', pass.bygningstype);
    }

    function setResultRowValue(prefix, valueText, descText){
      const valEl = document.getElementById(`result-${prefix}`);
      const descEl = document.getElementById(`result-${prefix}-desc`);
      if (valEl) valEl.textContent = (valueText === null || valueText === undefined || String(valueText).trim() === '') ? '-' : String(valueText);
      if (descEl) descEl.textContent = (descText === null || descText === undefined) ? '' : String(descText);
    }

    function setResultRowStatus(prefix, isComplete){
      const statusEl = document.getElementById(`result-${prefix}-status`);
      if (!statusEl) return;
      // Status icons removed - validation badges show this information instead
      statusEl.classList.remove('ok','missing','pending');
      statusEl.textContent = '';
      statusEl.title = '';
      statusEl.setAttribute('aria-label', '');
      statusEl.style.display = 'none'; // Hide the circle completely
    }

    function prestepExplain(kind, value){
      const cfg = PRESTEP_EXPLANATIONS?.[kind];
      if (!cfg) return '';
      const key = (value === null || value === undefined) ? '' : String(value);
      return (cfg[key] ?? cfg.default ?? '');
    }

    function getActiveEvaluation(){
      try {
        const idx = getActiveSectionIndex();
        return sectionsState?.evaluations?.[idx] ?? latestEvaluation ?? {};
      } catch(_) {
        return latestEvaluation ?? {};
      }

      return '';
    }

    function describeBygningstypeArticle(bygningstype) {
      const raw = (bygningstype === null || bygningstype === undefined) ? '' : String(bygningstype).trim();
      if (!raw) return 'et byggeri';

      // Reuse the same wording style as formatChecklistItem's bygningstype mapping.
      const typeMap = {
        'RÃ¦kkehus': 'et rÃ¦kkehus',
        'Fritliggende enfamiliehus': 'et fritliggende enfamiliehus',
        'Etagebolig': 'en etagebolig',
        'Butik': 'en butik',
        'Kontor': 'et kontor',
        'Museum': 'et museum',
        'Restaurant': 'en restaurant',
        'Biograf': 'en biograf',
        'Hotel': 'et hotel',
        'Hospital': 'et hospital',
        'Plejehjem': 'et plejehjem',
        'FÃ¦ngsel': 'et fÃ¦ngsel',
        'Kaserne': 'en kaserne',
        'IdrÃ¦tshal': 'en idrÃ¦tshal',
        'Forsamlingslokale': 'et forsamlingslokale'
      };

      if (raw in typeMap) return typeMap[raw];

      // Fallback that reads well in sentences like: "Byggeriet er <...> i anvendelseskategori ..."
      return 'af typen "' + raw + '"';
    }

    function getBrandklasseDisplay(evalRes){
      const bkValue = evalRes?.brandklasse?.value;
      if (bkValue !== null && bkValue !== undefined && String(bkValue).trim() !== '') return String(bkValue);
      return '';
    }

    function buildPrestepPages(evalRes){
      const bilagVal = getBilagValueFromEvaluation(evalRes);
      const brandVal = getBrandklasseDisplay(evalRes);

      return [
        {
          kind: 'anvendelseskategori',
          title: '',
          short: 'Anvendelseskategori',
          value: (evalRes?.anvendelseskategori?.value ?? ''),
          description: (evalRes?.anvendelseskategori?.description ?? '')
        },
        {
          kind: 'risikoklasse',
          title: 'Risikoklasse',
          short: 'Risikoklasse',
          value: (evalRes?.risikoklasse?.value ?? ''),
          description: (evalRes?.risikoklasse?.description ?? '')
        },
        {
          kind: 'bilag',
          title: 'Relevant bilag',
          short: 'Bilag',
          value: bilagVal,
          description: ''
        },
        {
          kind: 'brandklasse',
          title: 'Brandklasse',
          short: 'Brandklasse',
          value: brandVal,
          description: (evalRes?.brandklasse?.description ?? '')
        }
      ];
    }

    function openPrestepOverlay(){
      const overlay = document.getElementById('prestep-overlay');
      if (!overlay) return;
      prestepState.pages = buildPrestepPages(getActiveEvaluation());
      prestepState.index = 0;
      prestepState.open = true;
      overlay.style.display = 'block';
      overlay.setAttribute('aria-hidden', 'false');
      try { renderPrestepOverlay(); } catch(_) {}
    }

    function closePrestepOverlay(){
      const overlay = document.getElementById('prestep-overlay');
      if (!overlay) return;
      prestepState.open = false;
      overlay.style.display = 'none';
      overlay.setAttribute('aria-hidden', 'true');
    }

    function renderPrestepOverlay(){
      const overlay = document.getElementById('prestep-overlay');
      if (!overlay || !prestepState.open) return;

      const stepsEl = document.getElementById('prestep-steps');
      const contentEl = document.getElementById('prestep-content');
      const btnBack = document.getElementById('prestep-back');
      const btnNext = document.getElementById('prestep-next');

      const pages = prestepState.pages || [];
      const idx = Math.max(0, Math.min(prestepState.index, pages.length - 1));
      prestepState.index = idx;
      const page = pages[idx] || { title:'', short:'', value:'', description:'', kind:'' };

      const hasValue = (v) => v !== null && v !== undefined && String(v).trim() !== '' && String(v).trim() !== '-';
      const ok = hasValue(page.value);
      const badgeClass = ok ? 'ok' : 'missing';
      const badgeText = ok ? 'âœ“ Klar' : '! Mangler data';

      if (stepsEl){
        stepsEl.innerHTML = pages.map((p, i) => {
          const done = i < idx;
          const active = i === idx;
          const cls = `prestep-step${done ? ' done' : ''}${active ? ' active' : ''}`;
          return `<span class="${cls}">${i+1}. ${p.short || p.title || 'Trin'}</span>`;
        }).join('');
      }

      if (contentEl){
        const explain = prestepExplain(page.kind, page.value);
        const desc = (page.description ?? '').toString().trim();
        const showExplain = (explain ?? '').toString().trim().length > 0;
        
        // Get current section info
        const sectionIdx = getActiveSectionIndex();
        const sectionTitle = sectionsState.titles?.[sectionIdx] || `Bygningsafsnit ${sectionIdx + 1}`;
        
        // Build enhanced explanation based on page type
        let enhancedContent = '';
        if (page.kind === 'anvendelseskategori' && ok) {
          enhancedContent = buildAnvendelseskategoriExplanation(page.value, sectionTitle, sectionIdx);
        } else if (page.kind === 'risikoklasse' && ok) {
          enhancedContent = buildRisikoklasseExplanation(page.value, sectionTitle, sectionIdx);
        } else if (page.kind === 'brandklasse' && ok) {
          enhancedContent = buildBrandklasseExplanation(page.value, sectionTitle, sectionIdx);
        } else if (page.kind === 'bilag' && ok) {
          enhancedContent = buildBilagExplanation(page.value, sectionTitle, sectionIdx);
        }
        
        contentEl.innerHTML = `
          <div class="prestep-card">
            ${enhancedContent ? enhancedContent : `
              <div class="prestep-value">${ok ? String(page.value) : '-'}</div>
              <div class="muted">Dette er beregnet ud fra dine indtastninger pÃ¥ side 1.</div>
              ${(desc || showExplain) ? `<div class="prestep-text">${desc ? `<div style="margin-bottom:8px;"><strong>Systemets begrundelse:</strong><br>${escapeHtml(desc)}</div>` : ''}${showExplain ? `<div><strong>Din forklaring:</strong><br>${escapeHtml(explain)}</div>` : ''}</div>` : ''}
            `}
          </div>
        `;
      }

      if (btnBack) btnBack.disabled = idx <= 0;
      if (btnNext){
        const last = idx >= pages.length - 1;
        btnNext.textContent = last ? 'Videre til brandklasse â†’' : 'NÃ¦ste â†’';
      }
    }
    
    function buildAnvendelseskategoriExplanation(akValue, sectionTitle, sectionIdx) {
      // Get inputs and evaluation for this section
      const inputs = sectionsState.inputData?.[sectionIdx] || {};
      const evaluation = sectionsState.evaluations?.[sectionIdx] || {};
      const matchedRuleId = evaluation?.anvendelseskategori?.matched_rule_id;
      
      console.log('[AK Explanation] Section:', sectionIdx);
      console.log('[AK Explanation] Matched Rule ID:', matchedRuleId);
      console.log('[AK Explanation] Model available:', !!window.BRANDKLASSE_MODEL);
      console.log('[AK Explanation] Inputs:', inputs);
      
      // Try to get the actual active conditions from the matched rule
      let activeConditions = [];
      if (matchedRuleId && window.BRANDKLASSE_MODEL) {
        try {
          const akNode = window.BRANDKLASSE_MODEL.nodes.find(n => n.name === 'Anvendelseskategori 2.0');
          console.log('[AK Explanation] Found AK node:', !!akNode);
          
          if (akNode) {
            const rule = akNode.content.rules.find(r => r._id === matchedRuleId);
            console.log('[AK Explanation] Found matched rule:', !!rule);
            
            // If not found directly, try removing node prefix
            let foundRule = rule;
            if (!foundRule && matchedRuleId.includes('_rule_')) {
              const ruleIndex = parseInt(matchedRuleId.split('_rule_')[1]);
              foundRule = akNode.content.rules[ruleIndex];
              console.log('[AK Explanation] Trying by index:', ruleIndex, 'found:', !!foundRule);
            }
            console.log('[AK Explanation] Rule details:', foundRule);
            
            if (foundRule) {
              const inputDefs = akNode.content.inputs;
              console.log('[AK Explanation] Input definitions:', inputDefs);
              
              // Check each input to see if it was used in the rule
              inputDefs.forEach(inp => {
                const conditionValue = foundRule[inp.id];
                console.log(`[AK Explanation] Field ${inp.field} (${inp.id}): condition="${conditionValue}"`);
                
                // If condition is not empty/wildcard, it was used
                if (conditionValue !== '' && conditionValue !== undefined && conditionValue !== null) {
                  const fieldName = inp.field;
                  const inputValue = inputs[fieldName];
                  const displayName = inp.name;
                  
                  // Format the condition
                  let conditionText = '';
                  if (conditionValue === 'true' || conditionValue === true) {
                    conditionText = 'ja';
                  } else if (conditionValue === 'false' || conditionValue === false) {
                    conditionText = 'nej';
                  } else if (conditionValue.startsWith && (conditionValue.startsWith('<=') || conditionValue.startsWith('<') || conditionValue.startsWith('>'))) {
                    conditionText = conditionValue;
                  } else {
                    conditionText = conditionValue;
                  }
                  
                  activeConditions.push({
                    name: displayName,
                    field: fieldName,
                    condition: conditionText,
                    value: inputValue
                  });
                  
                  console.log(`[AK Explanation] Added active condition:`, { field: fieldName, condition: conditionText, value: inputValue });
                }
              });
              
              console.log('[AK Explanation] Total active conditions found:', activeConditions.length);
            }
          }
        } catch (e) {
          console.error('[AK Explanation] Error analyzing matched rule:', e);
        }
      } else {
        console.log('[AK Explanation] Skipping rule analysis - matchedRuleId:', matchedRuleId, 'model:', !!window.BRANDKLASSE_MODEL);
      }
      
      // Build bullet list from active conditions
      let conditionsList = [];
      if (activeConditions.length > 0) {
        conditionsList = activeConditions.map(ac => {
          return formatChecklistItem(ac.field, ac.name, ac.value, ac.condition);
        });
      } else {
        // Fallback hvis vi ikke kan finde den matchede regel
        conditionsList = [];
        if (inputs.overnatning === 'Ja') {
          conditionsList.push('Der foregÃ¥r overnatning');
        } else if (inputs.overnatning === 'Nej') {
          conditionsList.push('Der ikke foregÃ¥r overnatning');
        }
        
        if (inputs.kendskab_flugtveje === 'Ja') {
          conditionsList.push('Brugerne er bekendt med flugtvejene');
        } else if (inputs.kendskab_flugtveje === 'Nej') {
          conditionsList.push('Brugerne ikke er bekendt med flugtvejene');
        }
        
        if (inputs.selvhjulpen === 'Ja') {
          conditionsList.push('Personerne er selvhjulpne');
        } else if (inputs.selvhjulpen === 'Nej') {
          conditionsList.push('Personerne ikke er selvhjulpne');
        }
        
        if (conditionsList.length === 0) conditionsList.push('De indtastede oplysninger');
      }
      
      // Get description for this category
      const categoryDescriptions = {
        '1': {
          desc: 'Bygningsafsnit uden overnatning, hvor personer er stedkendte, og hvor personbelastningen er lav. Flugtvejene er typisk enkle, og der er begrÃ¦nset behov for sÃ¦rlige evakueringstiltag.',
          examples: 'Kontorer, industribygninger, lagerbygninger, garager, teknikbygninger og mindre klinikker.'
        },
        '2': {
          desc: 'Bygningsafsnit uden overnatning, indrettet til hÃ¸jst 50 personer, hvor personerne ikke nÃ¸dvendigvis er stedkendte.',
          examples: 'Undervisningsrum, dagcentre for selvhjulpne, mindre butikker, klinikker, mindre forsamlingslokaler og fritidstilbud.'
        },
        '3': {
          desc: 'Bygningsafsnit uden overnatning, indrettet til flere end 50 personer. Ofte hÃ¸j personbelastning og mange ikke-stedkendte personer, hvilket giver skÃ¦rpede krav til flugtveje og brandforanstaltninger.',
          examples: 'Butikker, biografer, restauranter, teatre, koncertsale, idrÃ¦tshaller, diskoteker, mÃ¸delokaler og stÃ¸rre forsamlingslokaler.'
        },
        '4': {
          desc: 'Bygningsafsnit med overnatning, hvor personerne er selvhjulpne og stedkendte.',
          examples: 'Enfamiliehuse, etageboliger, rÃ¦kkehuse, kollegier, ungdomsboliger, sommerhuse, shelters og mindre overnatningshytter.'
        },
        '5': {
          desc: 'Bygningsafsnit med overnatning, hvor personerne ikke er stedkendte.',
          examples: 'Hoteller, vandrehjem, kroer med overnatning, pensionater samt kost-, efter- og hÃ¸jskoler samt kollegier, der benyttes som hotellignende funktion med kortvarige ophold.'
        },
        '6': {
          desc: 'Bygningsafsnit hvor personer ikke kan bringe sig selv i sikkerhed, eller kun med vÃ¦sentlig hjÃ¦lp.',
          examples: 'Plejeboliger, behandlings- og sengeafsnit pÃ¥ hospitaler, plejhjem, fÃ¦ngsler, vuggestuer, bÃ¸rnehaver og dagcentre for Ã¦ldre.'
        }
      };
      
      const catInfo = categoryDescriptions[String(akValue)] || { desc: '', examples: '' };
      
      // Format conditions as bullet list
      const bulletList = conditionsList.map(c => `<li style="margin-bottom: 4px;">${c}</li>`).join('');
      
      return `
        <div style="margin: 20px 0 16px 0; padding: 0;">
          <p style="margin: 0 0 12px 0; color: #0f172a; line-height: 1.6;">
            <strong>${sectionTitle}</strong> er indplaceret i <strong>anvendelseskategori ${akValue}</strong> baseret pÃ¥:
          </p>
          <ul style="margin: 0 0 16px 0; padding-left: 24px; color: #475569; line-height: 1.6;">
            ${bulletList}
          </ul>
        </div>
        ${catInfo.desc ? `
        <div style="margin: 0 0 16px 0;">
          <p style="margin: 0 0 4px 0; font-weight: 600; color: #0f172a;">Om anvendelseskategori ${akValue}:</p>
          <p style="margin: 0; color: #475569; line-height: 1.6;">${catInfo.desc}</p>
        </div>
        ` : ''}
        ${catInfo.examples ? `
        <div style="margin: 0;">
          <p style="margin: 0 0 4px 0; font-weight: 600; color: #0f172a;">Typiske bygningstyper:</p>
          <p style="margin: 0; color: #475569; line-height: 1.6;">${catInfo.examples}</p>
        </div>
        ` : ''}
      `;
    }
    
    function buildRisikoklasseExplanation(rkValue, sectionTitle, sectionIdx) {
      // Get inputs and evaluation for this section
      const inputs = sectionsState.inputData?.[sectionIdx] || {};
      const evaluation = sectionsState.evaluations?.[sectionIdx] || {};
      const matchedRuleId = evaluation?.risikoklasse?.matched_rule_id;
      
      // Get anvendelseskategori from evaluation (from previous page)
      const akValue = evaluation?.anvendelseskategori?.value;
      
      console.log('[RK Explanation] Section:', sectionIdx);
      console.log('[RK Explanation] Matched Rule ID:', matchedRuleId);
      console.log('[RK Explanation] AK Value:', akValue);
      console.log('[RK Explanation] Inputs:', inputs);
      
      // Try to get the actual active conditions from the matched rule
      let activeConditions = [];
      if (matchedRuleId && window.BRANDKLASSE_MODEL) {
        try {
          const rkNode = window.BRANDKLASSE_MODEL.nodes.find(n => n.name === 'Risikoklasse');
          console.log('[RK Explanation] Found RK node:', !!rkNode);
          
          if (rkNode) {
            let foundRule = rkNode.content.rules.find(r => r._id === matchedRuleId);
            
            // If not found directly, try by index
            if (!foundRule && matchedRuleId.includes('_rule_')) {
              const ruleIndex = parseInt(matchedRuleId.split('_rule_')[1]);
              foundRule = rkNode.content.rules[ruleIndex];
              console.log('[RK Explanation] Trying by index:', ruleIndex, 'found:', !!foundRule);
            }
            
            console.log('[RK Explanation] Found matched rule:', !!foundRule);
            
            if (foundRule) {
              const inputDefs = rkNode.content.inputs;
              
              // Check each input to see if it was used in the rule
              inputDefs.forEach(inp => {
                const conditionValue = foundRule[inp.id];
                
                // If condition is not empty/wildcard, it was used
                if (conditionValue !== '' && conditionValue !== undefined && conditionValue !== null) {
                  const fieldName = inp.field;
                  let inputValue = inputs[fieldName];
                  
                  // Special handling for anvendelseskategori - use from evaluation
                  if (fieldName === 'anvendelseskategori') {
                    inputValue = akValue;
                  }
                  
                  const displayName = inp.name;
                  
                  activeConditions.push({
                    name: displayName,
                    field: fieldName,
                    condition: conditionValue,
                    value: inputValue
                  });
                  
                  console.log(`[RK Explanation] Active:`, { field: fieldName, condition: conditionValue, value: inputValue });
                }
              });
              
              console.log('[RK Explanation] Total active conditions:', activeConditions.length);
            }
          }
        } catch (e) {
          console.error('[RK Explanation] Error:', e);
        }
      }
      
      // Build bullet list from active conditions
      let conditionsList = [];
      if (activeConditions.length > 0) {
        conditionsList = activeConditions.map(ac => {
          const field = ac.field;
          const value = ac.value;
          const condition = ac.condition;
          
          // Format based on field type
          if (field === 'anvendelseskategori') {
            return `Anvendelseskategori: ${value}`;
          }
          return formatChecklistItem(field, ac.name, value, condition);
        });
      } else {
        // Fallback
        conditionsList = ['De indtastede oplysninger'];
        if (akValue) {
          conditionsList.push(`Anvendelseskategori: ${akValue}`);
        }
      }
      
      // Get description for this risk class
      const riskDescriptions = {
        '1': 'Risikoklasse 1 indikerer, at byggeriet er simpelt at evakuere uden hÃ¸j brandbelastning og med et kort brandforlÃ¸b.',
        '2': 'Risikoklasse 2 krÃ¦ver skÃ¦rpede krav sammenlignet med risikoklasse 1.',
        '3': 'Risikoklasse 3 indikerer, at evakueringen er forholdsvis kompleks med lÃ¦ngere brandforlÃ¸b.',
        '4': 'Risikoklasse 4 er den kategori, hvor der sÃ¦ttes hÃ¸jeste krav til brandsikkerhed grundet komplekst og langt brandforlÃ¸b.'
      };
      
      const riskDesc = riskDescriptions[String(rkValue)] || '';
      
      // Format conditions as bullet list
      const bulletList = conditionsList.map(c => `<li style="margin-bottom: 4px;">${c}</li>`).join('');
      
      return `
        <div style="margin: 20px 0 16px 0; padding: 0;">
          <p style="margin: 0 0 12px 0; color: #0f172a; line-height: 1.6;">
            <strong>${sectionTitle}</strong> er indplaceret i <strong>risikoklasse ${rkValue}</strong> baseret pÃ¥:
          </p>
          <ul style="margin: 0 0 16px 0; padding-left: 24px; color: #475569; line-height: 1.6;">
            ${bulletList}
          </ul>
        </div>
        ${riskDesc ? `
        <div style="margin: 0 0 16px 0;">
          <p style="margin: 0 0 4px 0; font-weight: 600; color: #0f172a;">Om risikoklasse ${rkValue}:</p>
          <p style="margin: 0; color: #475569; line-height: 1.6;">${riskDesc}</p>
        </div>
        ` : ''}
      `;
    }
    
    function buildBrandklasseExplanation(bkValue, sectionTitle, sectionIdx) {
      // Get inputs and evaluation for this section
      const inputs = sectionsState.inputData?.[sectionIdx] || {};
      const evaluation = sectionsState.evaluations?.[sectionIdx] || {};
      const matchedRuleId = evaluation?.brandklasse?.matched_rule_id;
      
      // Get values from evaluation (from previous pages)
      const akValue = evaluation?.anvendelseskategori?.value;
      const rkValue = evaluation?.risikoklasse?.value;
      
      console.log('[BK Explanation] Section:', sectionIdx);
      console.log('[BK Explanation] Matched Rule ID:', matchedRuleId);
      console.log('[BK Explanation] AK Value:', akValue, 'RK Value:', rkValue);
      
      // Try to get the actual active conditions from the matched rule
      let activeConditions = [];
      if (matchedRuleId && window.BRANDKLASSE_MODEL) {
        try {
          // Try multiple possible node names
          let bkNode = window.BRANDKLASSE_MODEL.nodes.find(n => n.name === 'Brandklasse');
          if (!bkNode) {
            bkNode = window.BRANDKLASSE_MODEL.nodes.find(n => n.name === 'PrÃ¦-accepterede lÃ¸sninger');
          }
          if (!bkNode) {
            // Try to find by checking if node has brandklasse in output
            bkNode = window.BRANDKLASSE_MODEL.nodes.find(n => 
              n.content && n.content.hitPolicy && 
              n.content.outputs && n.content.outputs.some(o => o.field === 'brandklasse')
            );
          }
          console.log('[BK Explanation] Found BK node:', !!bkNode);
          if (bkNode) {
            console.log('[BK Explanation] Node name:', bkNode.name);
          }
          
          if (bkNode) {
            let foundRule = bkNode.content.rules.find(r => r._id === matchedRuleId);
            
            // If not found directly, try by index
            if (!foundRule && matchedRuleId.includes('_rule_')) {
              const ruleIndex = parseInt(matchedRuleId.split('_rule_')[1]);
              foundRule = bkNode.content.rules[ruleIndex];
              console.log('[BK Explanation] Trying by index:', ruleIndex, 'found:', !!foundRule);
            }
            
            console.log('[BK Explanation] Found matched rule:', !!foundRule);
            
            if (foundRule) {
              console.log('[BK Explanation] Full matched rule object:', foundRule);
              const inputDefs = bkNode.content.inputs;
              console.log('[BK Explanation] Input definitions count:', inputDefs.length);
              console.log('[BK Explanation] All input definitions:', inputDefs);
              
              // Check each input to see if it was used in the rule
              inputDefs.forEach(inp => {
                const conditionValue = foundRule[inp.id];
                const conditionType = typeof conditionValue;
                const isArray = Array.isArray(conditionValue);
                console.log(`[BK Explanation] Field: ${inp.field}, ID: ${inp.id}, Condition: ${JSON.stringify(conditionValue)}, Type: ${conditionType}, IsArray: ${isArray}`);
                
                // If condition is not empty/wildcard, it was used
                // Handle arrays (like bygningstype lists) as active conditions
                const isActive = conditionValue !== '' && 
                                conditionValue !== undefined && 
                                conditionValue !== null && 
                                !(isArray && conditionValue.length === 0);
                
                console.log(`[BK Explanation] Is active: ${isActive}`);
                
                if (isActive) {
                  const fieldName = inp.field;
                  let inputValue = inputs[fieldName];
                  
                  // Special handling for previous page values (computed results from earlier nodes)
                  if (fieldName === 'anvendelseskategori') {
                    inputValue = akValue;
                  } else if (fieldName === 'risikoklasse') {
                    inputValue = rkValue;
                  } else if (fieldName === 'relevant_bilag') {
                    inputValue = evaluation?.relevant_bilag?.value;
                  }
                  
                  const displayName = inp.name;
                  
                  activeConditions.push({
                    name: displayName,
                    field: fieldName,
                    condition: conditionValue,
                    value: inputValue
                  });
                  
                  console.log(`[BK Explanation] Active:`, { field: fieldName, condition: conditionValue, value: inputValue });
                }
              });
              
              console.log('[BK Explanation] Total active conditions:', activeConditions.length);
            }
          }
        } catch (e) {
          console.error('[BK Explanation] Error:', e);
        }
      }
      
      // Build bullet list from active conditions
      let conditionsList = [];
      if (activeConditions.length > 0) {
        conditionsList = activeConditions.map(ac => {
          const field = ac.field;
          const value = ac.value;
          const condition = ac.condition;
          
          // Format based on field type
          if (field === 'anvendelseskategori') {
            return `Anvendelseskategori: ${value}`;
          } else if (field === 'risikoklasse') {
            return `Risikoklasse: ${value}`;
          } else if (field === 'relevant_bilag') {
            return `Relevant bilag: ${value}`;
          }
          return formatChecklistItem(field, ac.name, value, condition);
        });
      } else {
        // Fallback - show all relevant values
        conditionsList = [];
        if (akValue) conditionsList.push(`Anvendelseskategori: ${akValue}`);
        if (rkValue) conditionsList.push(`Risikoklasse: ${rkValue}`);
        
        // Add key inputs from section
        if (inputs.simpelt_bygningsafsnit === 'Ja') {
          conditionsList.push('Bygningen er simpelt');
        } else if (inputs.simpelt_bygningsafsnit === 'Nej') {
          conditionsList.push('Bygningen ikke er simpelt');
        }
        
        if (inputs.tilbygning === 'Ja') {
          conditionsList.push('Der er en tilbygning');
        }
        
        if (inputs.erhvervssammenbygning === 'Ja') {
          conditionsList.push('Der er erhvervssammenbygning');
        }
        
        if (inputs.total_bygningsareal) {
          conditionsList.push(`Total bygningsareal: ${inputs.total_bygningsareal} mÂ²`);
        }
        
        if (inputs.antal_etager_over_terrÃ¦n) {
          conditionsList.push(`Antal etager over terrÃ¦n: ${inputs.antal_etager_over_terrÃ¦n}`);
        }
        
        if (conditionsList.length === 0) conditionsList.push('De indtastede oplysninger');
      }
      
      // Get description for this brand class
      const brandDescriptions = {
        '1': 'Brandklasse 1 er for enkle byggerier med lave risici, hvor prÃ¦-accepterede lÃ¸sninger kan anvendes.',
        '2': 'Brandklasse 2 krÃ¦ver certificeret rÃ¥dgivning og anvendes ved komplekse projekter eller afvigelser fra prÃ¦-accepterede lÃ¸sninger.',
        '3': 'Brandklasse 3 anvendes primÃ¦rt til Ã¦ldre bygninger.',
        '4': 'Brandklasse 4 anvendes til helt sÃ¦rlige bygningstyper.'
      };
      
      const brandDesc = brandDescriptions[String(bkValue)] || '';
      
      // Format conditions as bullet list
      const bulletList = conditionsList.map(c => `<li style="margin-bottom: 4px;">${c}</li>`).join('');
      
      return `
        <div style="margin: 20px 0 16px 0; padding: 0;">
          <p style="margin: 0 0 12px 0; color: #0f172a; line-height: 1.6;">
            <strong>${sectionTitle}</strong> er indplaceret i <strong>brandklasse ${bkValue}</strong> baseret pÃ¥:
          </p>
          <ul style="margin: 0 0 16px 0; padding-left: 24px; color: #475569; line-height: 1.6;">
            ${bulletList}
          </ul>
        </div>
        ${brandDesc ? `
        <div style="margin: 0 0 16px 0;">
          <p style="margin: 0 0 4px 0; font-weight: 600; color: #0f172a;">Om brandklasse ${bkValue}:</p>
          <p style="margin: 0; color: #475569; line-height: 1.6;">${brandDesc}</p>
        </div>
        ` : ''}
      `;
    }
    
    function buildBilagExplanation(bilagValue, sectionTitle, sectionIdx) {
      const getBilagTitleFromEvaluation = (evalObj) => {
        if (!evalObj) return '';
        const bt = evalObj.bilag_titel;
        if (bt && typeof bt === 'object' && ('value' in bt)) {
          const v = bt.value;
          return (v === null || v === undefined) ? '' : String(v).trim();
        }
        if (bt !== null && bt !== undefined) return String(bt).trim();
        return '';
      };

      function getBilagDownloadInfo(rawBilagValue){
        const raw = (rawBilagValue === null || rawBilagValue === undefined) ? '' : String(rawBilagValue).trim();
        const lower = raw.toLowerCase();

        // Normalize common shapes
        if (lower === 'bilag_1' || lower === 'bilag1' || lower === '1') {
          return {
            label: 'Bilag 1a (PDF)',
            url: `${API_BASE}/assets/bilag1/bilag-1a-fritliggende-og-sammenbyggede-enfamiliehuse-ver-20-20220103-a.pdf`
          };
        }
        if (lower === 'bilag_11' || lower === 'bilag11' || lower === '11' || lower === '1.1') {
          return {
            label: 'Bilag 1b (PDF)',
            url: `${API_BASE}/assets/bilag11/bilag-1b-ver-2020220218-a.pdf`
          };
        }

        // Try a numeric normalization fallback
        const normalized = normalizeBilagId(raw);
        if (normalized === '1') {
          return {
            label: 'Bilag 1a (PDF)',
            url: `${API_BASE}/assets/bilag1/bilag-1a-fritliggende-og-sammenbyggede-enfamiliehuse-ver-20-20220103-a.pdf`
          };
        }
        if (normalized === '1.1') {
          return {
            label: 'Bilag 1b (PDF)',
            url: `${API_BASE}/assets/bilag11/bilag-1b-ver-2020220218-a.pdf`
          };
        }
        return null;
      }

      // Get inputs and evaluation for this section
      const inputs = sectionsState.inputData?.[sectionIdx] || {};
      const evaluation = sectionsState.evaluations?.[sectionIdx] || {};
      // Note: matched_rule_id is in relevant_bilag, not bilag
      const matchedRuleId = evaluation?.relevant_bilag?.matched_rule_id;
      
      // Get values from evaluation (from previous pages)
      const akValue = evaluation?.anvendelseskategori?.value;
      const rkValue = evaluation?.risikoklasse?.value;
      const bkValue = evaluation?.brandklasse?.value;

      const bilagTitle = getBilagTitleFromEvaluation(evaluation);
      const bilagDisplay = (bilagTitle && bilagTitle.trim() !== '') ? bilagTitle : (bilagValue === null || bilagValue === undefined ? '' : String(bilagValue));
      
      console.log('[Bilag Explanation] Section:', sectionIdx);
      console.log('[Bilag Explanation] Matched Rule ID:', matchedRuleId);
      console.log('[Bilag Explanation] AK:', akValue, 'RK:', rkValue, 'BK:', bkValue);
      
      // Try to get the actual active conditions from the matched rule
      let activeConditions = [];
      if (matchedRuleId && window.BRANDKLASSE_MODEL) {
        try {
          // Try multiple possible node names
          let bilagNode = window.BRANDKLASSE_MODEL.nodes.find(n => n.name === 'Bilag');
          if (!bilagNode) {
            bilagNode = window.BRANDKLASSE_MODEL.nodes.find(n => n.name === 'Relevant bilag');
          }
          if (!bilagNode) {
            // Try to find by checking if node has relevant_bilag in output
            bilagNode = window.BRANDKLASSE_MODEL.nodes.find(n => 
              n.content && n.content.hitPolicy && 
              n.content.outputs && n.content.outputs.some(o => o.field === 'relevant_bilag')
            );
          }
          console.log('[Bilag Explanation] Found Bilag node:', !!bilagNode);
          if (bilagNode) {
            console.log('[Bilag Explanation] Node name:', bilagNode.name);
          }
          
          if (bilagNode) {
            let foundRule = bilagNode.content.rules.find(r => r._id === matchedRuleId);
            
            // If not found directly, try by index
            if (!foundRule && matchedRuleId.includes('_rule_')) {
              const ruleIndex = parseInt(matchedRuleId.split('_rule_')[1]);
              foundRule = bilagNode.content.rules[ruleIndex];
              console.log('[Bilag Explanation] Trying by index:', ruleIndex, 'found:', !!foundRule);
            }
            
            console.log('[Bilag Explanation] Found matched rule:', !!foundRule);
            
            if (foundRule) {
              console.log('[Bilag Explanation] Full matched rule object:', foundRule);
              const inputDefs = bilagNode.content.inputs;
              console.log('[Bilag Explanation] Input definitions count:', inputDefs.length);
              console.log('[Bilag Explanation] All input definitions:', inputDefs);
              
              // Check each input to see if it was used in the rule
              inputDefs.forEach(inp => {
                const conditionValue = foundRule[inp.id];
                const conditionType = typeof conditionValue;
                const isArray = Array.isArray(conditionValue);
                console.log(`[Bilag Explanation] Field: ${inp.field}, ID: ${inp.id}, Condition: ${JSON.stringify(conditionValue)}, Type: ${conditionType}, IsArray: ${isArray}`);
                
                // If condition is not empty/wildcard, it was used
                // Handle arrays (like bygningstype lists) as active conditions
                const isActive = conditionValue !== '' && 
                                conditionValue !== undefined && 
                                conditionValue !== null && 
                                !(isArray && conditionValue.length === 0);
                
                console.log(`[Bilag Explanation] Is active: ${isActive}`);
                
                if (isActive) {
                  const fieldName = inp.field;
                  let inputValue = inputs[fieldName];
                  
                  // Special handling for previous page values
                  if (fieldName === 'anvendelseskategori') {
                    inputValue = akValue;
                  } else if (fieldName === 'risikoklasse') {
                    inputValue = rkValue;
                  } else if (fieldName === 'brandklasse') {
                    inputValue = bkValue;
                  }
                  
                  const displayName = inp.name;
                  
                  activeConditions.push({
                    name: displayName,
                    field: fieldName,
                    condition: conditionValue,
                    value: inputValue
                  });
                  
                  console.log(`[Bilag Explanation] Active:`, { field: fieldName, condition: conditionValue, value: inputValue });
                }
              });
              
              console.log('[Bilag Explanation] Total active conditions:', activeConditions.length);
            }
          }
        } catch (e) {
          console.error('[Bilag Explanation] Error:', e);
        }
      }
      
      // Build bullet list from active conditions
      let conditionsList = [];
      if (activeConditions.length > 0) {
        conditionsList = activeConditions.map(ac => {
          const field = ac.field;
          const value = ac.value;
          const condition = ac.condition;
          
          // Format based on field type
          if (field === 'anvendelseskategori') {
            return `Anvendelseskategori: ${value}`;
          } else if (field === 'risikoklasse') {
            return `Risikoklasse: ${value}`;
          } else if (field === 'brandklasse') {
            return `Brandklasse: ${value}`;
          }
          return formatChecklistItem(field, ac.name, value, condition);
        });
      } else {
        // Fallback
        conditionsList = [];
        if (akValue) conditionsList.push(`Anvendelseskategori: ${akValue}`);
        if (rkValue) conditionsList.push(`Risikoklasse: ${rkValue}`);
        if (bkValue) conditionsList.push(`Brandklasse: ${bkValue}`);
        if (conditionsList.length === 0) conditionsList.push('De indtastede oplysninger');
      }
      
      // Parse bilag value to show which one(s)
      const bilagInfo = {
        '1': 'Dette bilag til Bygningsreglementets vejledning om brand indeholder prÃ¦-accepterede lÃ¸sninger for brandsikring af fritliggende og sammenbyggede enfamiliehuse efter BR18. FÃ¸lges lÃ¸sningerne, dokumenteres overholdelse af brandkrav og grundlag for indplacering i brandklasse 1 eller 2. Ved brandklasse 2 skal en certificeret brandrÃ¥dgiver tilknyttes, og mindre fravigelser kan indarbejdes.',
        '1.1': 'Dette bilag til Bygningsreglementets vejledning om brand indeholder prÃ¦-accepterede lÃ¸sninger for brandsikring af sekundÃ¦r bebyggelse til enfamiliehuse. Bilaget kan anvendes til at dokumentere overholdelse af BR18â€™s brandkrav og grundlag for indplacering i brandklasse 1 eller 2. Ved brandklasse 2 skal en certificeret brandrÃ¥dgiver tilknyttes, og der kan indarbejdes fÃ¥ simple fravigelser.',
        'bilag_1': 'Dette bilag indeholder de relevante krav for dit byggeri.',
        'bilag_11': 'Dette bilag indeholder de relevante krav for dit byggeri.',
        'bilag_1+bilag_11': 'Dette bilag indeholder de relevante krav for dit byggeri.'
      };

      const bilagKey = normalizeBilagId(String(bilagValue ?? '').trim()) || String(bilagValue ?? '').trim();
      const bilagDesc = bilagInfo[bilagKey] || 'Dette bilag indeholder de relevante krav for dit byggeri.';
      
      // Format conditions as bullet list
      const bulletList = conditionsList.map(c => `<li style="margin-bottom: 4px;">${c}</li>`).join('');

      const bilagIdForDownload = normalizeBilagId(getBilagValueFromEvaluation(evaluation)) || String(bilagValue ?? '').trim();
      const downloadInfo = getBilagDownloadInfo(bilagIdForDownload);
      const downloadHtml = downloadInfo ? `
        <div class="download-row">
          <div class="download-label">Download det relevante bilag som PDF:</div>
          <a class="btn-secondary download-link" href="${downloadInfo.url}" target="_blank" rel="noopener" style="text-decoration:none;">
            <span class="download-icon" aria-hidden="true">â¬‡</span>
            <span>${escapeHtml(downloadInfo.label)}</span>
          </a>
        </div>
      ` : '';
      
      return `
        <div style="margin: 20px 0 16px 0; padding: 0;">
          <p style="margin: 0 0 12px 0; color: #0f172a; line-height: 1.6;">
            <strong>${sectionTitle}</strong> skal fÃ¸lge <strong>${escapeHtml(bilagDisplay)}</strong> baseret pÃ¥:
          </p>
          <ul style="margin: 0 0 16px 0; padding-left: 24px; color: #475569; line-height: 1.6;">
            ${bulletList}
          </ul>
        </div>
        <div style="margin: 0 0 16px 0;">
          <p style="margin: 0 0 4px 0; font-weight: 600; color: #0f172a;">Om bilaget:</p>
          <p style="margin: 0; color: #475569; line-height: 1.6;">${bilagDesc}</p>
          ${downloadHtml}
        </div>
      `;
    }

    function escapeHtml(str){
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    // Step 2 figures carousel state
    let step2FigureRefs = [];
    let step2FigureIndex = 0;
    let step2CaptionsCache = null;
    let step2FigureTextBlocks = [];
    let step2FigureBindingsReady = false;

    const clamp = (n, min, max) => Math.min(max, Math.max(min, n));

    function ensureStep2FigureBindings(){
      if (step2FigureBindingsReady) return;
      step2FigureBindingsReady = true;

      const btnPrev = document.getElementById('step2-fig-prev');
      const btnNext = document.getElementById('step2-fig-next');
      if (btnPrev) btnPrev.addEventListener('click', () => setStep2FigureIndex(step2FigureIndex - 1));
      if (btnNext) btnNext.addEventListener('click', () => setStep2FigureIndex(step2FigureIndex + 1));
    }

    function setStep2FigureIndex(nextIndex){
      if (!Array.isArray(step2FigureRefs) || step2FigureRefs.length === 0) return;
      step2FigureIndex = clamp(nextIndex, 0, step2FigureRefs.length - 1);
      try { renderStep2Figure(); } catch(_) {}
    }

    async function loadStep2Captions(){
      if (step2CaptionsCache !== null) return step2CaptionsCache;
      const getFigureDirs = ()=>{
        const out = [];
        try {
          const b = normalizeBilagId(getCurrentBilagId());
          const digits = b ? String(b).replace(/\D/g, '') : '';
          if (digits) out.push(`${API_BASE}/assets/bilag${digits}/figures`);
        } catch(_) {}
        out.push(`${API_BASE}/assets/figures`);
        return out;
      };

      for (const baseDir of getFigureDirs()) {
        try {
          const capResp = await fetch(`${baseDir}/captions.json`, { cache: 'no-store' });
          if (capResp.ok) {
            const capJson = await capResp.json();
            if (capJson && typeof capJson === 'object') {
              step2CaptionsCache = capJson;
              return step2CaptionsCache;
            }
          }
        } catch (_) {}
      }
      step2CaptionsCache = {};
      return step2CaptionsCache;
    }

    async function renderStep2Figure(){
      ensureStep2FigureBindings();
      const carousel = document.getElementById('step2-figure-carousel');
      const img = document.getElementById('step2-fig-img');
      const refEl = document.getElementById('step2-fig-ref');
      const countEl = document.getElementById('step2-fig-count');
      const captionEl = document.getElementById('step2-fig-caption');
      const missingEl = document.getElementById('step2-fig-missing');
      const btnPrev = document.getElementById('step2-fig-prev');
      const btnNext = document.getElementById('step2-fig-next');

      if (!carousel || !img || !refEl || !countEl || !captionEl || !missingEl) return;
      if (!Array.isArray(step2FigureRefs) || step2FigureRefs.length === 0) {
        carousel.style.display = 'none';
        return;
      }

      const getFigureDirs = ()=>{
        const out = [];
        try {
          const b = normalizeBilagId(getCurrentBilagId());
          const digits = b ? String(b).replace(/\D/g, '') : '';
          if (digits) out.push(`${API_BASE}/assets/bilag${digits}/figures`);
        } catch(_) {}
        out.push(`${API_BASE}/assets/figures`);
        return out;
      };
      const figureDirs = getFigureDirs();
      const mkSrc = (baseDir, ref, ext) => `${baseDir}/${encodeURIComponent(ref)}${ext}`;

      step2FigureIndex = clamp(step2FigureIndex, 0, step2FigureRefs.length - 1);
      const ref = String(step2FigureRefs[step2FigureIndex] ?? '').trim();
      carousel.style.display = '';
      refEl.textContent = ref || '-';
      countEl.textContent = step2FigureRefs.length > 1 ? `(${step2FigureIndex + 1}/${step2FigureRefs.length})` : '';
      if (btnPrev) btnPrev.disabled = step2FigureIndex <= 0;
      if (btnNext) btnNext.disabled = step2FigureIndex >= step2FigureRefs.length - 1;

      // Captions
      const captions = await loadStep2Captions();
      const lookupKey = ref.replace(/\.(png|jpg|jpeg|svg|webp)$/i, '');
      const humanCaption = (captions && (captions[lookupKey] ?? captions[ref])) ? String(captions[lookupKey] ?? captions[ref]) : '';
      const figureText = (Array.isArray(step2FigureTextBlocks) && step2FigureTextBlocks[step2FigureIndex] !== undefined)
        ? String(step2FigureTextBlocks[step2FigureIndex] ?? '').trim()
        : '';
      const preferredCaption = figureText || (humanCaption ? String(humanCaption).trim() : '');
      if (preferredCaption) {
        captionEl.style.display = '';
        captionEl.textContent = preferredCaption;
      } else {
        captionEl.style.display = 'none';
        captionEl.textContent = '';
      }

      // Image loading (try common extensions if ref has none)
      missingEl.style.display = 'none';
      missingEl.textContent = '';
      img.alt = ref;

      const hasExt = /\.(png|jpg|jpeg|svg|webp)$/i.test(ref);
      const baseRef = hasExt ? ref.replace(/\.(png|jpg|jpeg|svg|webp)$/i, '') : ref;
      const tryExts = hasExt ? [''] : ['.png', '.jpg', '.jpeg', '.svg', '.webp'];
      let dirIndex = 0;
      let tryIndex = 0;

      const setTrySrc = () => {
        const ext = tryExts[tryIndex];
        const baseDir = figureDirs[Math.min(dirIndex, figureDirs.length - 1)];
        img.src = hasExt ? `${baseDir}/${encodeURIComponent(ref)}` : mkSrc(baseDir, baseRef, ext);
      };

      img.onerror = () => {
        tryIndex++;
        if (tryIndex < tryExts.length) {
          setTrySrc();
          return;
        }
        // Next base dir
        dirIndex++;
        if (dirIndex < figureDirs.length) {
          tryIndex = 0;
          setTrySrc();
          return;
        }
        const attempted = hasExt
          ? figureDirs.map(d => `${d}/${encodeURIComponent(ref)}`)
          : figureDirs.flatMap(d => tryExts.map(ext => mkSrc(d, baseRef, ext)));
        missingEl.textContent = `Kunne ikke finde billedfil for "${ref}".\nForsÃ¸gt:\n- ${attempted.join('\n- ')}`;
        missingEl.style.display = '';
      };

      setTrySrc();
    }
    // Multi-building + multi-section state
    function createEmptySectionsState(){
      return {
        count: 1,
        titles: [],
        inputs: {},
        inputData: {},  // Store complete input data for each section (for explanations)
        bilagExtras: {},
        evaluations: {},
        progress: {},
        lastStep: {},
        kravChecks: {},
        kravResults: {},
        // Step 3: canonical order for requirement categories (matches Krav page ordering)
        // Shape: { [sectionIdx]: Array<string> }
        kravCategoryOrder: {},
        // Step 3: documentation uploads per requirement category (JSON-export safe)
        // Shape: { [sectionIdx]: { [categoryLabel]: Array<{ id, name, type, size, lastModified, caption, description }> } }
        kravCategoryDocs: {}
      };
    }

    function sortCategoryLabelsByOrder(labels, order){
      const list = Array.isArray(labels) ? labels.slice() : [];
      const orderArr = Array.isArray(order) ? order : [];
      const idx = new Map();
      for (let i = 0; i < orderArr.length; i++) {
        const k = String(orderArr[i] ?? '').trim();
        if (!k || idx.has(k)) continue;
        idx.set(k, i);
      }

      list.sort((a, b) => {
        const aa = String(a ?? '').trim();
        const bb = String(b ?? '').trim();
        const ia = idx.has(aa) ? idx.get(aa) : Infinity;
        const ib = idx.has(bb) ? idx.get(bb) : Infinity;
        if (ia !== ib) return ia - ib;
        return aa.localeCompare(bb, 'da');
      });
      return list;
    }

    function ensureKravCategoryDocsForSection(sectionIdx){
      if (!sectionsState.kravCategoryDocs || typeof sectionsState.kravCategoryDocs !== 'object') {
        sectionsState.kravCategoryDocs = {};
      }
      const k = String(sectionIdx);
      if (!sectionsState.kravCategoryDocs[k] || typeof sectionsState.kravCategoryDocs[k] !== 'object') {
        sectionsState.kravCategoryDocs[k] = {};
      }
      return sectionsState.kravCategoryDocs[k];
    }

    function getKravCategoryDocs(sectionIdx, categoryLabel){
      const perSection = ensureKravCategoryDocsForSection(sectionIdx);
      const key = String(categoryLabel || '').trim();
      if (!key) return [];
      if (!Array.isArray(perSection[key])) perSection[key] = [];
      return perSection[key];
    }

    function getKravDocFileStore(){
      try {
        if (!window.__kravDocFileStore || typeof window.__kravDocFileStore !== 'object') {
          window.__kravDocFileStore = {};
        }
        return window.__kravDocFileStore;
      } catch(_) {
        return {};
      }
    }

    function getKravDocFileById(docId){
      if (!docId) return null;
      const store = getKravDocFileStore();
      return store[String(docId)] || null;
    }

    function addKravCategoryDocsFromFiles(sectionIdx, categoryLabel, files){
      const key = String(categoryLabel || '').trim();
      if (!key) return;
      const list = getKravCategoryDocs(sectionIdx, key);
      const arr = Array.from(files || []).filter(Boolean);
      if (arr.length === 0) return;

      const mkId = () => {
        try { return (crypto && crypto.randomUUID) ? crypto.randomUUID() : null; } catch(_) { return null; }
      };

      const store = getKravDocFileStore();
      for (const f of arr) {
        const id = mkId() || `doc_${Date.now()}_${Math.random().toString(16).slice(2)}`;
        try { store[String(id)] = f; } catch(_) {}
        list.push({
          id,
          name: String(f.name || 'fil'),
          type: String(f.type || ''),
          size: Number.isFinite(Number(f.size)) ? Number(f.size) : null,
          lastModified: Number.isFinite(Number(f.lastModified)) ? Number(f.lastModified) : null,
          caption: '',
          description: ''
        });
      }
    }

    function updateKravCategoryDocField(sectionIdx, categoryLabel, docId, field, value){
      const key = String(categoryLabel || '').trim();
      if (!key || !docId) return;
      const list = getKravCategoryDocs(sectionIdx, key);
      const entry = list.find(x => String(x?.id) === String(docId));
      if (!entry) return;
      if (field === 'caption') entry.caption = String(value ?? '');
      if (field === 'description') entry.description = String(value ?? '');
    }

    function removeKravCategoryDoc(sectionIdx, categoryLabel, docId){
      const key = String(categoryLabel || '').trim();
      if (!key || !docId) return;
      const list = getKravCategoryDocs(sectionIdx, key);
      const idx = list.findIndex(x => String(x?.id) === String(docId));
      if (idx >= 0) list.splice(idx, 1);
      try {
        const store = getKravDocFileStore();
        delete store[String(docId)];
      } catch(_) {}
    }

    // ---- PDF helpers (for embedding bilag as images) ----
    async function ensurePdfJsLoaded(){
      if (window.pdfjsLib) return window.pdfjsLib;

      const existing = document.querySelector('script[data-pdfjs="true"]');
      if (!existing) {
        await new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.dataset.pdfjs = 'true';
          // CDN is simplest for a single-file frontend. If you prefer vendoring, we can.
          s.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.js';
          s.onload = resolve;
          s.onerror = reject;
          document.head.appendChild(s);
        });
      } else {
        await new Promise((resolve, reject) => {
          if (window.pdfjsLib) return resolve();
          existing.addEventListener('load', resolve, { once: true });
          existing.addEventListener('error', reject, { once: true });
        });
      }

      const lib = window.pdfjsLib;
      if (!lib) throw new Error('Kunne ikke indlÃ¦se PDF.js');
      try {
        lib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.js';
      } catch(_) {}
      return lib;
    }

    async function pdfFileToPngFile(pdfFile, opts){
      const options = opts || {};
      const pageNumber = Number.isFinite(Number(options.pageNumber)) ? Number(options.pageNumber) : 1;
      const scale = Number.isFinite(Number(options.scale)) ? Number(options.scale) : 2;

      const lib = await ensurePdfJsLoaded();
      const data = await pdfFile.arrayBuffer();
      const loadingTask = lib.getDocument({ data });
      const pdf = await loadingTask.promise;
      const page = await pdf.getPage(pageNumber);
      const viewport = page.getViewport({ scale });

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = Math.ceil(viewport.width);
      canvas.height = Math.ceil(viewport.height);
      await page.render({ canvasContext: ctx, viewport }).promise;

      const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png', 0.95));
      if (!blob) throw new Error('PDF -> PNG konvertering fejlede');
      const baseName = String(pdfFile.name || 'bilag.pdf').replace(/\.pdf$/i, '');
      return new File([blob], `${baseName}.png`, { type: 'image/png' });
    }

    const buildingsState = {
      count: 1,
      titles: [],
      buildings: {},
      lastActiveSection: {}
    };

    // This variable always points at the active building's sections state.
    // Many parts of the UI assume a single "sectionsState"; this keeps changes localized.
    let sectionsState = createEmptySectionsState();
    buildingsState.buildings[0] = sectionsState;

    function getActiveSectionIndex(){
      const el = document.body.getAttribute('data-active-section');
      return el ? parseInt(el) : 0;
    }

    function getActiveBuildingIndex(){
      const el = document.body.getAttribute('data-active-building');
      return el ? parseInt(el) : 0;
    }

    function setActiveBuildingIndex(idx){
      const prevB = getActiveBuildingIndex();
      const prevS = getActiveSectionIndex();
      if (prevB !== idx) {
        // Capture current section and remember last active section for this building.
        try { captureInputsToSection(prevS); } catch(_) {}
        buildingsState.lastActiveSection[prevB] = prevS;
      }

      // Ensure building exists
      if (!buildingsState.buildings[idx]) {
        buildingsState.buildings[idx] = createEmptySectionsState();
      }

      document.body.setAttribute('data-active-building', String(idx));
      sectionsState = buildingsState.buildings[idx];

      // Re-render tabs and restore last active section for the building.
      try { renderBuildingTabs(); } catch(_) {}
      const targetSection = buildingsState.lastActiveSection[idx] ?? 0;
      setActiveSectionIndex(Math.max(0, Math.min(targetSection, (sectionsState.count || 1) - 1)));
      updateCurrentSectionNameDisplay();
    }
    function setActiveSectionIndex(idx){
      // CRITICAL: Capture current section data BEFORE switching
      const prevIdx = getActiveSectionIndex();
      if (prevIdx !== idx) {
        try { captureInputsToSection(prevIdx); } catch(_) {}
      }
      
      document.body.setAttribute('data-active-section', String(idx));
      renderSectionTabs();
      updateCurrentSectionNameDisplay();
      // Restore inputs for this section
      hydrateInputsFromSection(idx);
      // Preload any existing evaluation for smooth rendering
      const existing = sectionsState.evaluations[idx];
      latestEvaluation = existing || null;
      // Navigate to this section's last visited step (default 1)
      const targetStep = sectionsState.lastStep[idx] || 1;
      goToStep(targetStep);

      // If we already have data for this section, render it immediately.
      // Otherwise the UI can look like only the "currently open" section was saved.
      if (targetStep === 2 && existing) {
        try { displayBrandklasseResults(existing); } catch(_) {}
      }
      if (targetStep === 3) {
        const eval3 = existing || sectionsState.evaluations[idx];
        if (eval3) {
          latestEvaluation = eval3;
          try { Promise.resolve(updateStep3Display()).catch(()=>{}); } catch(_) {}
        }
      }
      // If we landed on step 2 without an evaluation yet, compute now
      if (targetStep === 2 && !existing) {
        try { scheduleBrandklasseEvaluate({ immediate: true }); } catch(_) {}
      }
    }

    function renderBuildingTabs(){
      const tabs = document.getElementById('building-tabs');
      if (!tabs) return;
      const active = getActiveBuildingIndex();
      tabs.innerHTML = '';

      for (let i = 0; i < buildingsState.count; i++){
        const title = buildingsState.titles[i] || `Bygning ${i+1}`;
        const b = buildingsState.buildings[i];
        const total = Math.max(1, Number(b?.count ?? 1) || 1);
        const completed = Object.values(b?.progress || {}).filter(p => p?.evaluated && p?.requirementsViewed).length;
        const done = (completed === total && total > 0);

        const btn = document.createElement('button');
        btn.className = i === active ? 'btn-primary' : 'btn-secondary';
        btn.style.padding = '6px 12px';
        btn.style.position = 'relative';
        btn.style.display = 'flex';
        btn.style.alignItems = 'center';
        btn.style.gap = '8px';

        const titleSpan = document.createElement('span');
        titleSpan.textContent = title + (done ? ' âœ“' : '');
        btn.appendChild(titleSpan);

        // Remove button (Ã—) - only show if more than 1 building
        if (buildingsState.count > 1) {
          const removeBtn = document.createElement('span');
          removeBtn.innerHTML = 'Ã—';
          removeBtn.title = 'Fjern bygning';
          removeBtn.style.cssText = 'font-size: 18px; font-weight: bold; cursor: pointer; opacity: 0.7; margin-left: 4px;';
          removeBtn.addEventListener('mouseenter', () => { removeBtn.style.opacity = '1'; });
          removeBtn.addEventListener('mouseleave', () => { removeBtn.style.opacity = '0.7'; });
          removeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            showConfirmDialog(
              'Fjern bygning?',
              `Er du sikker pÃ¥ at du vil fjerne "${title}"? Alle bygningsafsnit og data for denne bygning vil blive slettet.`,
              () => removeBuilding(i)
            );
          });
          btn.appendChild(removeBtn);
        }

        btn.addEventListener('click', ()=> setActiveBuildingIndex(i));

        // Rename (same mini-popup UX)
        btn.addEventListener('dblclick', (e)=>{
          e.preventDefault();
          e.stopPropagation();
          if (i !== active) return;
          openRenamePopup(i, title, e, 'building');
        });
        btn.addEventListener('contextmenu', (e)=>{
          e.preventDefault();
          openRenamePopup(i, title, e, 'building');
        });

        tabs.appendChild(btn);
      }

      const addBtn = document.createElement('button');
      addBtn.className = 'btn-secondary';
      addBtn.innerHTML = '+ TilfÃ¸j bygning';
      addBtn.style.padding = '6px 12px';
      addBtn.style.fontWeight = '600';
      addBtn.addEventListener('click', () => addBuilding());
      tabs.appendChild(addBtn);
    }

    function addBuilding(){
      // Capture current section before adding
      try { captureInputsToSection(getActiveSectionIndex()); } catch(_) {}

      const newIndex = buildingsState.count;
      buildingsState.count++;
      buildingsState.titles[newIndex] = `Bygning ${buildingsState.count}`;
      buildingsState.buildings[newIndex] = createEmptySectionsState();
      buildingsState.lastActiveSection[newIndex] = 0;
      renderBuildingTabs();
      updateCurrentSectionNameDisplay();
    }

    function removeBuilding(indexToRemove){
      if (buildingsState.count <= 1) {
        alert('Du skal have mindst Ã©n bygning.');
        return;
      }

      const activeB = getActiveBuildingIndex();
      const activeS = getActiveSectionIndex();
      try { captureInputsToSection(activeS); } catch(_) {}

      buildingsState.count--;

      for (let i = indexToRemove; i < buildingsState.count; i++) {
        buildingsState.titles[i] = buildingsState.titles[i + 1];
        buildingsState.buildings[i] = buildingsState.buildings[i + 1];
        buildingsState.lastActiveSection[i] = buildingsState.lastActiveSection[i + 1];
      }

      delete buildingsState.titles[buildingsState.count];
      delete buildingsState.buildings[buildingsState.count];
      delete buildingsState.lastActiveSection[buildingsState.count];

      // Fix active building index after removal
      let nextActive = activeB;
      if (activeB >= buildingsState.count) nextActive = Math.max(0, buildingsState.count - 1);
      else if (activeB >= indexToRemove) nextActive = Math.max(0, activeB - 1);

      setActiveBuildingIndex(nextActive);
      renderBuildingTabs();
    }

    function renderSectionTabs(){
      const tabs = document.getElementById('section-tabs');
      if (!tabs) return;
      const active = getActiveSectionIndex();
      tabs.innerHTML = '';

      // Keep building-level badges in sync
      try { renderBuildingTabs(); } catch(_) {}
      for (let i=0;i<sectionsState.count;i++){
        const title = sectionsState.titles[i] || `Bygningsafsnit ${i+1}`;
        const prog = sectionsState.progress[i] || { evaluated:false, requirementsViewed:false };
        const done = prog.evaluated && prog.requirementsViewed;
        const btn = document.createElement('button');
        btn.className = i===active ? 'btn-primary' : 'btn-secondary';
        btn.style.padding = '6px 12px';
        btn.style.position = 'relative';
        btn.style.display = 'flex';
        btn.style.alignItems = 'center';
        btn.style.gap = '8px';
        
        const titleSpan = document.createElement('span');
        titleSpan.textContent = title + (done ? ' âœ“' : '');
        btn.appendChild(titleSpan);
        
        // Remove button (Ã—) - only show if more than 1 section
        if (sectionsState.count > 1) {
          const removeBtn = document.createElement('span');
          removeBtn.innerHTML = 'Ã—';
          removeBtn.title = 'Fjern bygningsafsnit';
          removeBtn.style.cssText = 'font-size: 18px; font-weight: bold; cursor: pointer; opacity: 0.7; margin-left: 4px;';
          removeBtn.addEventListener('mouseenter', () => { removeBtn.style.opacity = '1'; });
          removeBtn.addEventListener('mouseleave', () => { removeBtn.style.opacity = '0.7'; });
          removeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            showConfirmDialog(
              'Fjern bygningsafsnit?',
              `Er du sikker pÃ¥ at du vil fjerne "${title}"? Alle data for dette afsnit vil blive slettet.`,
              () => removeBuildingSection(i)
            );
          });
          btn.appendChild(removeBtn);
        }
        
        // Single click: switch immediately (no delay)
        btn.addEventListener('click', ()=> setActiveSectionIndex(i));
        
        // Double click: rename via the SAME mini-popup UI as right-click.
        // To avoid losing the dblclick due to re-render: only allow dblclick rename on the ACTIVE tab.
        btn.addEventListener('dblclick', (e)=>{
          e.preventDefault();
          e.stopPropagation();
          if (i !== active) return;
          openRenamePopup(i, title, e);
        });
        // Right-click fallback: prompt-based rename
        btn.addEventListener('contextmenu', (e)=>{
          e.preventDefault();
          openRenamePopup(i, title, e);
        });
        tabs.appendChild(btn);
      }
      
      // Add (+) button to create new section
      const addBtn = document.createElement('button');
      addBtn.className = 'btn-secondary';
      addBtn.innerHTML = '+ TilfÃ¸j bygningsafsnit';
      addBtn.style.padding = '6px 12px';
      addBtn.style.fontWeight = '600';
      addBtn.addEventListener('click', () => {
        addBuildingSection();
      });
      tabs.appendChild(addBtn);
      
      // Removed right-side inline editor; rename via double-click / hover pencil / right-click
    }
    
    // Update the current section name display at the top
    function updateCurrentSectionNameDisplay() {
      const nameEl = document.getElementById('current-section-name');
      if (nameEl) {
        const bIdx = getActiveBuildingIndex();
        const sIdx = getActiveSectionIndex();
        const buildingTitle = buildingsState.titles[bIdx] || `Bygning ${bIdx+1}`;
        const sectionTitle = sectionsState.titles[sIdx] || `Bygningsafsnit ${sIdx+1}`;
        nameEl.textContent = (sectionsState.count && sectionsState.count > 1)
          ? `${buildingTitle} â€” ${sectionTitle}`
          : buildingTitle;
      }
    }
    
    function addBuildingSection() {
      // CRITICAL: Capture current section data BEFORE switching
      const currentIdx = getActiveSectionIndex();
      captureInputsToSection(currentIdx);
      
      const newIndex = sectionsState.count;
      sectionsState.count++;
      sectionsState.titles[newIndex] = `Bygningsafsnit ${sectionsState.count}`;
      sectionsState.inputs[newIndex] = null;
      sectionsState.evaluations[newIndex] = null;
      sectionsState.progress[newIndex] = { evaluated: false, requirementsViewed: false };
      sectionsState.lastStep[newIndex] = 1;
      renderSectionTabs();

      // Do NOT auto-switch; keep user on current section.
      // The new section stays blank until the user clicks its tab.
      updateCurrentSectionNameDisplay();

      // Keep derived/global keys (like antal_BA) in sync immediately.
      // Without this, the right-side JSON (and evaluation payload) may still show the previous count
      // until the user changes a form field.
      try { scheduleEvaluate(); } catch(_) {}
    }
    
    function removeBuildingSection(indexToRemove) {
      if (sectionsState.count <= 1) {
        alert('Du skal have mindst Ã©t bygningsafsnit.');
        return;
      }
      
      // Remove data for this index
      sectionsState.count--;
      
      // Shift all data after this index down by one
      for (let i = indexToRemove; i < sectionsState.count; i++) {
        sectionsState.titles[i] = sectionsState.titles[i + 1];
        sectionsState.inputs[i] = sectionsState.inputs[i + 1];
        sectionsState.evaluations[i] = sectionsState.evaluations[i + 1];
        sectionsState.progress[i] = sectionsState.progress[i + 1];
        sectionsState.lastStep[i] = sectionsState.lastStep[i + 1];
        if (sectionsState.bilagExtras) sectionsState.bilagExtras[i] = sectionsState.bilagExtras[i + 1];
        if (sectionsState.kravChecks) sectionsState.kravChecks[i] = sectionsState.kravChecks[i + 1];
        if (sectionsState.kravResults) sectionsState.kravResults[i] = sectionsState.kravResults[i + 1];
        if (sectionsState.inputData) sectionsState.inputData[i] = sectionsState.inputData[i + 1];

        // Object-keyed state (string keys)
        if (sectionsState.kravCategoryDocs && typeof sectionsState.kravCategoryDocs === 'object') {
          sectionsState.kravCategoryDocs[String(i)] = sectionsState.kravCategoryDocs[String(i + 1)];
        }
        if (sectionsState.kravCategoryOrder && typeof sectionsState.kravCategoryOrder === 'object') {
          sectionsState.kravCategoryOrder[String(i)] = sectionsState.kravCategoryOrder[String(i + 1)];
        }
      }
      
      // Clean up last index
      delete sectionsState.titles[sectionsState.count];
      delete sectionsState.inputs[sectionsState.count];
      delete sectionsState.evaluations[sectionsState.count];
      delete sectionsState.progress[sectionsState.count];
      delete sectionsState.lastStep[sectionsState.count];
      if (sectionsState.bilagExtras) delete sectionsState.bilagExtras[sectionsState.count];
      if (sectionsState.kravChecks) delete sectionsState.kravChecks[sectionsState.count];
      if (sectionsState.kravResults) delete sectionsState.kravResults[sectionsState.count];
      if (sectionsState.inputData) delete sectionsState.inputData[sectionsState.count];

      if (sectionsState.kravCategoryDocs && typeof sectionsState.kravCategoryDocs === 'object') {
        delete sectionsState.kravCategoryDocs[String(sectionsState.count)];
      }
      if (sectionsState.kravCategoryOrder && typeof sectionsState.kravCategoryOrder === 'object') {
        delete sectionsState.kravCategoryOrder[String(sectionsState.count)];
      }
      
      // If we removed the active section, switch to the previous one (or 0)
      const currentActive = getActiveSectionIndex();
      if (currentActive >= sectionsState.count) {
        setActiveSectionIndex(Math.max(0, sectionsState.count - 1));
      } else if (currentActive >= indexToRemove) {
        // Stay on same logical section (which has shifted down in index)
        setActiveSectionIndex(currentActive);
      } else {
        // We're before the removed section, no change needed
        renderSectionTabs();

        // Active section didn't change, but section count did.
        // Refresh JSON/evaluation so antal_BA reflects the new count.
        try { scheduleEvaluate(); } catch(_) {}
      }
    }
    
    // Show confirmation dialog
    function showConfirmDialog(title, message, onConfirm, onCancel, options) {
      const opts = options && typeof options === 'object' ? options : {};
      const confirmText = typeof opts.confirmText === 'string' ? opts.confirmText : 'Fjern';
      const cancelText = typeof opts.cancelText === 'string' ? opts.cancelText : 'Annuller';

      const overlay = document.createElement('div');
      overlay.className = 'confirm-overlay';

      const modal = document.createElement('div');
      modal.className = 'confirm-modal';
      modal.setAttribute('role', 'dialog');
      modal.setAttribute('aria-modal', 'true');

      const header = document.createElement('div');
      header.className = 'confirm-header';
      header.textContent = title;

      const msg = document.createElement('div');
      msg.className = 'confirm-message';
      msg.textContent = message;

      const actions = document.createElement('div');
      actions.className = 'confirm-actions';

      let closed = false;
      const handleEscape = (e) => {
        if (e.key === 'Escape') close(false);
      };

      function close(confirmed) {
        if (closed) return;
        closed = true;
        try {
          if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
        } catch (_) {}
        document.removeEventListener('keydown', handleEscape);

        if (confirmed) {
          if (onConfirm) onConfirm();
        } else {
          if (onCancel) onCancel();
        }
      }

      const cancelBtn = document.createElement('button');
      cancelBtn.className = 'confirm-btn-cancel';
      cancelBtn.textContent = cancelText;
      cancelBtn.addEventListener('click', () => close(false));

      const confirmBtn = document.createElement('button');
      confirmBtn.className = 'confirm-btn-confirm';
      confirmBtn.textContent = confirmText;
      confirmBtn.addEventListener('click', () => close(true));

      actions.appendChild(cancelBtn);
      actions.appendChild(confirmBtn);

      modal.appendChild(header);
      modal.appendChild(msg);
      modal.appendChild(actions);

      overlay.appendChild(modal);
      document.body.appendChild(overlay);

      // Close on overlay click
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) close(false);
      });

      // Close on Escape key
      document.addEventListener('keydown', handleEscape);
    }

    function showProceedToKravPopup() {
      const msg = 'Inden vi gÃ¥r videre til kravene, bedes du dobbelttjekke, at dit design samt vÃ¦rktÃ¸jets valg af brandklasse og bilag stemmer overens med de relevante prÃ¦-accepterede lÃ¸sninger, som nu vises.';
      return new Promise((resolve) => {
        showConfirmDialog(
          'Dobbelttjek fÃ¸r krav',
          msg,
          () => resolve(true),
          () => resolve(false),
          { confirmText: 'OK, fortsÃ¦t', cancelText: 'Luk' }
        );
      });
    }

    function openRenamePopup(index, currentTitle, evt, kind){
      const targetKind = (kind === 'building') ? 'building' : 'section';
      // Remove existing popup
      document.querySelectorAll('.mini-popup').forEach(p => p.remove());
      const pop = document.createElement('div');
      pop.className = 'mini-popup';
      const input = document.createElement('input');
      input.type = 'text';
      input.value = currentTitle;
      const actions = document.createElement('div');
      actions.className = 'actions';
      const btnOk = document.createElement('button'); btnOk.className='btn-primary'; btnOk.textContent='Gem'; btnOk.style.padding='6px 10px';
      const btnCancel = document.createElement('button'); btnCancel.className='btn-secondary'; btnCancel.textContent='AnnullÃ©r'; btnCancel.style.padding='6px 10px';
      actions.appendChild(btnOk); actions.appendChild(btnCancel);
      pop.appendChild(input); pop.appendChild(actions);
      document.body.appendChild(pop);
      const x = evt.clientX, y = evt.clientY;
      const pad = 8;
      // Temporarily place, then measure to position ABOVE the click and centered
      pop.style.left = x + 'px';
      pop.style.top = y + 'px';
      // After next frame, compute size and adjust
      requestAnimationFrame(()=>{
        const rect = pop.getBoundingClientRect();
        const left = Math.max(8, x - rect.width/2);
        const top = Math.max(8, y - rect.height - pad);
        pop.style.left = left + 'px';
        pop.style.top = top + 'px';
      });
      input.focus(); input.select();
      const commit = ()=>{
        const v = input.value.trim();
        if (targetKind === 'building') {
          buildingsState.titles[index] = v;
          renderBuildingTabs();
        } else {
          sectionsState.titles[index] = v;
          renderSectionTabs();
        }
        updateCurrentSectionNameDisplay();
        pop.remove();
      };
      btnOk.addEventListener('click', commit);
      btnCancel.addEventListener('click', ()=> pop.remove());
      input.addEventListener('keydown', (e)=>{ if(e.key==='Enter') commit(); if(e.key==='Escape') pop.remove(); });
      // Close on outside click
      const onDocClick = (e)=>{ if(!pop.contains(e.target)) { pop.remove(); document.removeEventListener('click', onDocClick); } };
      setTimeout(()=> document.addEventListener('click', onDocClick), 0);
    }
    function captureInputsToSection(idx){
      sectionsState.inputs[idx] = canonicalizeInputData(buildJsonFromForm());
      // Also ensure bilagExtras are captured for this section
      const tilbygEl = document.getElementById('fld_med_tilbygning');
      const erhvEl = document.getElementById('fld_med_erhvervssammenbygning');
      if (!sectionsState.bilagExtras) sectionsState.bilagExtras = {};
      if (!sectionsState.bilagExtras[idx]) sectionsState.bilagExtras[idx] = {};
      if (tilbygEl && tilbygEl.value !== '') {
        sectionsState.bilagExtras[idx].med_tilbygning = (tilbygEl.value === 'true');
      }
      if (erhvEl && erhvEl.value !== '') {
        sectionsState.bilagExtras[idx].med_erhvervssammenbygning = (erhvEl.value === 'true');
      }
    }
    function hydrateInputsFromSection(idx){
      const obj = sectionsState.inputs[idx];
      // Always clear first, then apply section data.
      // This prevents any values from the previous section from "sticking" when the next section is blank/partial.
      clearFormInputs();
      if (!obj) return;
      try { updateFormFromJson(obj); } catch(_) {}
      
      // Restore bilag extras for this section
      const bilagExtras = sectionsState.bilagExtras?.[idx];
      if (bilagExtras) {
        const tilbygEl = document.getElementById('fld_med_tilbygning');
        const erhvEl = document.getElementById('fld_med_erhvervssammenbygning');
        if (tilbygEl && bilagExtras.med_tilbygning !== undefined) {
          tilbygEl.value = String(bilagExtras.med_tilbygning);
        }
        if (erhvEl && bilagExtras.med_erhvervssammenbygning !== undefined) {
          erhvEl.value = String(bilagExtras.med_erhvervssammenbygning);
        }
      }
      
      // Trigger status/eval refresh without overwriting manual JSON
      scheduleEvaluate();
      // Re-initialize custom selects after hydration
      setTimeout(() => {
        if (typeof initCustomSelects === 'function') initCustomSelects();
      }, 50);
    }
    
    // Clear all form inputs to default/empty state
    function clearFormInputs(){
      // Text/number inputs - NO DEFAULT VALUES, make everything blank
      document.querySelectorAll('input[type="number"]').forEach(input => {
        if (input.id === 'section-count') {
          // Don't clear section count - it's global
        } else {
          input.value = '';
        }
      });
      document.querySelectorAll('input[type="text"]').forEach(input => input.value = '');
      
      // Selects - ALWAYS set to first empty/disabled option or -1
      document.querySelectorAll('select').forEach(select => {
        // Look for first option that is disabled, has empty value, or says "VÃ¦lg"
        let emptyOptionIndex = -1;
        for (let i = 0; i < select.options.length; i++) {
          const opt = select.options[i];
          if (opt.disabled || opt.value === '' || opt.textContent.includes('VÃ¦lg')) {
            emptyOptionIndex = i;
            break;
          }
        }
        if (emptyOptionIndex >= 0) {
          select.selectedIndex = emptyOptionIndex;
        } else {
          // Force clear by setting selectedIndex to -1 (no selection)
          select.selectedIndex = -1;
        }
        // Force update the select display
        select.value = '';
      });
      
      // Clear bilag extras selects explicitly
      const tilbygEl = document.getElementById('fld_med_tilbygning');
      const erhvEl = document.getElementById('fld_med_erhvervssammenbygning');
      if (tilbygEl) tilbygEl.value = '';
      if (erhvEl) erhvEl.value = '';
      
      // Update JSON textarea
      const jsonTextarea = document.getElementById('json-input');
      if (jsonTextarea) jsonTextarea.value = '{}';
      
      // Re-initialize custom selects
      setTimeout(() => {
        if (typeof initCustomSelects === 'function') initCustomSelects();
      }, 50);
      
      // Update status display
      updateStatus();
    }

    // Wizard navigation
    function goToStep(stepNumber) {
      currentStep = stepNumber;
      
      // Hide all steps
      document.getElementById('wizard-step-1').style.display = 'none';
      document.getElementById('wizard-step-2').style.display = 'none';
      const s3 = document.getElementById('wizard-step-3'); if (s3) s3.style.display = 'none';
      const s4 = document.getElementById('wizard-step-4'); if (s4) s4.style.display = 'none';
      
      // Show current step
      document.getElementById(`wizard-step-${stepNumber}`).style.display = 'flex';
      
      // Re-initialize custom selects after content visibility changes
      setTimeout(() => {
        if (typeof initCustomSelects === 'function') initCustomSelects();
      }, 50);
      
      // Update step indicators
      document.getElementById('step-indicator-1').classList.remove('active', 'completed');
      document.getElementById('step-indicator-2').classList.remove('active', 'completed');
      const i3 = document.getElementById('step-indicator-3'); if (i3) i3.classList.remove('active', 'completed');
      const i4 = document.getElementById('step-indicator-4'); if (i4) i4.classList.remove('active', 'completed');
      
      if (stepNumber === 1) {
        document.getElementById('step-indicator-1').classList.add('active');
        // IMPORTANT: Step 1 result cards (AK/RK/Bilag/BK) must reflect the active section.
        // Switching building/section hydrates inputs but does not fire input events, so we
        // re-render (or clear) the results explicitly to avoid stale values.
        try {
          const idx = getActiveSectionIndex();
          const existing = sectionsState?.evaluations?.[idx];
          latestEvaluation = existing || null;

          if (existing) {
            try { displayResults(existing); } catch(_) {}
          } else {
            try {
              // Reset matched rule IDs
              if (typeof currentMatchedRules === 'object' && currentMatchedRules) {
                currentMatchedRules.anvendelseskategori = null;
                currentMatchedRules.risikoklasse = null;
                currentMatchedRules.relevant_bilag = null;
                currentMatchedRules.brandklasse = null;
              }
            } catch(_) {}

            try { setResultRowValue('anvendelse', '-', ''); } catch(_) {}
            try { setResultRowStatus('anvendelse', false); } catch(_) {}
            try { setResultRowValue('risiko', '-', ''); } catch(_) {}
            try { setResultRowStatus('risiko', false); } catch(_) {}
            try { setResultRowValue('bilag', '-', ''); } catch(_) {}
            try { setResultRowStatus('bilag', false); } catch(_) {}

            const headline = document.getElementById('headline-results');
            if (headline) headline.textContent = 'Resultater';
            const banner = document.getElementById('eval-error-banner');
            if (banner) banner.remove();

            try { updateResultValidationStatus(); } catch(_) {}
          }
        } catch(_) {}

        try { updateStep1BrandklasseCard(); } catch(_) {}
      } else if (stepNumber === 2) {
        document.getElementById('step-indicator-1').classList.add('completed');
        document.getElementById('step-indicator-2').classList.add('active');
        // Update step 2 displays
        updateStep2Display();
      } else if (stepNumber === 3) {
        document.getElementById('step-indicator-1').classList.add('completed');
        document.getElementById('step-indicator-2').classList.add('completed');
        const i3b = document.getElementById('step-indicator-3'); if (i3b) i3b.classList.add('active');
        updateStep3Display();
      } else if (stepNumber === 4) {
        document.getElementById('step-indicator-1').classList.add('completed');
        document.getElementById('step-indicator-2').classList.add('completed');
        const i3c = document.getElementById('step-indicator-3'); if (i3c) i3c.classList.add('completed');
        const i4b = document.getElementById('step-indicator-4'); if (i4b) i4b.classList.add('active');
        renderFinalOverview();
      }
      // Remember last visited step per section
      const activeIdx = getActiveSectionIndex();
      sectionsState.lastStep[activeIdx] = stepNumber;
    }

    // Allow clicking the top step indicators to navigate directly.
    function initWizardStepIndicatorNavigation(){
      const steps = [1,2,3,4];
      steps.forEach((n)=>{
        const el = document.getElementById(`step-indicator-${n}`);
        if (!el) return;

        el.setAttribute('role', 'button');
        el.setAttribute('tabindex', '0');
        el.setAttribute('aria-label', `GÃ¥ til trin ${n}`);

        const navigate = async (evt)=>{
          try { evt?.preventDefault?.(); } catch(_) {}
          try { evt?.stopPropagation?.(); } catch(_) {}

          // Capture current section inputs before leaving the page.
          try { captureInputsToSection(getActiveSectionIndex()); } catch(_) {}

          // Keep latestEvaluation in sync with the active section, if present.
          try {
            const idx = getActiveSectionIndex();
            const existing = sectionsState?.evaluations?.[idx];
            if (existing) latestEvaluation = existing;
          } catch(_) {}

          // Convenience: if user jumps to Step 2 from Step 1 and BK isn't computed yet, compute once.
          try {
            const idx = getActiveSectionIndex();
            if (n === 2 && currentStep === 1 && !sectionsState?.evaluations?.[idx]) {
              await evaluateBrandklasseNow();
            }
          } catch(_) {}

          goToStep(n);
        };

        el.addEventListener('click', navigate);
        el.addEventListener('keydown', (e)=>{
          if (e.key === 'Enter' || e.key === ' ') navigate(e);
        });
      });
    }

    try { initWizardStepIndicatorNavigation(); } catch(_) {}

    let brandklasseTimer = null;
    function setStep2Status(text){
      const el = document.getElementById('step2-bk-status');
      if (!el) return;
      el.textContent = text;
      const t = (text === null || text === undefined) ? '' : String(text);
      const isInstruction = /tjek\s+om\s+dine\s+valg\s+stemmer\s+med\s+de\s+figurer/i.test(t);
      el.classList.toggle('step2-status--instruction', isInstruction);
    }
    function showStep2InlineBrandklasse(show){
      const el = document.getElementById('step2-bk-inline');
      if (!el) return;
      el.style.display = show ? '' : 'none';
    }
    function scheduleBrandklasseEvaluate({ immediate = false } = {}){
      if (brandklasseTimer) clearTimeout(brandklasseTimer);
      const run = ()=>{
        // Brandklasse must be computed from Step 1 only. Step 2 is view-only.
        if (currentStep !== 1) return;
        evaluateBrandklasseNow();
      };
      if (immediate) return run();
      brandklasseTimer = setTimeout(run, 250);
    }

    // --- Result-driven field highlights (Step 1) ---
    let lastOptimizationHighlightKeys = new Set();
    // NOTE: These are the *requirements we actually display* on the right.
    // Each item is either a string (legacy) or an object like: { field, question }.
    let latestDisplayedHighlightQuestionsBase = [];

    function normalizeHintText(v){
      const s = (v === null || v === undefined) ? '' : String(v);
      return s
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
    }

    function getStep1FieldRows(){
      const root = document.getElementById('step1-field-list');
      if (!root) return [];
      return Array.from(root.querySelectorAll('.form-field'));
    }

    function getStep1FieldRowByControlId(controlId){
      if (!controlId) return null;
      const el = document.getElementById(controlId);
      if (!el) return null;
      return el.closest('.form-field');
    }

    function mapFieldKeyToControlId(fieldKey){
      const f = (fieldKey === null || fieldKey === undefined) ? '' : String(fieldKey).trim();
      if (!f) return null;
      const id = `fld_${f}`;
      return document.getElementById(id) ? id : null;
    }

    function clearOptimizationHighlights(){
      getStep1FieldRows().forEach(row => {
        row.classList.remove('opt-highlight');
        row.classList.remove('opt-highlight-opt');
        row.classList.remove('opt-pulse');
      });
      lastOptimizationHighlightKeys = new Set();
    }

    function applyHighlightsFromDisplayedQuestions(questions){
      // Supports:
      // - { field: 'antal_personer_BA', question?: '...', kind?: 'missing'|'opt' }: stable ID mapping
      const rawItems = Array.isArray(questions) ? questions : [];
      const seen = new Set();
      const uniq = [];
      rawItems.forEach((item)=>{
        if (item === null || item === undefined) return;
        if (typeof item === 'object') {
          const field = (item.field === null || item.field === undefined) ? '' : String(item.field).trim();
          const question = (item.question === null || item.question === undefined) ? '' : String(item.question).trim();
          const kind = (item.kind === 'opt' || item.kind === 'missing') ? item.kind : null;
          const k = field ? `f:${field}` : '';
          if (!k || seen.has(k)) return;
          seen.add(k);
          uniq.push({ field: field || null, question: question || null, kind });
        }
      });

      const rows = getStep1FieldRows();
      rows.forEach(r => { r.classList.remove('opt-highlight'); r.classList.remove('opt-highlight-opt'); r.classList.remove('opt-pulse'); });

      if (!uniq.length) {
        lastOptimizationHighlightKeys = new Set();
        return;
      }

      // Track pulses per control id (stable)
      const matchedKeys = new Set();
      const matchedRows = new Set();
      const rowKinds = new Map();

      const controlHasValue = (controlId)=>{
        if (!controlId) return false;
        const el = document.getElementById(controlId);
        if (!el) return false;
        // Select
        if (el.tagName && el.tagName.toLowerCase() === 'select') {
          return String(el.value ?? '').trim() !== '';
        }
        // Input
        if (el.tagName && el.tagName.toLowerCase() === 'input') {
          const t = (el.getAttribute('type') || '').toLowerCase();
          if (t === 'checkbox' || t === 'radio') return el.checked === true;
          return String(el.value ?? '').trim() !== '';
        }
        // Fallback
        return String(el.value ?? '').trim() !== '';
      };

      uniq.forEach(item => {
        if (!item || typeof item !== 'object' || !item.field) return;
        const mappedId = mapFieldKeyToControlId(item.field);
        if (!mappedId) return;
        const row = getStep1FieldRowByControlId(mappedId);
        if (!row) return;

        matchedRows.add(row);
        matchedKeys.add(mappedId);

        // Apply green only when this is an optimization-change AND the control already has a value.
        const wantsOpt = (item.kind === 'opt');
        const isFilled = controlHasValue(mappedId);
        if (wantsOpt && isFilled) rowKinds.set(row, 'opt');
      });

      matchedRows.forEach(row => {
        row.classList.add('opt-highlight');
        if (rowKinds.get(row) === 'opt') row.classList.add('opt-highlight-opt');
        const key = (()=>{
          try {
            const el = row.querySelector('input,select,textarea');
            return el?.id ? String(el.id) : null;
          } catch(_) {
            return null;
          }
        })();
        if (key && !lastOptimizationHighlightKeys.has(key)) {
          row.classList.add('opt-pulse');
          setTimeout(()=>{ row.classList.remove('opt-pulse'); }, 750);
        }
      });

      lastOptimizationHighlightKeys = matchedKeys;
    }

    function updateStep1BrandklasseCard(){
      // Keep Brandklasse quiet on initial page load.
      try {
        const idx = getActiveSectionIndex();
        const evaluated = !!(sectionsState?.progress?.[idx]?.evaluated);
        if (!evaluated) {
          const elVal0 = document.getElementById('result-brand');
          const elDesc0 = document.getElementById('result-brand-desc');
          if (elVal0) elVal0.textContent = '-';
          if (elDesc0) elDesc0.textContent = '';
          try { applyHighlightsFromDisplayedQuestions(latestDisplayedHighlightQuestionsBase); } catch(_) {}
          return;
        }
      } catch(_) {}

      const bkValue = latestEvaluation?.brandklasse?.value;
      const kravOut = latestEvaluation?.bilag_outputs?.krav ?? latestEvaluation?.bilag_outputs?.Krav;
      const kravText = Array.isArray(kravOut) ? kravOut.join('; ') : (kravOut ?? '');
      const hasBk = (bkValue !== null && bkValue !== undefined);

      const displayVal = hasBk ? String(bkValue) : '-';

      const elVal = document.getElementById('result-brand');
      const elDesc = document.getElementById('result-brand-desc');
      if (elVal) elVal.textContent = hasBk ? displayVal : '-';
      if (elDesc) {
        if (hasBk) {
          const opt = latestEvaluation?.suggestions?.brandklasse;
          if (Array.isArray(opt) && opt.length) {
            const bkQuestions = [];
            const lines = ['Optimering:'];
            opt.slice(0, 3).forEach((s)=>{
              const target = s?.target_value;
              if (target === null || target === undefined) return;
              const parts = [];

              const missing = Array.isArray(s?.missing_questions) ? s.missing_questions : [];
              if (missing.length) parts.push(`Udfyld: ${missing.slice(0, 4).join(', ')}`);
              // Prefer stable fields for highlighting.
              const mf = Array.isArray(s?.missing_fields) ? s.missing_fields : [];
              if (mf.length) mf.forEach(f => bkQuestions.push({ field: f, kind: 'missing' }));

              const req = Array.isArray(s?.required_fields) ? s.required_fields : [];
              const reqTxt = req
                .map(r => {
                  const q = r?.question;
                  const exp = r?.expected_value;
                  if (!q) return '';
                  if (exp === null || exp === undefined || String(exp).trim() === '') return `${q}`;
                  return `${q} = ${exp}`;
                })
                .filter(Boolean);
              if (reqTxt.length) parts.push(`SÃ¦t: ${reqTxt.slice(0, 3).join('; ')}`);
              req.forEach(r => {
                if (r?.field) bkQuestions.push({ field: r.field, question: r?.question || null, kind: 'opt' });
              });

              const nums = Array.isArray(s?.numeric_adjustments) ? s.numeric_adjustments : [];
              const numsTxt = nums
                .map(a => {
                  const q = a?.question;
                  const exp = a?.expected;
                  const d = a?.delta_abs;
                  if (!q || !exp) return '';
                  const deltaTxt = (d !== null && d !== undefined && Number.isFinite(Number(d)))
                    ? ` (afvigelse: ${Number(d).toFixed(0)})`
                    : '';
                  return `${q} ${exp}${deltaTxt}`;
                })
                .filter(Boolean);
              if (numsTxt.length) parts.push(`JustÃ©r: ${numsTxt.slice(0, 3).join('; ')}`);
              nums.forEach(a => {
                if (a?.field) bkQuestions.push({ field: a.field, question: a?.question || null, kind: 'opt' });
              });

              const detail = parts.length ? ` ${parts.join(' | ')}` : '';
              lines.push(`â€¢ BK${target}:${detail}`);
            });
            elDesc.textContent = lines.join('\n');

            // Only highlight when BK is actually showing requirements (not "Afventer").
            try { applyHighlightsFromDisplayedQuestions([...latestDisplayedHighlightQuestionsBase, ...bkQuestions]); } catch(_) {}
          } else {
            elDesc.textContent = '';
            try { applyHighlightsFromDisplayedQuestions(latestDisplayedHighlightQuestionsBase); } catch(_) {}
          }
        } else {
          const cand = latestEvaluation?.candidates?.brandklasse;
          if (Array.isArray(cand) && cand.length) {
            const values = Array.from(new Set(cand.map(c => c?.value).filter(v => v !== null && v !== undefined).map(v => String(v))));
            const missingQs = Array.from(new Set(
              cand.flatMap(c => Array.isArray(c?.missing_questions) ? c.missing_questions : [])
                .map(v => String(v ?? '').trim())
                .filter(Boolean)
            )).slice(0, 4);
            const missingFields = Array.from(new Set(
              cand.flatMap(c => Array.isArray(c?.missing_fields) ? c.missing_fields : [])
                .map(v => String(v ?? '').trim())
                .filter(Boolean)
            )).slice(0, 6);
            const lines = [];
            if (values.length) lines.push(`Kan blive: ${values.slice(0, 6).map(v => `BK${v}`).join(' eller ')}`);
            if (missingQs.length) {
              lines.push('For at afgÃ¸re:');
              missingQs.forEach(q => lines.push(`â€¢ ${q}`));
            }
            elDesc.textContent = lines.join('\n');

            // Highlight by stable fields when available.
            const hl = missingFields.length ? missingFields.map(f => ({ field: f, kind: 'missing' })) : [];
            try { applyHighlightsFromDisplayedQuestions([...latestDisplayedHighlightQuestionsBase, ...hl]); } catch(_) {}
          } else {
            const waiting = [];
            const akMissing = (latestEvaluation?.anvendelseskategori?.value === null || latestEvaluation?.anvendelseskategori?.value === undefined || String(latestEvaluation?.anvendelseskategori?.value ?? '').trim() === '');
            const rkMissing = (latestEvaluation?.risikoklasse?.value === null || latestEvaluation?.risikoklasse?.value === undefined || String(latestEvaluation?.risikoklasse?.value ?? '').trim() === '');
            const bilagMissing = (()=>{
              const v = latestEvaluation?.relevant_bilag?.value ?? latestEvaluation?.relevant_bilag ?? latestEvaluation?.bilag;
              return (v === null || v === undefined || String(v).trim() === '');
            })();
            if (akMissing) waiting.push('Anvendelseskategori');
            if (rkMissing) waiting.push('Risikoklasse');
            if (bilagMissing) waiting.push('Relevant bilag');
            // If prerequisites are complete but BK isn't (yet), avoid leaving the box empty.
            // (Often BK is coming from the /evaluate-complete call or awaits totalareal.)
            if (waiting.length) {
              elDesc.textContent = `Afventer: ${waiting.join(', ')}`;
              // If BK is waiting, do not highlight BK requirements.
              try { applyHighlightsFromDisplayedQuestions(latestDisplayedHighlightQuestionsBase); } catch(_) {}
            } else {
              // Prereqs are known; show what BK still needs (field-based) instead of just "Beregner".
              // If we haven't called /evaluate-complete yet, we may not have missing_inputs/candidates.
              // In that case, fall back to known BK prerequisite(s) like totalareal.
              try {
                const areaTotalNum = asNum('fld_area_total');
                const hasAreaTotalNum = (areaTotalNum !== null);
                if (!hasAreaTotalNum) {
                  elDesc.textContent = 'For at beregne:\nâ€¢ Total bygningsareal (hele bygningen) [mÂ²]';
                  try { applyHighlightsFromDisplayedQuestions([...latestDisplayedHighlightQuestionsBase, { field: 'area_total', kind: 'missing' }]); } catch(_) {}
                  return;
                }
              } catch(_) {}

              const mi = Array.isArray(latestEvaluation?.missing_inputs) ? latestEvaluation.missing_inputs : [];
              const bkMi = mi
                .filter(x => {
                  const n = String(x?.node_name ?? x?.node ?? '').toLowerCase();
                  return n.includes('brand');
                })
                .sort((a, b) => Number(b?.score ?? 0) - Number(a?.score ?? 0));

              const bkMiQuestions = Array.from(new Set(bkMi.map(x => x?.question).filter(Boolean))).slice(0, 6);
              const bkMiFields = Array.from(new Set(bkMi.map(x => x?.field).filter(Boolean))).slice(0, 8);

              if (bkMiQuestions.length || bkMiFields.length) {
                const lines = [];
                lines.push('For at beregne:');
                if (bkMiQuestions.length) bkMiQuestions.forEach(q => lines.push(`â€¢ ${q}`));
                else bkMiFields.forEach(f => lines.push(`â€¢ ${f}`));
                elDesc.textContent = lines.join('\n');
                const hl = bkMiFields.map(f => ({ field: f, kind: 'missing' }));
                try { applyHighlightsFromDisplayedQuestions([...latestDisplayedHighlightQuestionsBase, ...hl]); } catch(_) {}
              } else {
                elDesc.textContent = 'Beregnerâ€¦';
                try { applyHighlightsFromDisplayedQuestions(latestDisplayedHighlightQuestionsBase); } catch(_) {}
              }
            }
          }
        }
      }

      try { setResultRowStatus('brand', hasBk); } catch(_) {}
      
      // Update brandklasse matched_rule_id for validation
      currentMatchedRules.brandklasse = latestEvaluation?.brandklasse?.matched_rule_id || null;
      console.log('[Brandklasse] updateStep1BrandklasseCard - matched_rule_id:', currentMatchedRules.brandklasse);
      console.log('[Brandklasse] latestEvaluation.brandklasse:', latestEvaluation?.brandklasse);
      // Update validation badge for brandklasse specifically
      updateResultValidationStatus();

      // Highlights are applied above based on what BK is currently showing.
    }

    async function evaluateBrandklasseNow(){
      // Compute brandklasse from Step 1 only. Step 2 is display-only.
      if (currentStep !== 1) return;

      const areaTotal = asNum('fld_area_total');
      const hasAreaTotal = (areaTotal !== null);

      const idx = getActiveSectionIndex();

      setStep2Status(hasAreaTotal ? 'Beregner brandklasseâ€¦' : 'Beregner forslag (brandklasse krÃ¦ver totalareal)â€¦');
      try {
        const data = { ...canonicalizeInputData(buildJsonFromForm()), ...getActiveBilagExtras() };
        const response = await fetch(`${API_BASE}/evaluate-complete`, {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify(data)
        });
        if (!response.ok) throw new Error('BK API request failed');
        const result = await response.json();
        
        // Store brandklasse matched rule ID
        console.log('[Brandklasse] evaluateBrandklasseNow - result.brandklasse:', result?.brandklasse);
        if (result?.brandklasse?.matched_rule_id) {
          currentMatchedRules.brandklasse = result.brandklasse.matched_rule_id;
          console.log('[Brandklasse] Stored matched_rule_id:', currentMatchedRules.brandklasse);
        } else {
          console.warn('[Brandklasse] No matched_rule_id in result!');
        }
        
        // Merge brandklasse outputs into existing evaluation to avoid wiping AK/RK/Bilag.
        const previous = sectionsState.evaluations[idx] ?? latestEvaluation ?? {};
        const merged = { ...previous, ...result };
        if (!('anvendelseskategori' in result) && previous.anvendelseskategori !== undefined) merged.anvendelseskategori = previous.anvendelseskategori;
        if (!('risikoklasse' in result) && previous.risikoklasse !== undefined) merged.risikoklasse = previous.risikoklasse;
        if (!('relevant_bilag' in result) && previous.relevant_bilag !== undefined) merged.relevant_bilag = previous.relevant_bilag;
        if (!('bilag' in result) && previous.bilag !== undefined) merged.bilag = previous.bilag;
        latestEvaluation = merged;
        // Persist per section
        sectionsState.evaluations[idx] = merged;
        // Store input data for explanations
        sectionsState.inputData[idx] = data;
        sectionsState.progress[idx] = { ...(sectionsState.progress[idx]||{}), evaluated:true };
        renderSectionTabs();
        // Update UI
        await updateStep2Display();
        try { updateStep1BrandklasseCard(); } catch(_) {}
        
        // Update validation badges for brandklasse
        updateResultValidationStatus();
        const bkValue = result?.brandklasse?.value;
        const hasBk = (bkValue !== null && bkValue !== undefined);
        if (!hasAreaTotal) {
          setStep2Status('Indtast det totale bygningsareal pÃ¥ side 1 for endelig brandklasse. Forslag vises i resultater.');
        } else {
          setStep2Status(hasBk ? 'Tjek om dine valg stemmer med de figurer der er refereret her' : 'Kunne ikke beregne brandklasse endnu.');
        }
      } catch (e) {
        showStep2InlineBrandklasse(false);
        setStep2Status('Kunne ikke beregne brandklasse/forslag. Tjek input og at backend kÃ¸rer.');
        try { updateStep1BrandklasseCard(); } catch(_) {}
      }
    }
    
    async function updateStep2Display() {
      // Step 2: Brandklasse + outputs
      const bkValue = latestEvaluation?.brandklasse?.value;
      const bkDesc = (latestEvaluation?.brandklasse?.description ?? '').trim();
      const kravOut = latestEvaluation?.bilag_outputs?.krav ?? latestEvaluation?.bilag_outputs?.Krav;
      const kravText = Array.isArray(kravOut) ? kravOut.join('; ') : (kravOut ?? '');
      const hasBk = (bkValue !== null && bkValue !== undefined);

      const bkDisplayValue = hasBk ? String(bkValue) : '-';

      // Inline brandklasse feedback (center card)
      const inlineVal = document.getElementById('step2-bk-inline-value');
      const inlineDesc = document.getElementById('step2-bk-inline-desc');
      if (inlineVal) inlineVal.textContent = bkDisplayValue;
      const showDesc = hasBk;
      // Avoid redundancy like "1" + "Brandklasse 1".
      const descLooksRedundant = (bkValue !== null && bkValue !== undefined) && /^brandklasse\s*\d+\s*$/i.test(bkDesc);
      if (inlineDesc) inlineDesc.textContent = (showDesc && !descLooksRedundant) ? bkDesc : '';
      showStep2InlineBrandklasse(hasBk);

      // Enable continue when brandklasse exists
      const btnContinue = document.getElementById('btn-continue-step2');
      if (btnContinue) btnContinue.disabled = !hasBk;

      // Render additional outputs
      const outputs = latestEvaluation?.bilag_outputs || {};
      const outputsWrap = document.getElementById('step2-outputs');
      if (outputsWrap) outputsWrap.style.display = hasBk ? '' : 'none';

      const formatBool = (v) => {
        if (v === true || v === 'true' || v === 1 || v === '1') return 'Ja';
        if (v === false || v === 'false' || v === 0 || v === '0') return 'Nej';
        if (v === null || v === undefined || String(v).trim() === '') return '-';
        return String(v);
      };
      const setText = (id, value) => {
        const el = document.getElementById(id);
        if (el) el.textContent = value;
      };

      const prae = outputs['Prae-accepteret_Godkendt'] ?? outputs['prÃ¦-accepteret_godkendt'] ?? outputs['Prae-accepteret_godkendt'];
      const raadKrav = outputs['brandrÃ¥dgiver_krav'] ?? outputs['brandradgiver_krav'];
      const raadCert = outputs['brandrÃ¥dgiver_certificeringsniveau'] ?? outputs['brandradgiver_certificeringsniveau'];
      const krav = outputs['Krav'] ?? outputs['krav'];
      const pickVigtig = () => {
        const explicit = [
          outputs['Vigtig_information'],
          outputs['vigtig_information'],
          outputs['Vigtig information'],
          outputs['vigtig information'],
          outputs['important_information'],
          outputs['Important_information'],
          outputs['Important information'],
          outputs['important information'],
        ];
        for (const v of explicit) {
          if (v !== undefined && v !== null && String(v).trim() !== '') return v;
        }
        // Fallback: look for any output key that suggests important info.
        const keys = Object.keys(outputs);
        const candidates = keys.filter(k => /vigtig|important/i.test(k));
        for (const k of candidates) {
          const v = outputs[k];
          if (v !== undefined && v !== null && String(v).trim() !== '') return v;
        }
        return undefined;
      };
      const vigtig = pickVigtig();

      const pickFigurTekst = () => {
        const explicit = [
          outputs['figur_tekst'],
          outputs['Figur_tekst'],
          outputs['Figurtekst'],
          outputs['figurtekst'],
          outputs['Figur tekst'],
          outputs['figur tekst'],
          outputs['figure_text'],
          outputs['Figure_text'],
          outputs['Figure text'],
          outputs['figure text'],
        ];
        for (const v of explicit) {
          if (v !== undefined && v !== null && (Array.isArray(v) || String(v).trim() !== '')) return v;
        }
        const keys = Object.keys(outputs);
        const candidates = keys.filter(k => /(figur|figure).*(tekst|text)|(tekst|text).*(figur|figure)/i.test(k));
        for (const k of candidates) {
          const v = outputs[k];
          if (v !== undefined && v !== null && (Array.isArray(v) || String(v).trim() !== '')) return v;
        }
        return undefined;
      };

      const parseFigureTextBlocks = (v) => {
        if (v === null || v === undefined) return [];

        const normalizeText = (raw) => {
          let s = String(raw ?? '');
          // Normalize linebreaks and handle the common â€œdouble-escapedâ€ form where the text
          // contains literal backslash-n sequences (e.g. "...\\n\\n...").
          s = s.replace(/\r\n/g, '\n');
          s = s.replace(/\\n/g, '\n');
          s = s.replace(/\\t/g, '\t');

          // Some decision-table cells were saved with an extra pair of quotes.
          // Example value starts with '"PÃ¥ Figur ...' and ends with '..."'.
          s = s.trim();
          if (s.length >= 2 && s.startsWith('"') && s.endsWith('"')) {
            s = s.slice(1, -1).trim();
          }
          return s;
        };

        if (Array.isArray(v)) {
          const arr = v.map(x => normalizeText(x).trim());
          while (arr.length && arr[0] === '') arr.shift();
          while (arr.length && arr[arr.length - 1] === '') arr.pop();
          return arr;
        }
        const s = normalizeText(v);
        const blocks = s.split(/\n\s*\n+/g).map(b => String(b).trim());
        while (blocks.length && blocks[0] === '') blocks.shift();
        while (blocks.length && blocks[blocks.length - 1] === '') blocks.pop();
        return blocks;
      };
      const figurTekstRaw = pickFigurTekst();
      const pickFigurRef = () => {
        const explicit = [
          ['figur_reference', outputs['figur_reference']],
          ['Figurer', outputs['Figurer']],
          ['figurReference', outputs['figurReference']],
          ['figur-referencer', outputs['figur-referencer']],
          ['Figur_reference', outputs['Figur_reference']],
          ['figurreferencer', outputs['figurreferencer']],
        ];
        for (const [k, v] of explicit) {
          if (v !== undefined && v !== null && String(v).trim() !== '') return { key: k, value: v };
        }

        // Fallback: look for any output key that suggests figures.
        const keys = Object.keys(outputs);
        const figureKeys = keys.filter(k => /figur|figure/i.test(k));
        for (const k of figureKeys) {
          const v = outputs[k];
          if (v !== undefined && v !== null && String(v).trim() !== '') return { key: k, value: v };
        }

        // As a last attempt, some backends might return this at top-level.
        const topLevel = latestEvaluation?.figur_reference ?? latestEvaluation?.figurReference;
        if (topLevel !== undefined && topLevel !== null && String(topLevel).trim() !== '') return { key: 'latestEvaluation.*', value: topLevel };
        return { key: '', value: undefined };
      };
      const { key: figurKey, value: figurRef } = pickFigurRef();

      setText('step2-out-prae', formatBool(prae));
      setText('step2-out-brandraadgiver', formatBool(raadKrav));
      setText('step2-out-cert', (raadCert === null || raadCert === undefined || String(raadCert).trim() === '') ? '-' : String(raadCert));
      setText('step2-out-krav', (krav === null || krav === undefined || String(krav).trim() === '') ? '-' : (Array.isArray(krav) ? krav.join('; ') : String(krav)));

      const importantCard = document.getElementById('step2-out-important');
      const importantText = document.getElementById('step2-out-important-text');
      // IMPORTANT: Use only Vigtig_information (bilag_outputs). Do not fall back to bilagsinformation.
      const viktigTextRaw = vigtig;
      const vigtigText = (viktigTextRaw === null || viktigTextRaw === undefined) ? '' : String(viktigTextRaw).trim();
      // Show important info in the figures header (instead of the static "Figur-reference" title)
      const figTitleEl = document.getElementById('step2-fig-title');
      const figSubtitleEl = document.getElementById('step2-fig-subtitle');
      if (figTitleEl) {
        if (vigtigText) {
          figTitleEl.style.display = '';
          figTitleEl.textContent = vigtigText;
        } else {
          figTitleEl.style.display = 'none';
          figTitleEl.textContent = '';
        }
      }
      if (figSubtitleEl) {
        figSubtitleEl.textContent = '';
        figSubtitleEl.style.display = 'none';
      }

      // Keep legacy card hidden to avoid duplicated information.
      if (importantCard) importantCard.style.display = 'none';
      if (importantText) importantText.textContent = vigtigText;

      const figuresCard = document.getElementById('step2-out-figures');
      const figuresCarousel = document.getElementById('step2-figure-carousel');
      const figuresDebug = document.getElementById('step2-figures-debug');
      const parseRefs = (v) => {
        if (v === null || v === undefined) return [];
        if (Array.isArray(v)) return v.map(x => String(x).trim()).filter(Boolean);
        const s = String(v).trim();
        if (!s) return [];
        // Accept common separators: comma/semicolon/newline and also Danish "og" / "&".
        // Examples: "1.3.1 og 1.3.2" or "1.3.1, 1.3.2".
        return s
          .replace(/\s+og\s+/gi, ',')
          .replace(/\s+and\s+/gi, ',')
          .replace(/\s*&\s*/g, ',')
          .split(/[,;\n]/g)
          .map(x => x.trim())
          .filter(Boolean);
      };
      const refs = parseRefs(figurRef);
      if (figuresCard) figuresCard.style.display = hasBk ? '' : 'none';
      if (figuresDebug) {
        const allFigureKeys = Object.keys(outputs).filter(k => /figur|figure/i.test(k));
        if (!hasBk) {
          figuresDebug.style.display = 'none';
        } else if (refs.length) {
          figuresDebug.style.display = 'none';
        } else {
          const raw = (figurRef === undefined) ? '(ingen)' : String(figurRef);
          figuresDebug.style.display = '';
          figuresDebug.textContent =
            `Ingen figur-reference fundet i output.\n` +
            `Fundne figur-nÃ¸gler: ${allFigureKeys.length ? allFigureKeys.join(', ') : '(ingen)'}\n` +
            `Brugt nÃ¸gle: ${figurKey || '(ingen)'}\n` +
            `RÃ¥ vÃ¦rdi: ${raw}`;
        }
      }
      if (!hasBk) {
        step2FigureRefs = [];
        step2FigureIndex = 0;
        step2FigureTextBlocks = [];
        if (figuresCarousel) figuresCarousel.style.display = 'none';
      } else if (!refs.length) {
        step2FigureRefs = [];
        step2FigureIndex = 0;
        step2FigureTextBlocks = [];
        if (figuresCarousel) figuresCarousel.style.display = 'none';
      } else {
        // Keep index stable when possible.
        const prevRef = (Array.isArray(step2FigureRefs) && step2FigureRefs.length)
          ? String(step2FigureRefs[step2FigureIndex] ?? '')
          : '';
        step2FigureRefs = refs;
        step2FigureTextBlocks = parseFigureTextBlocks(figurTekstRaw);
        if (prevRef) {
          const found = step2FigureRefs.findIndex(r => String(r) === prevRef);
          step2FigureIndex = found >= 0 ? found : 0;
        } else {
          step2FigureIndex = clamp(step2FigureIndex, 0, step2FigureRefs.length - 1);
        }
        await renderStep2Figure();
      }
    }

    async function updateStep3Display() {
      // Step 3: Requirements based on bilag + brandklasse
      if (!latestEvaluation) {
        const setTextIf = (id, value) => {
          const el = document.getElementById(id);
          if (el) el.textContent = value;
        };

        setTextIf('display-ak', '-');
        setTextIf('display-rk', '-');
        setTextIf('display-bk', '-');
        setTextIf('display-bilag', '-');

        // Legacy nodes (may not exist)
        setTextIf('result-anvendelse-3', '-');
        setTextIf('result-anvendelse-desc-3', '');
        setTextIf('result-risiko-3', '-');
        setTextIf('result-risiko-desc-3', '');
        setTextIf('result-brand-3', '-');
        setTextIf('result-brand-desc-3', '');

        const container = document.getElementById('requirements-container');
        if (container) {
          container.innerHTML = `
            <div style="text-align: center; padding: 48px; color: #999;">
              <div style="font-size: 48px; margin-bottom: 16px;">ðŸ“‹</div>
              <div>Krav vises nÃ¥r brandklassen er bestemt</div>
            </div>
          `;
        }
        return;
      }
      const ak = latestEvaluation.anvendelseskategori?.value ?? '-';
      const rk = latestEvaluation.risikoklasse?.value ?? '-';
      const bk = latestEvaluation.brandklasse?.value ?? '-';
      const bilag = getBilagValueFromEvaluation(latestEvaluation) || '-';

      const setTextIf = (id, value) => {
        const el = document.getElementById(id);
        if (el) el.textContent = value;
      };

      setTextIf('display-ak', ak);
      setTextIf('display-rk', rk);
      setTextIf('display-bk', bk);
      setTextIf('display-bilag', bilag);

      // Legacy nodes (may not exist if Step 3 right panel changes)
      setTextIf('result-anvendelse-3', ak);
      setTextIf('result-anvendelse-desc-3', latestEvaluation.anvendelseskategori?.description ?? '');
      setTextIf('result-risiko-3', rk);
      setTextIf('result-risiko-desc-3', latestEvaluation.risikoklasse?.description ?? '');
      setTextIf('result-brand-3', bk);
      setTextIf('result-brand-desc-3', latestEvaluation.brandklasse?.description ?? '');

      await generateRequirements(bilag, bk, latestEvaluation);
    }

    async function loadBilagTemplate(bilag) {
      const container = document.getElementById('bilag-template-container');
      if (!container) return;
      if (!bilag || bilag === '-') {
        container.textContent = 'Relevant bilag er ikke bestemt endnu. GÃ¥ tilbage og udfyld grunddata.';
        return;
      }
      try {
        const resp = await fetch(`${API_BASE}/bilag/${bilag}.html`, { cache: 'no-store' });
        if (!resp.ok) throw new Error('bilag template not found');
        const html = await resp.text();
        container.innerHTML = html;
        try { bindBilagTemplate(container, String(bilag)); } catch(_) {}
      } catch (e) {
        container.innerHTML = `<div class="muted">Ingen skabelon fundet for bilag ${bilag}. Opret en fil <code>frontend/bilag/${bilag}.html</code>.</div>`;
      }
    }

    function inferBilag1BranchFromBygningstype(){
      const raw = (document.getElementById('fld_bygningstype')?.value || '').toLowerCase();
      // Simple heuristic: treat common multi-unit types as rÃ¦kkehus, else default to enfamiliehus.
      if (raw.includes('rÃ¦kke') || raw.includes('raekke') || raw.includes('kÃ¦de') || raw.includes('kaede') || raw.includes('dobbel') || raw.includes('gruppe')) return 'raekkehus';
      return 'enfamiliehus';
    }

    function bindBilagTemplate(container, bilagId){
      // 1) Bind bilag inputs into per-section bilagExtras state
      const inputs = Array.from(container.querySelectorAll('[data-bilag-key]'));
      inputs.forEach(el => {
        const key = el.getAttribute('data-bilag-key');
        if (!key) return;

        // Prefill from existing extras (if any)
        const existing = getActiveBilagExtras()[key];
        if (existing !== undefined) {
          if (el.tagName === 'SELECT') el.value = String(!!existing);
          else if (el.type === 'checkbox') el.checked = !!existing;
          else el.value = String(existing);
        }

        const onChange = ()=>{
          let value;
          if (el.tagName === 'SELECT') value = (String(el.value) === 'true');
          else if (el.type === 'checkbox') value = !!el.checked;
          else value = el.value;
          setActiveBilagExtra(key, value);
          // If the user isn't editing JSON manually, keep JSON pane in sync
          try {
            if (!syncingFromJson && !jsonManualEdit) {
              const merged = { ...canonicalizeInputData(buildJsonFromForm()), ...getActiveBilagExtras() };
              jsonTextarea.value = JSON.stringify(merged, null, 2);
            }
          } catch(_) {}
        };
        el.addEventListener('change', onChange);
        el.addEventListener('input', onChange);
      });

      // 2) Bilag 1: simple â€œone question at a timeâ€ flow with automatic branching
      if (String(bilagId) !== '1') return;
      const branch = inferBilag1BranchFromBygningstype();

      // Hide all questions not matching the branch (if branch-specific)
      const questions = Array.from(container.querySelectorAll('.bilag-question'));
      const filtered = questions.filter(q => {
        const only = q.getAttribute('data-only');
        if (!only) return true;
        return only === branch;
      });
      questions.forEach(q => q.style.display = 'none');

      let step = 0;
      const showStep = (n)=>{
        step = Math.max(0, Math.min(n, filtered.length - 1));
        filtered.forEach((q, i)=>{ q.style.display = (i === step) ? '' : 'none'; });
        const btnPrev = container.querySelector('[data-bilag-nav="prev"]');
        const btnNext = container.querySelector('[data-bilag-nav="next"]');
        if (btnPrev) btnPrev.disabled = (step === 0);
        if (btnNext) btnNext.disabled = (step >= filtered.length - 1);
        const prog = container.querySelector('[data-bilag-progress]');
        if (prog) prog.textContent = `${step + 1}/${Math.max(filtered.length, 1)}`;
      };

      const btnPrev = container.querySelector('[data-bilag-nav="prev"]');
      const btnNext = container.querySelector('[data-bilag-nav="next"]');
      if (btnPrev) btnPrev.addEventListener('click', ()=> showStep(step - 1));
      if (btnNext) btnNext.addEventListener('click', ()=> showStep(step + 1));
      showStep(0);
    }
    
    async function generateRequirements(bilag, brandklasse, evaluation) {
      const container = document.getElementById('requirements-container');
      if (!container) return;
      const activeSectionIdx = getActiveSectionIndex();

      // Ensure bilag is always a plain string/number token (never an object)
      try {
        if (bilag && typeof bilag === 'object') {
          bilag = getBilagValueFromEvaluation({ relevant_bilag: bilag }) || '-';
        }
        bilag = (bilag === null || bilag === undefined) ? '-' : String(bilag).trim();
      } catch (_) {}
      
      if (!bilag || bilag === '-' || !brandklasse || brandklasse === '-') {
        container.innerHTML = `
          <div style="text-align: center; padding: 48px; color: #999;">
            <div style="font-size: 48px; margin-bottom: 16px;">ðŸ“‹</div>
            <div>Krav vises nÃ¥r brandklassen er bestemt</div>
          </div>
        `;
        return;
      }
      
      // Call backend API to get requirements (Krav)
      try {
        // Build input data from current form/JSON
        const inputData = { ...canonicalizeInputData(buildJsonFromForm()), ...getActiveBilagExtras() };
        inputData.Relevant_bilag = bilag;
        inputData.brandklasse = brandklasse;
        
        const response = await fetch(`${API_BASE}/evaluate-krav`, {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify(inputData)
        });
        
        if (!response.ok) {
          throw new Error('API request failed');
        }
        
        const result = await response.json();
        
        if (!result.success || !result.krav || result.krav.length === 0) {
          container.innerHTML = `
            <div style="text-align: center; padding: 48px; color: #999;">
              <div style="font-size: 48px; margin-bottom: 16px;">ðŸ“‹</div>
              <div>Ingen matchende krav fundet for Bilag ${bilag} - Brandklasse ${brandklasse}</div>
              ${result.error ? `<div style="margin-top: 12px; color: #e74c3c;">${result.error}</div>` : ''}
            </div>
          `;
          return;
        }
        
        const requirements = Array.isArray(result.krav) ? result.krav : [];

        // Persist the exact matched krav rows for validation overview (per section + latestEvaluation)
        try {
          const idx = getActiveSectionIndex();
          sectionsState.kravResults = sectionsState.kravResults || [];
          sectionsState.kravResults[idx] = requirements;
          latestEvaluation = latestEvaluation || {};
          latestEvaluation.krav = requirements;
        } catch (_) {}

        // -------------------------
        // Helpers
        // -------------------------
        const decodeGorulesString = (value) => {
          if (value === null || value === undefined) return '';
          let s = String(value);

          // GoRules often stores strings with extra surrounding quotes, e.g. "\n\n-foo".
          s = s.trim();
          if (s.length >= 2 && s.startsWith('"') && s.endsWith('"')) {
            s = s.slice(1, -1);
          }

          // Decode common double-escaped sequences (when the model contains "\\n" literally)
          s = s
            .replace(/\\r\\n/g, '\n')
            .replace(/\\n/g, '\n')
            .replace(/\\r/g, '\n')
            .replace(/\\t/g, '\t')
            .replace(/\\"/g, '"')
            .replace(/\\\\/g, '\\');

          return s;
        };

        const norm = (v) => decodeGorulesString(v).trim();

        const multilineHtml = (raw) => {
          const s = norm(raw);
          if (!s) return '';
          // Escape, then convert newlines to <br> (double newline becomes blank line)
          return escapeHtml(s)
            .replace(/\r\n/g, '\n')
            .replace(/\n\n+/g, '<br><br>')
            .replace(/\n/g, '<br>');
        };
        const parseRefs = (raw) => {
          const s = norm(raw);
          if (!s) return [];
          return s
            .replace(/\s+og\s+/gi, ',')
            .replace(/\s+and\s+/gi, ',')
            .replace(/\s*&\s*/g, ',')
            .split(/[,;\n]/g)
            .map(x => x.trim())
            .filter(Boolean);
        };
        const parseChecklistItems = (raw) => {
          const s = norm(raw);
          if (!s) return [];
          const text = s.replace(/\r\n/g, '\n');

          // First try: double-newline delimiter (\n\n)
          if (/\n\s*\n/.test(text)) {
            return text
              .split(/\n\s*\n/)
              .map(x => x.trim())
              .filter(Boolean);
          }

          // Fallback: Bullet-per-line with dash
          if (/\n\s*-\s+/.test(text)) {
            return text
              .split(/\n+/)
              .map(l => l.trim())
              .filter(Boolean)
              .map(l => l.replace(/^\s*-\s*/, '').trim())
              .filter(Boolean);
          }

          // Single item (but also split on explicit " - " if user wrote multiple in one line)
          const one = text.trim();
          if (!one) return [];
          if (/\s-\s/.test(one) && !/^\s*-\s/.test(one)) {
            const parts = one.split(/\s-\s/).map(x => x.trim()).filter(Boolean);
            return parts.length ? parts : [one];
          }
          return [one];
        };

        // -------------------------
        // Viewer (right panel)
        // -------------------------
        window.__kravViewerState = window.__kravViewerState || { open: false, kind: null, refs: [], index: 0, source: null };
        const viewerState = window.__kravViewerState;
        const viewerTitleEl = document.getElementById('krav-viewer-title');
        const viewerBodyEl = document.getElementById('krav-viewer-body');
        const viewerSlotsEl = document.getElementById('krav-viewer-slots');
        const viewerPlaceholderEl = document.getElementById('krav-viewer-placeholder');
        const viewerCarouselEl = document.getElementById('krav-viewer-carousel');
        const viewerPrevEl = document.getElementById('krav-viewer-prev');
        const viewerNextEl = document.getElementById('krav-viewer-next');
        const viewerImgEl = document.getElementById('krav-viewer-img');
        const viewerRefEl = document.getElementById('krav-viewer-ref');
        const viewerCountEl = document.getElementById('krav-viewer-count');
        const viewerCaptionEl = document.getElementById('krav-viewer-caption');
        const viewerMissingEl = document.getElementById('krav-viewer-missing');

        const setViewerOpen = (open) => {
          viewerState.open = !!open;
          if (viewerBodyEl) viewerBodyEl.classList.toggle('open', viewerState.open);
          const btnMin = document.getElementById('krav-viewer-minimize');
          if (btnMin) btnMin.textContent = viewerState.open ? 'MinimÃ©r' : 'Vis';
        };

        // New asset structure: assets/<bilag-folder>/{figures,tables}/...
        // We map bilag "1" -> "bilag1" and bilag "1.1" -> "bilag11".
        const bilagFolder = (()=>{
          const b = normalizeBilagId(bilag);
          if (!b) return '';
          const digits = b.replace(/\D/g, '');
          return digits ? `bilag${digits}` : '';
        })();

        const buildAssetCandidates = (ref, kind) => {
          const r = String(ref || '').trim();
          if (!r) return [];
          const looksLikePath = r.includes('/') || r.includes('\\');
          const hasExt = /\.(png|jpg|jpeg|svg|webp|gif)$/i.test(r);
          if (looksLikePath) {
            const cleaned = r.replace(/\\/g, '/').replace(/^\/+/, '');
            return [`${API_BASE}/assets/${cleaned}`];
          }
          if (hasExt) return [`${API_BASE}/assets/${r.replace(/^\/+/, '')}`];

          const exts = ['png','jpg','jpeg','svg','webp'];
          const bilagBases = bilagFolder
            ? ((kind === 'table')
                ? [`${API_BASE}/assets/${bilagFolder}/tables/${r}`, `${API_BASE}/assets/${bilagFolder}/figures/${r}`]
                : [`${API_BASE}/assets/${bilagFolder}/figures/${r}`])
            : [];

          // Fallback to legacy global folders for backwards compatibility
          const legacyBases = (kind === 'table')
            ? [`${API_BASE}/assets/tables/${r}`, `${API_BASE}/assets/figures/${r}`, `${API_BASE}/assets/${r}`]
            : [`${API_BASE}/assets/figures/${r}`, `${API_BASE}/assets/${r}`];

          const bases = [...bilagBases, ...legacyBases];
          const out = [];
          for (const b of bases) for (const e of exts) out.push(`${b}.${e}`);
          return out;
        };

        async function loadFigureCaptions(){
          window.__figureCaptionsCache = window.__figureCaptionsCache || { loaded: new Set(), dataByUrl: {} };
          const cache = window.__figureCaptionsCache;

          const urls = [];
          if (bilagFolder) urls.push(`${API_BASE}/assets/${bilagFolder}/figures/captions.json`);
          urls.push(`${API_BASE}/assets/figures/captions.json`);

          for (const url of urls) {
            if (cache.loaded.has(url)) {
              const existing = cache.dataByUrl[url];
              if (existing) return existing;
              continue;
            }
            cache.loaded.add(url);
            try {
              const resp = await fetch(url, { cache: 'no-store' });
              if (!resp.ok) { cache.dataByUrl[url] = null; continue; }
              const data = await resp.json();
              cache.dataByUrl[url] = data || {};
              return cache.dataByUrl[url] || {};
            } catch(_) {
              cache.dataByUrl[url] = null;
            }
          }
          return {};
        }

        async function renderViewer(){
          if (!viewerTitleEl || !viewerBodyEl) return;
          viewerTitleEl.textContent = 'RELEVANTE FIGURER / TABELLER';

          // Legacy single-carousel viewer is disabled; we render per-button anchored slots instead.
          if (viewerCarouselEl) viewerCarouselEl.style.display = 'none';

          const hasSlots = !!(viewerSlotsEl && viewerSlotsEl.querySelector('.krav-slot'));
          if (viewerPlaceholderEl) viewerPlaceholderEl.style.display = (viewerState.open && hasSlots) ? 'none' : '';
        }

        if (!window.__kravViewerBound) {
          window.__kravViewerBound = true;
          const btnMin = document.getElementById('krav-viewer-minimize');
          if (btnMin) btnMin.addEventListener('click', ()=>{ setViewerOpen(!viewerState.open); renderViewer(); });
          if (viewerPrevEl) viewerPrevEl.addEventListener('click', ()=>{ viewerState.index = Math.max(0, viewerState.index - 1); renderViewer(); });
          if (viewerNextEl) viewerNextEl.addEventListener('click', ()=>{ viewerState.index = Math.min(Math.max(viewerState.refs.length - 1, 0), viewerState.index + 1); renderViewer(); });
        }

        // Keep viewer minimized until the user asks to see figures/tables
        setViewerOpen(viewerState.open);
        await renderViewer();

        // -------------------------
        // Checklist completion state (persist per section)
        // -------------------------
        sectionsState.kravChecks = sectionsState.kravChecks || [];
        const sectionIdx = getActiveSectionIndex();
        sectionsState.kravChecks[sectionIdx] = sectionsState.kravChecks[sectionIdx] || {};
        const checkState = sectionsState.kravChecks[sectionIdx];
        const makeCheckKey = (kravId, text) => `${String(kravId || '').trim()}::${String(text || '').trim()}`;

        // -------------------------
        // Preserve original row order (do NOT collapse on Krav_id)
        // -------------------------
        const rows = requirements.map((r, i) => {
          const kravId = norm(r?.Krav_id) || `__row_${i}`;
          const title = norm(r?.Krav_Titel) || 'Krav';
          const undertitle = norm(r?.Krav_Undertitel);
          const underundertitle = norm(r?.Krav_UnderUndertitel);
          const minititle = norm(r?.Krav_MiniTitel);
          const paragrafTitle = norm(r?.Krav_Paragraf_Titel);
          const paragrafUnderTitle = norm(r?.Krav_Paragraf_UnderTitel);
          const paragrafUnderUnderTitle = norm(
            r?.Krav_ParagrafUnderUnderTitel ??
            r?.Krav_Paragraf_UnderUnderTitel ??
            r?.Krav_Paragraf_UnderUndertitel
          );
          const beskrivelse = norm(r?.Krav_Beskrivelse);
          const dim = norm(r?.Krav_Korrekt_Dimensionering);
          const bullets = parseChecklistItems(norm(r?.Krav_Tjekliste));
          const figures = parseRefs(r?.Krav_Figurer);
          const tables = parseRefs(r?.Krav_Tabel || r?.Krav_Tabeller);
          return {
            kravId,
            title,
            undertitle,
            underundertitle,
            minititle,
            paragrafTitle,
            paragrafUnderTitle,
            paragrafUnderUnderTitle,
            beskrivelse,
            dim,
            bullets,
            figures,
            tables,
          };
        });

        const byTitle = new Map();
        const titleOrder = [];
        for (const row of rows) {
          const t = row.title || 'Krav';
          if (!byTitle.has(t)) { byTitle.set(t, []); titleOrder.push(t); }
          byTitle.get(t).push(row);
        }

        // Persist Krav-page category order so trin 4 (bilag) and exports match
        try {
          const idx = getActiveSectionIndex();
          sectionsState.kravCategoryOrder = sectionsState.kravCategoryOrder && typeof sectionsState.kravCategoryOrder === 'object'
            ? sectionsState.kravCategoryOrder
            : {};
          sectionsState.kravCategoryOrder[String(idx)] = titleOrder.slice();
        } catch (_) {}

        // -------------------------
        // Render
        // -------------------------
        container.innerHTML = '';
        const frag = document.createDocumentFragment();

        const createParaIcon = (text) => {
          const s = norm(text);
          if (!s) return null;
          const span = document.createElement('span');
          span.className = 'info-icon para-icon';
          span.textContent = 'Â§';
          span.setAttribute('data-tip', s);
          span.setAttribute('tabindex', '0');
          return span;
        };

        const makeSegmentActionsRow = () => {
          const row = document.createElement('div');
          row.className = 'krav-segment-actions';
          return row;
        };

        // -------------------------
        // Right-panel anchored viewers (one slot per "Se figur" / "Se tabel" button)
        // -------------------------
        window.__kravInlineViewers = window.__kravInlineViewers || new Map();

        const closeInlineViewer = (key) => {
          const v = window.__kravInlineViewers.get(key);
          if (v?.slotEl && v.slotEl.parentNode) v.slotEl.parentNode.removeChild(v.slotEl);
          window.__kravInlineViewers.delete(key);
          renderViewer();
        };

        const closeAllInlineViewers = () => {
          try {
            for (const key of Array.from(window.__kravInlineViewers.keys())) closeInlineViewer(key);
          } catch(_) {}
        };

        // Requirements rerender destroys old buttons; close any old slots.
        closeAllInlineViewers();

        const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
        const rangesOverlap = (aTop, aH, bTop, bH) => (aTop < (bTop + bH)) && (bTop < (aTop + aH));

        const ensureSlotsHeight = () => {
          if (!viewerSlotsEl) return;
          try {
            const reqH = container?.getBoundingClientRect?.().height;
            if (reqH && isFinite(reqH)) viewerSlotsEl.style.minHeight = `${Math.max(140, Math.ceil(reqH))}px`;
          } catch(_) {}
        };

        const computeSlotTop = (anchorEl) => {
          if (!viewerSlotsEl || !anchorEl) return 0;
          const anchorDocTop = anchorEl.getBoundingClientRect().top + window.scrollY;
          const slotsDocTop = viewerSlotsEl.getBoundingClientRect().top + window.scrollY;
          return Math.max(0, anchorDocTop - slotsDocTop);
        };

        const layoutInlineViewers = () => {
          if (!viewerSlotsEl) return;
          ensureSlotsHeight();

          const slotsH = viewerSlotsEl.getBoundingClientRect().height;
          for (const v of window.__kravInlineViewers.values()) {
            if (!v?.slotEl || !v.anchorEl) continue;
            const desired = computeSlotTop(v.anchorEl);
            const h = v.slotEl.offsetHeight || 220;
            const top = clamp(desired, 0, Math.max(0, Math.floor(slotsH - h)));
            v.top = top;
            v.slotEl.style.top = `${top}px`;
          }

          // If two slots overlap, close the older one.
          const viewers = Array.from(window.__kravInlineViewers.values())
            .filter(v => v?.slotEl)
            .sort((a,b)=> (a.openedAt || 0) - (b.openedAt || 0));

          for (let i = 0; i < viewers.length; i++) {
            const a = viewers[i];
            if (!a?.slotEl) continue;
            const aTop = a.top || 0;
            const aH = a.slotEl.offsetHeight || 220;
            for (let j = i + 1; j < viewers.length; j++) {
              const b = viewers[j];
              if (!b?.slotEl) continue;
              const bTop = b.top || 0;
              const bH = b.slotEl.offsetHeight || 220;
              if (rangesOverlap(aTop, aH, bTop, bH)) {
                closeInlineViewer(a.key);
                break;
              }
            }
          }

          // Update placeholder visibility
          renderViewer();
        };

        // -------------------------
        // Expanded / fullscreen lightbox viewer
        // -------------------------
        window.__kravLightbox = window.__kravLightbox || { open: false, kind: null, refs: [], index: 0 };
        const lbState = window.__kravLightbox;
        const lbOverlayEl = document.getElementById('image-lightbox');
        const lbImgEl = document.getElementById('lightbox-img');
        const lbPrevEl = document.getElementById('lightbox-prev');
        const lbNextEl = document.getElementById('lightbox-next');
        const lbCloseEl = document.getElementById('lightbox-close');
        const lbCountEl = document.getElementById('lightbox-count');
        const lbCaptionEl = document.getElementById('lightbox-caption');
        const lbMissingEl = document.getElementById('lightbox-missing');

        const setLightboxOpen = (open) => {
          lbState.open = !!open;
          if (!lbOverlayEl) return;
          lbOverlayEl.classList.toggle('open', lbState.open);
          lbOverlayEl.setAttribute('aria-hidden', lbState.open ? 'false' : 'true');
          if (!lbState.open && lbImgEl) lbImgEl.removeAttribute('src');
        };

        const renderLightbox = async () => {
          if (!lbOverlayEl || !lbImgEl) return;
          const kind = lbState.kind;
          const refs = Array.isArray(lbState.refs) ? lbState.refs : [];
          lbState.index = Math.max(0, Math.min(lbState.index, Math.max(refs.length - 1, 0)));
          const ref = refs[lbState.index] || '';

          if (lbCountEl) lbCountEl.textContent = refs.length > 1 ? `${lbState.index + 1}/${refs.length}` : '';
          if (lbPrevEl) lbPrevEl.disabled = (lbState.index <= 0);
          if (lbNextEl) lbNextEl.disabled = (lbState.index >= refs.length - 1);
          if (lbMissingEl) { lbMissingEl.style.display = 'none'; lbMissingEl.textContent = ''; }

          if (lbCaptionEl) {
            if (kind !== 'figure') {
              lbCaptionEl.style.display = 'none';
              lbCaptionEl.textContent = '';
            } else {
              const captions = await loadFigureCaptions();
              const cap = captions && captions[String(ref)] ? String(captions[String(ref)]) : '';
              if (cap.trim()) { lbCaptionEl.style.display = ''; lbCaptionEl.textContent = cap; }
              else { lbCaptionEl.style.display = 'none'; lbCaptionEl.textContent = ''; }
            }
          }

          const candidates = buildAssetCandidates(ref, kind);
          let candidateIndex = 0;
          const tryNext = ()=>{
            candidateIndex++;
            if (candidateIndex >= candidates.length) {
              lbImgEl.removeAttribute('src');
              if (lbMissingEl) {
                lbMissingEl.style.display = '';
                lbMissingEl.textContent = `Kunne ikke finde fil for "${ref}".`;
              }
              return;
            }
            lbImgEl.src = candidates[candidateIndex];
          };

          lbImgEl.onerror = tryNext;
          lbImgEl.onload = ()=>{ if (lbMissingEl) lbMissingEl.style.display = 'none'; };
          if (candidates.length) lbImgEl.src = candidates[0];
          else {
            lbImgEl.removeAttribute('src');
            if (lbMissingEl) { lbMissingEl.style.display = ''; lbMissingEl.textContent = 'Ingen reference angivet.'; }
          }
        };

        if (!window.__kravLightboxBound) {
          window.__kravLightboxBound = true;
          if (lbCloseEl) lbCloseEl.addEventListener('click', ()=> setLightboxOpen(false));
          if (lbOverlayEl) lbOverlayEl.addEventListener('click', (e)=>{
            if (e.target === lbOverlayEl) setLightboxOpen(false);
          });
          window.addEventListener('keydown', (e)=>{
            if (!lbState.open) return;
            if (e.key === 'Escape') setLightboxOpen(false);
            if (e.key === 'ArrowLeft') { lbState.index = Math.max(0, lbState.index - 1); renderLightbox(); }
            if (e.key === 'ArrowRight') { lbState.index = Math.min(Math.max(lbState.refs.length - 1, 0), lbState.index + 1); renderLightbox(); }
          });
          if (lbPrevEl) lbPrevEl.addEventListener('click', ()=>{ lbState.index = Math.max(0, lbState.index - 1); renderLightbox(); });
          if (lbNextEl) lbNextEl.addEventListener('click', ()=>{ lbState.index = Math.min(Math.max(lbState.refs.length - 1, 0), lbState.index + 1); renderLightbox(); });
        }

        const openLightboxFor = async (viewer) => {
          lbState.kind = viewer?.kind || 'figure';
          lbState.refs = Array.from(new Set((viewer?.refs || []).map(x => String(x).trim()).filter(Boolean)));
          lbState.index = Math.max(0, Math.min(viewer?.index || 0, Math.max(lbState.refs.length - 1, 0)));
          setLightboxOpen(true);
          await renderLightbox();
        };

        const renderInlineViewer = async (viewer) => {
          if (!viewer?.slotEl) return;
          const slotEl = viewer.slotEl;

          const imgEl = slotEl.querySelector('[data-kvs-img]');
          const countEl = slotEl.querySelector('[data-kvs-count]');
          const captionEl = slotEl.querySelector('[data-kvs-caption]');
          const missingEl = slotEl.querySelector('[data-kvs-missing]');
          const btnPrev = slotEl.querySelector('[data-kvs-prev]');
          const btnNext = slotEl.querySelector('[data-kvs-next]');
          const btnExpand = slotEl.querySelector('[data-kvs-expand]');

          const kind = viewer.kind;
          viewer.index = Math.max(0, Math.min(viewer.index, Math.max((viewer.refs.length - 1), 0)));
          const ref = viewer.refs[viewer.index] || '';

          if (countEl) countEl.textContent = viewer.refs.length > 1 ? `${viewer.index + 1}/${viewer.refs.length}` : '';
          if (btnPrev) btnPrev.disabled = (viewer.index <= 0);
          if (btnNext) btnNext.disabled = (viewer.index >= viewer.refs.length - 1);
          if (missingEl) { missingEl.style.display = 'none'; missingEl.textContent = ''; }

          // Captions only for figures
          if (captionEl) {
            if (kind !== 'figure') {
              captionEl.style.display = 'none';
              captionEl.textContent = '';
            } else {
              const captions = await loadFigureCaptions();
              const cap = captions && captions[String(ref)] ? String(captions[String(ref)]) : '';
              if (cap.trim()) { captionEl.style.display = ''; captionEl.textContent = cap; }
              else { captionEl.style.display = 'none'; captionEl.textContent = ''; }
            }
          }

          const candidates = buildAssetCandidates(ref, kind);
          let candidateIndex = 0;
          const tryNext = ()=>{
            candidateIndex++;
            if (candidateIndex >= candidates.length) {
              if (imgEl) imgEl.removeAttribute('src');
              if (missingEl) {
                missingEl.style.display = '';
                missingEl.textContent = `Kunne ikke finde fil for "${ref}".\nForventede fx: ${candidates.slice(0, 4).join(', ')}${candidates.length > 4 ? 'â€¦' : ''}`;
              }
              setTimeout(layoutInlineViewers, 0);
              return;
            }
            if (imgEl) imgEl.src = candidates[candidateIndex];
          };

          if (imgEl) {
            imgEl.onerror = tryNext;
            imgEl.onload = ()=>{ if (missingEl) missingEl.style.display = 'none'; setTimeout(layoutInlineViewers, 0); };
            if (candidates.length) imgEl.src = candidates[0];
            else {
              imgEl.removeAttribute('src');
              if (missingEl) { missingEl.style.display = ''; missingEl.textContent = `Ingen reference angivet.`; }
              setTimeout(layoutInlineViewers, 0);
            }
          }

          if (btnExpand) {
            btnExpand.onclick = ()=>{ openLightboxFor(viewer); };
          }
        };

        const openInlineViewer = async ({ kind, refs, source, anchorEl }) => {
          if (!viewerSlotsEl) return;
          const key = `${String(kind)}::${String(source || '')}`;
          const existing = window.__kravInlineViewers.get(key);
          if (existing && existing.slotEl && viewerSlotsEl.contains(existing.slotEl)) {
            closeInlineViewer(key);
            return;
          }

          setViewerOpen(true);
          ensureSlotsHeight();

          const slot = document.createElement('div');
          slot.className = 'krav-slot';
          slot.innerHTML = `
            <div class="krav-slot-actions">
              <button class="krav-slot-expand" type="button" aria-label="Udvid" data-kvs-expand>â¤¢</button>
              <button class="krav-slot-close" type="button" aria-label="Luk">Ã—</button>
            </div>
            <div class="krav-carousel">
              <button class="figure-nav-btn" type="button" aria-label="Forrige" data-kvs-prev>â€¹</button>
              <div class="krav-stage">
                <div class="krav-frame">
                  <img data-kvs-img alt="" />
                </div>
                <div class="krav-viewer-meta">
                  <div>
                    <span class="count" data-kvs-count></span>
                  </div>
                  <div class="krav-viewer-caption" data-kvs-caption style="display:none;"></div>
                  <div class="krav-viewer-missing" data-kvs-missing style="display:none;"></div>
                </div>
              </div>
              <button class="figure-nav-btn" type="button" aria-label="NÃ¦ste" data-kvs-next>â€º</button>
            </div>
          `;
          viewerSlotsEl.appendChild(slot);

          const viewer = {
            key,
            kind,
            refs: Array.from(new Set((refs || []).map(x => String(x).trim()).filter(Boolean))),
            index: 0,
            source: source || null,
            anchorEl,
            slotEl: slot,
            openedAt: Date.now(),
            top: 0,
          };
          window.__kravInlineViewers.set(key, viewer);

          const btnPrev = slot.querySelector('[data-kvs-prev]');
          const btnNext = slot.querySelector('[data-kvs-next]');
          const btnClose = slot.querySelector('.krav-slot-close');
          if (btnPrev) btnPrev.addEventListener('click', ()=>{ viewer.index = Math.max(0, viewer.index - 1); renderInlineViewer(viewer); });
          if (btnNext) btnNext.addEventListener('click', ()=>{ viewer.index = Math.min(Math.max(viewer.refs.length - 1, 0), viewer.index + 1); renderInlineViewer(viewer); });
          if (btnClose) btnClose.addEventListener('click', ()=> closeInlineViewer(key));

          // Initial position & render
          viewer.top = computeSlotTop(anchorEl);
          slot.style.top = `${viewer.top}px`;
          await renderInlineViewer(viewer);
          layoutInlineViewers();
        };

        const createViewerButton = (kind, refs, source, anchorEl) => {
          const items = Array.from(new Set((refs || []).map(x => String(x).trim()).filter(Boolean)));
          if (!items.length) return null;
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'krav-pill';
          const label = (kind === 'table')
            ? (items.length === 1 ? 'Se tabel' : 'Se tabeller')
            : (items.length === 1 ? 'Se figur' : 'Se figurer');
          btn.textContent = label;
          btn.addEventListener('click', ()=>{ openInlineViewer({ kind, refs: items, source: source || null, anchorEl: anchorEl || btn }); });
          return btn;
        };

        for (const title of titleOrder) {
          const titleRows = byTitle.get(title) || [];

          const block = document.createElement('div');
          block.className = 'krav-title-block';

          const header = document.createElement('div');
          header.className = 'krav-title-header';
          const left = document.createElement('div');
          left.className = 'krav-title-left';
          const titleEl = document.createElement('div');
          titleEl.className = 'krav-title';
          titleEl.textContent = title;
          const titlePara = titleRows.map(r => r.paragrafTitle).find(x => norm(x));
          const titleParaIcon = createParaIcon(titlePara);
          if (titleParaIcon) titleEl.appendChild(titleParaIcon);
          left.appendChild(titleEl);
          header.appendChild(left);
          
          // Add "Check All" button to title header
          const titleActions = document.createElement('div');
          titleActions.className = 'krav-heading-actions';
          const checkAllTitleBtn = document.createElement('button');
          checkAllTitleBtn.type = 'button';
          checkAllTitleBtn.className = 'krav-check-all-btn';
          checkAllTitleBtn.textContent = 'âœ“ Tjek alle';
          checkAllTitleBtn.setAttribute('data-title-checkall', title);
          titleActions.appendChild(checkAllTitleBtn);
          header.appendChild(titleActions);
          
          block.appendChild(header);

          const body = document.createElement('div');
          body.className = 'krav-block-body';

          // -------------------------
          // Step 3: Upload documentation per krav-gruppe (title)
          // -------------------------
          const docsCategoryLabel = String(title || '').trim();
          const docsFileInput = document.createElement('input');
          docsFileInput.type = 'file';
          docsFileInput.multiple = true;
          docsFileInput.style.display = 'none';

          const docsHeaderBtn = document.createElement('button');
          docsHeaderBtn.type = 'button';
          docsHeaderBtn.className = 'btn-secondary';
          docsHeaderBtn.style.padding = '8px 12px';
          docsHeaderBtn.textContent = 'TilfÃ¸j bilag';
          docsHeaderBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            try { docsFileInput.click(); } catch(_) {}
          });

          // Put docs controls into the title header actions (visible even when user hasn't expanded anything)
          try {
            titleActions.appendChild(docsHeaderBtn);
          } catch(_) {}

          const docsBlock = document.createElement('div');
          docsBlock.className = 'cat-docs';
          docsBlock.setAttribute('data-category-label', docsCategoryLabel);

          const docsBlockHeader = document.createElement('div');
          docsBlockHeader.className = 'cat-docs-header';

          const docsHeaderText = document.createElement('div');
          const docsTitle = document.createElement('div');
          docsTitle.className = 'cat-docs-title';
          docsTitle.textContent = 'Dokumentation til denne kravgruppe';
          const docsSub = document.createElement('div');
          docsSub.className = 'cat-docs-sub';
          docsSub.textContent = 'TilfÃ¸j relevante bilag, samt billedtekst og evt. en kort forklaring. Det kommer med i dokumentationen i trin 4.';
          docsHeaderText.appendChild(docsTitle);
          docsHeaderText.appendChild(docsSub);

          docsBlockHeader.appendChild(docsHeaderText);

          const docsList = document.createElement('div');
          docsList.className = 'cat-docs-list';

          const renderDocs = () => {
            const docs = getKravCategoryDocs(activeSectionIdx, docsCategoryLabel);
            const n = Array.isArray(docs) ? docs.length : 0;
            docsList.innerHTML = '';
            if (!n) {
              const empty = document.createElement('div');
              empty.className = 'cat-doc-empty';
              empty.textContent = 'Ingen dokumentation tilfÃ¸jet til denne kravgruppe endnu.';
              docsList.appendChild(empty);
              return;
            }

            for (const d of docs) {
              const item = document.createElement('div');
              item.className = 'cat-doc-item';
              item.setAttribute('data-doc-id', String(d?.id || ''));

              const top = document.createElement('div');
              top.className = 'cat-doc-item-top';

              const nameEl = document.createElement('div');
              nameEl.className = 'cat-doc-name';
              nameEl.textContent = String(d?.name || 'fil');

              const rmBtn = document.createElement('button');
              rmBtn.type = 'button';
              rmBtn.className = 'btn-secondary';
              rmBtn.style.padding = '6px 10px';
              rmBtn.textContent = 'Fjern';
              rmBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                removeKravCategoryDoc(activeSectionIdx, docsCategoryLabel, String(d?.id || ''));
                renderDocs();
              });

              top.appendChild(nameEl);
              top.appendChild(rmBtn);

              const fields = document.createElement('div');
              fields.className = 'cat-doc-fields';

              const capLabel = document.createElement('label');
              capLabel.className = 'cat-doc-field';
              const capLbl = document.createElement('div');
              capLbl.className = 'cat-doc-field-label';
              capLbl.textContent = 'Billedtekst';
              const capInput = document.createElement('input');
              capInput.type = 'text';
              capInput.className = 'cat-doc-input';
              capInput.placeholder = 'fx Figur 1: Placering af brandvÃ¦g';
              capInput.value = String(d?.caption || '');
              capInput.addEventListener('input', () => {
                updateKravCategoryDocField(activeSectionIdx, docsCategoryLabel, String(d?.id || ''), 'caption', capInput.value);
              });
              capLabel.appendChild(capLbl);
              capLabel.appendChild(capInput);

              const descLabel = document.createElement('label');
              descLabel.className = 'cat-doc-field';
              const descLbl = document.createElement('div');
              descLbl.className = 'cat-doc-field-label';
              descLbl.textContent = 'Kort forklaring (valgfri)';
              const descArea = document.createElement('textarea');
              descArea.className = 'cat-doc-textarea';
              descArea.rows = 2;
              descArea.placeholder = 'Hvad viser dokumentet/figuren â€“ og hvorfor er det relevant?';
              descArea.value = String(d?.description || '');
              descArea.addEventListener('input', () => {
                updateKravCategoryDocField(activeSectionIdx, docsCategoryLabel, String(d?.id || ''), 'description', descArea.value);
              });
              descLabel.appendChild(descLbl);
              descLabel.appendChild(descArea);

              fields.appendChild(capLabel);
              fields.appendChild(descLabel);

              item.appendChild(top);
              item.appendChild(fields);
              docsList.appendChild(item);
            }
          };

          docsFileInput.addEventListener('change', async () => {
            try {
              const files = docsFileInput.files;
              if (files && files.length > 0) {
                const arr = Array.from(files);
                const pdfs = arr.filter(f => f && ((String(f.type || '').toLowerCase() === 'application/pdf') || /\.pdf$/i.test(String(f.name || ''))));
                let finalFiles = arr;
                if (pdfs.length > 0) {
                  const ok = confirm('PDF-bilag bliver konverteret til billede (side 1) for at kunne indgÃ¥ i eksport. FortsÃ¦t?');
                  if (ok) {
                    finalFiles = [];
                    for (const f of arr) {
                      if (f && ((String(f.type || '').toLowerCase() === 'application/pdf') || /\.pdf$/i.test(String(f.name || '')))) {
                        try {
                          const img = await pdfFileToPngFile(f, { pageNumber: 1, scale: 2 });
                          finalFiles.push(img);
                        } catch(err) {
                          finalFiles.push(f);
                        }
                      } else {
                        finalFiles.push(f);
                      }
                    }
                  }
                }

                addKravCategoryDocsFromFiles(activeSectionIdx, docsCategoryLabel, finalFiles);
              }
            } catch(_) {}
            try { docsFileInput.value = ''; } catch(_) {}
            renderDocs();
          });

          docsBlock.appendChild(docsBlockHeader);
          docsBlock.appendChild(docsList);
          docsBlock.appendChild(docsFileInput);
          renderDocs();

          body.appendChild(docsBlock);

          let lastUnder = null;
          let lastUnderHeadingEl = null;
          let lastUnderUnderHeadingEl = null;
          let lastMiniHeadingEl = null;
          let currentKravId = null;
          let currentGroupWrap = null;
          let currentGroupBody = null;
          let lastUnderUnderInGroup = null;
          let lastMiniInGroup = null;
          let dimAnchorInGroup = null;

          const ensureHeadingActions = (headingEl) => {
            if (!headingEl) return null;
            let wrap = headingEl.querySelector(':scope > .krav-heading-actions');
            if (!wrap) {
              wrap = document.createElement('span');
              wrap.className = 'krav-heading-actions';
              headingEl.appendChild(wrap);
            }
            return wrap;
          };

          const attachViewerButtons = (headingEl, row) => {
            if (!headingEl || !row) return;
            const wrap = ensureHeadingActions(headingEl);
            if (!wrap) return;

            const figures = Array.isArray(row.figures) ? row.figures : [];
            const tables = Array.isArray(row.tables) ? row.tables : [];
            const anchorKey = (row.underundertitle || row.undertitle || row.title || '').trim();

            if (figures.length && !wrap.querySelector('[data-krav-action="figure"]')) {
              const btn = createViewerButton('figure', figures, `${row.kravId}::${anchorKey}::figure`, null);
              if (btn) { btn.setAttribute('data-krav-action', 'figure'); wrap.appendChild(btn); }
            }
            if (tables.length && !wrap.querySelector('[data-krav-action="table"]')) {
              const btn = createViewerButton('table', tables, `${row.kravId}::${anchorKey}::table`, null);
              if (btn) { btn.setAttribute('data-krav-action', 'table'); wrap.appendChild(btn); }
            }
          };

          for (const row of titleRows) {
            const under = row.undertitle || '';
            if (under !== lastUnder && under) {
              const uEl = document.createElement('div');
              uEl.className = 'krav-subtitle';
              uEl.textContent = under;
              const pIcon = createParaIcon(row.paragrafUnderTitle);
              if (pIcon) uEl.appendChild(pIcon);
              body.appendChild(uEl);
              lastUnder = under;
              lastUnderHeadingEl = uEl;
              lastUnderUnderHeadingEl = null;
              // force new Krav group after a new undertitle section
              currentKravId = null;
              currentGroupWrap = null;
              currentGroupBody = null;
              lastUnderUnderInGroup = null;
            }

            // Create a new group when kravId changes
            const kravId = row.kravId || '';
            if (kravId !== currentKravId) {
              currentKravId = kravId;

              currentGroupWrap = document.createElement('div');
              currentGroupWrap.className = 'krav-group';

              const gHeader = document.createElement('div');
              gHeader.className = 'krav-group-header';
              const gMeta = document.createElement('div');
              gMeta.className = 'krav-group-meta';
              const badge = document.createElement('div');
              badge.className = 'krav-id-badge';
              badge.textContent = kravId;
              gMeta.appendChild(badge);
              
              // Add validation badge showing granular validation status
              // Count ACTUAL points from the krav content, not just what's in validationData
              const kravValidation = validationData.krav?.[kravId] || {};
              
              // Find all rows with this kravId to count actual content
              const kravRows = titleRows.filter(r => r.kravId === kravId);
              let actualTotalCount = 0;
              let actualBeskrivelseCount = 0;
              let actualChecklistCount = 0;
              let actualDimCount = 0;
              
              // Count actual beskrivelse, bullets, dim from rows
              kravRows.forEach(r => {
                if (r.beskrivelse) actualBeskrivelseCount++;
                if (r.bullets && r.bullets.length > 0) actualChecklistCount += r.bullets.length;
                if (r.dim) actualDimCount++;
              });
              
              actualTotalCount = actualBeskrivelseCount + actualChecklistCount + actualDimCount;
              
              // Count validated items
              let validatedCount = 0;
              
              if (actualBeskrivelseCount > 0 && kravValidation.beskrivelse) {
                validatedCount++;
              }
              if (actualChecklistCount > 0 && kravValidation.tjekliste) {
                validatedCount += Object.values(kravValidation.tjekliste).filter(v => v).length;
              }
              if (actualDimCount > 0 && kravValidation.dimensionering) {
                validatedCount++;
              }
              
              const isFullyValidated = actualTotalCount > 0 && validatedCount === actualTotalCount;
              const isPartiallyValidated = validatedCount > 0 && validatedCount < actualTotalCount;
              const isNotValidated = validatedCount === 0;
              
              const valBadge = document.createElement('span');
              valBadge.className = 'validation-badge';
              
              // Build detailed status text
              let statusParts = [];
              if (actualBeskrivelseCount > 0) {
                statusParts.push(`Beskrivelse: ${kravValidation.beskrivelse ? 'âœ“' : 'âœ—'}`);
              }
              if (actualChecklistCount > 0) {
                const validatedChecklist = kravValidation.tjekliste ? Object.values(kravValidation.tjekliste).filter(v => v).length : 0;
                statusParts.push(`Tjekliste: ${validatedChecklist}/${actualChecklistCount}`);
              }
              if (actualDimCount > 0) {
                statusParts.push(`Uddybende forklaring: ${kravValidation.dimensionering ? 'âœ“' : 'âœ—'}`);
              }
              
              let badgeColor, badgeText, badgeTooltip;
              if (isFullyValidated) {
                badgeColor = 'background: #d1fae5; color: #065f46;';
                badgeText = 'âœ“ Fuldt valideret';
                badgeTooltip = `Alle ${actualTotalCount} punkter er valideret\n${statusParts.join(' | ')}`;
              } else if (isPartiallyValidated) {
                badgeColor = 'background: #fef3c7; color: #92400e;';
                badgeText = `âš  Delvist (${validatedCount}/${actualTotalCount})`;
                badgeTooltip = `Oversigt over hvad der er valideret:\n\n${statusParts.join('\n')}`;
              } else if (actualTotalCount > 0) {
                badgeColor = 'background: #fed7aa; color: #92400e;';
                badgeText = 'âš  Ikke valideret';
                badgeTooltip = `Oversigt over hvad der er valideret:\n\n${statusParts.join('\n')}`;
              } else {
                badgeColor = 'background: #e5e7eb; color: #6b7280;';
                badgeText = 'â€“ Ingen validering';
                badgeTooltip = 'Dette krav har ingen validerbare punkter';
              }
              
              valBadge.style.cssText = `
                display: inline-flex; 
                align-items: center; 
                gap: 4px; 
                padding: 3px 8px; 
                border-radius: 12px; 
                font-size: 11px; 
                font-weight: 600; 
                margin-left: 8px;
                cursor: help;
                white-space: pre-line;
                ${badgeColor}
              `;
              valBadge.innerHTML = badgeText;
              valBadge.setAttribute('data-tip', badgeTooltip);
              gMeta.appendChild(valBadge);
              
              gHeader.appendChild(gMeta);
              const gActions = document.createElement('div');
              gActions.className = 'krav-actions';
              gHeader.appendChild(gActions);
              currentGroupWrap.appendChild(gHeader);

              currentGroupBody = document.createElement('div');
              currentGroupWrap.appendChild(currentGroupBody);
              body.appendChild(currentGroupWrap);

              // reset group-local heading state
              lastUnderUnderInGroup = null;
              lastMiniInGroup = null;
              dimAnchorInGroup = null;
              lastUnderUnderHeadingEl = null;
              lastMiniHeadingEl = null;
            }

            if (!currentGroupBody) continue;

            // Under-undertitel + mini (inserted inside the Krav_id group so it can appear between checklist segments)
            const underUnder = row.underundertitle || '';
            const mini = row.minititle || '';

            if (underUnder !== lastUnderUnderInGroup && underUnder) {
              const uuEl = document.createElement('div');
              uuEl.className = 'krav-subsubtitle';
              uuEl.textContent = underUnder;
              const pIcon = createParaIcon(row.paragrafUnderUnderTitle);
              if (pIcon) uuEl.appendChild(pIcon);
              currentGroupBody.appendChild(uuEl);
              lastUnderUnderInGroup = underUnder;
              lastMiniInGroup = null;
              dimAnchorInGroup = uuEl;
              lastUnderUnderHeadingEl = uuEl;
              lastMiniHeadingEl = null;
            } else if (underUnder !== lastUnderUnderInGroup) {
              lastUnderUnderInGroup = underUnder;
              lastMiniInGroup = null;
              dimAnchorInGroup = null;
              lastUnderUnderHeadingEl = null;
              lastMiniHeadingEl = null;
            }

            if (mini !== lastMiniInGroup && mini) {
              const mEl = document.createElement('div');
              mEl.className = 'krav-mini';
              mEl.textContent = mini;
              currentGroupBody.appendChild(mEl);
              lastMiniInGroup = mini;
              if (!dimAnchorInGroup) dimAnchorInGroup = mEl;
              lastMiniHeadingEl = mEl;
            } else if (mini !== lastMiniInGroup) {
              lastMiniInGroup = mini;
              if (!mini) dimAnchorInGroup = null;
              if (!mini) lastMiniHeadingEl = null;
            }

            // Optional description (placed immediately above this row's checklist)
            if (row.beskrivelse) {
              const d = document.createElement('div');
              d.className = 'krav-desc';
              
              // Check validation status for beskrivelse
              const kravValidation = validationData.krav?.[row.kravId] || {};
              const isValidated = kravValidation.beskrivelse || false;
              
              const validationBadge = document.createElement('span');
              validationBadge.style.cssText = `
                display: inline-flex;
                align-items: center;
                gap: 4px;
                padding: 2px 8px;
                border-radius: 12px;
                font-size: 11px;
                font-weight: 600;
                margin-left: 8px;
                ${isValidated 
                  ? 'background: #d1fae5; color: #065f46;' 
                  : 'background: #fee2e2; color: #991b1b;'}
              `;
              validationBadge.innerHTML = isValidated ? 'âœ“ Valideret' : 'âœ— Ikke valideret';
              validationBadge.setAttribute('title', isValidated 
                ? 'Beskrivelsen er valideret af brandrÃ¥dgiver' 
                : 'Beskrivelsen er ikke valideret');
              
              d.innerHTML = `<div class="text">${multilineHtml(row.beskrivelse)}</div>`;
              d.insertBefore(validationBadge, d.firstChild);
              currentGroupBody.appendChild(d);
            }

            // Segment actions: keep spacing tight.
            // Place '?' and viewer buttons on the SAME LINE as the nearest heading (right-aligned),
            // so we don't create an extra "actions" line above the checklist.
            const figures = Array.isArray(row.figures) ? row.figures : [];
            const tables = Array.isArray(row.tables) ? row.tables : [];
            const hasViewerButtons = (figures.length || tables.length);
            const hasDim = !!norm(row.dim);

            const makeDimIcon = () => {
              const q = document.createElement('span');
              q.className = 'q-icon q-icon-big';
              q.textContent = '?';
              q.setAttribute('data-dim', decodeGorulesString(row.dim));
              q.setAttribute('data-dim-title', row.kravId);
              q.setAttribute('tabindex', '0');
              return q;
            };

            if (hasViewerButtons || hasDim) {
              const anchorEl = lastMiniHeadingEl || lastUnderUnderHeadingEl || lastUnderHeadingEl || null;
              const wrap = ensureHeadingActions(anchorEl);
              if (wrap) {
                if (hasDim && !wrap.querySelector('.q-icon')) {
                  wrap.appendChild(makeDimIcon());
                }

                const anchorKey = (row.minititle || row.underundertitle || row.undertitle || row.title || '').trim();

                if (figures.length && !wrap.querySelector('[data-krav-action="figure"]')) {
                  const btn = createViewerButton('figure', figures, `${row.kravId}::${anchorKey}::figure`, null);
                  if (btn) { btn.setAttribute('data-krav-action', 'figure'); wrap.appendChild(btn); }
                }
                if (tables.length && !wrap.querySelector('[data-krav-action="table"]')) {
                  const btn = createViewerButton('table', tables, `${row.kravId}::${anchorKey}::table`, null);
                  if (btn) { btn.setAttribute('data-krav-action', 'table'); wrap.appendChild(btn); }
                }
              }
            }

            // Checklist items
            if (row.bullets && row.bullets.length) {
              const ul = document.createElement('ul');
              ul.className = 'krav-checklist';
              
              // Get validation status for this krav
              const kravValidation = validationData.krav?.[row.kravId] || {};
              
              for (let idx = 0; idx < row.bullets.length; idx++) {
                const b = row.bullets[idx];
                const li = document.createElement('li');
                li.className = 'krav-check';
                const leftC = document.createElement('div');
                leftC.className = 'krav-check-left';
                const cb = document.createElement('input');
                cb.type = 'checkbox';
                const key = makeCheckKey(row.kravId, b);
                cb.checked = !!checkState[key];
                if (cb.checked) li.classList.add('checked');
                cb.addEventListener('change', ()=>{ 
                  checkState[key] = !!cb.checked; 
                  if (cb.checked) {
                    li.classList.add('checked');
                  } else {
                    li.classList.remove('checked');
                  }
                });
                const txt = document.createElement('div');
                txt.className = 'krav-check-text';
                txt.innerHTML = multilineHtml(b);
                
                // Add validation badge for this checklist item
                const isValidated = kravValidation.tjekliste?.[idx] || false;
                const validationBadge = document.createElement('span');
                validationBadge.style.cssText = `
                  display: inline-flex;
                  align-items: center;
                  gap: 4px;
                  padding: 2px 8px;
                  border-radius: 12px;
                  font-size: 11px;
                  font-weight: 600;
                  margin-left: 8px;
                  ${isValidated 
                    ? 'background: #d1fae5; color: #065f46;' 
                    : 'background: #fee2e2; color: #991b1b;'}
                `;
                validationBadge.innerHTML = isValidated ? 'âœ“' : 'âœ—';
                validationBadge.setAttribute('title', isValidated 
                  ? 'Dette punkt er valideret af brandrÃ¥dgiver' 
                  : 'Dette punkt er ikke valideret');
                
                leftC.appendChild(cb);
                leftC.appendChild(txt);
                leftC.appendChild(validationBadge);
                li.appendChild(leftC);
                ul.appendChild(li);
              }
              currentGroupBody.appendChild(ul);
            }
          }

          block.appendChild(body);
          frag.appendChild(block);
        }

        container.appendChild(frag);
        
        // Mark requirements as viewed for progress tracking
        const idx = getActiveSectionIndex();
        sectionsState.progress[idx] = { ...(sectionsState.progress[idx]||{}), requirementsViewed: true };
        renderSectionTabs();
        
        // Add event listeners to "Check All" buttons at title level
        document.querySelectorAll('.krav-check-all-btn[data-title-checkall]').forEach(btn => {
          btn.addEventListener('click', function() {
            const title = this.getAttribute('data-title-checkall');
            // Find the parent krav-title-block
            const titleBlock = this.closest('.krav-title-block');
            if (!titleBlock) return;
            
            // Find all checkboxes in this title block
            const checkboxes = titleBlock.querySelectorAll('.krav-checklist input[type="checkbox"]');
            let allChecked = true;
            
            // Check if all are already checked
            checkboxes.forEach(cb => {
              if (!cb.checked) allChecked = false;
            });
            
            // Toggle: if all checked, uncheck all; otherwise check all
            const newState = !allChecked;
            checkboxes.forEach(cb => {
              if (cb.checked !== newState) {
                cb.checked = newState;
                cb.dispatchEvent(new Event('change', { bubbles: true }));
              }
            });
            
            // Update button text
            this.textContent = newState ? 'âœ— Fjern alle' : 'âœ“ Tjek alle';
          });
        });
        
      } catch (error) {
        container.innerHTML = `
          <div style="text-align: center; padding: 48px; color: #999;">
            <div style="font-size: 48px; margin-bottom: 16px;">âš ï¸</div>
            <div>Kunne ikke indlÃ¦se krav fra backend API</div>
            <div style="margin-top: 12px; color: #e74c3c; font-size: 13px;">${error.message}</div>
          </div>
        `;
      }
    }

    // ========== LEGACY: Old requirements.json loader (kept for reference) ==========
    async function generateRequirementsLegacy(bilag, brandklasse, evaluation) {
      window.__requirementsCache = window.__requirementsCache || { data: null, loaded: false, error: null };
      async function loadRequirements(){
        const cache = window.__requirementsCache;
        if (cache.loaded && cache.data) return cache.data;
        try {
          const resp = await fetch('requirements.json');
          if (!resp.ok) throw new Error('Kan ikke hente requirements.json');
          const data = await resp.json();
          cache.data = data; cache.loaded = true; cache.error = null;
          return data;
        } catch (e){
          cache.error = e.message; cache.loaded = true; cache.data = null;
          return null;
        }
      }

      const reqData = await loadRequirements();
      if (!reqData){
        container.innerHTML = `
          <div style="text-align: center; padding: 48px; color: #999;">
            <div style="font-size: 48px; margin-bottom: 16px;">âš ï¸</div>
            <div>Kunne ikke indlÃ¦se krav (requirements.json). PrÃ¸v at genindlÃ¦se siden.</div>
          </div>
        `;
        return;
      }

      // Support both numeric keys and descriptive keys like Bilag1/BK1
      const bilagKeyNumeric = reqData[String(bilag)] || reqData[bilag];
      const bilagKeyDescriptive = reqData[`Bilag${bilag}`];
      const bkKeyNumeric = String(brandklasse);
      const bkKeyDescriptive = `BK${brandklasse}`;
      let requirements = null;
      if (bilagKeyDescriptive && (bilagKeyDescriptive[bkKeyDescriptive] || bilagKeyDescriptive[bkKeyNumeric])){
        requirements = bilagKeyDescriptive[bkKeyDescriptive] || bilagKeyDescriptive[bkKeyNumeric];
      } else if (bilagKeyNumeric && (bilagKeyNumeric[bkKeyNumeric] || bilagKeyNumeric[bkKeyDescriptive])){
        requirements = bilagKeyNumeric[bkKeyNumeric] || bilagKeyNumeric[bkKeyDescriptive];
      }

      // Merge in any Bilag-level common requirements, if provided, so you can define shared items once
      // Supported keys: "common", "Common", "AlleBK"
      const commonSets = [];
      const pushCommon = (obj) => {
        if (!obj || typeof obj !== 'object') return;
        const keys = ["common", "Common", "AlleBK"];
        for (const k of keys){
          if (Array.isArray(obj[k])) commonSets.push(obj[k]);
        }
      };
      pushCommon(bilagKeyDescriptive);
      pushCommon(bilagKeyNumeric);
      if (requirements && commonSets.length){
        // Prepend common categories so they appear first
        requirements = [...commonSets.flat(), ...requirements];
      }
      
      if (!requirements) {
        container.innerHTML = `
          <div style="text-align: center; padding: 48px; color: #999;">
            <div style="font-size: 48px; margin-bottom: 16px;">ðŸš§</div>
            <div>Krav for Bilag ${bilag} - Brandklasse ${brandklasse} er ikke implementeret endnu</div>
          </div>
        `;
        return;
      }
      
      // Build HTML for requirements
      let html = '';
      requirements.forEach((category, idx) => {
        const categoryId = `req-cat-${idx}`;
        const openClass = (prevOpen[idx] === true || (idx === 0 && (!prevOpen.length))) ? 'open' : '';
        
        let itemsHtml = '';
        let checkedCount = 0;
        let totalCheckable = 0;

        // Gate state store (persisted per category label)
        const gateStoreKey = (category.category || '').toLowerCase().replace(/\s+/g,'_');
        const getGateState = (flag) => {
          try {
            const raw = sessionStorage.getItem('reqGateState') || '{}';
            const obj = JSON.parse(raw);
            return !!(obj[flag]);
          } catch(_) { return false; }
        };
        const setGateState = (flag, val) => {
          try {
            const raw = sessionStorage.getItem('reqGateState') || '{}';
            const obj = JSON.parse(raw);
            obj[flag] = !!val;
            sessionStorage.setItem('reqGateState', JSON.stringify(obj));
          } catch(_) {}
        };
        
        // Helper: evaluate condition string or function
        const evalCondition = (cond, val) => {
          if (typeof cond === 'function') return cond(val);
          if (typeof cond === 'string'){
            // very small safe evaluator for patterns like "val <= 600", "val > 3"
            // Only allow operators: <=, >=, <, >, ==, != and numeric RHS
            const m = cond.trim().match(/^val\s*(<=|>=|<|>|==|!=)\s*(-?\d+(?:\.\d+)?)$/);
            if (!m) return false;
            const op = m[1]; const rhs = Number(m[2]);
            // Normalize left value to number when possible
            const left = (typeof val === 'number') ? val : (typeof val === 'string' ? Number(val) : Number(val?.value ?? val));
            switch(op){
              case '<=': return left <= rhs;
              case '>=': return left >= rhs;
              case '<': return left < rhs;
              case '>': return left > rhs;
              case '==': return left === rhs;
              case '!=': return left !== rhs;
              default: return false;
            }
          }
          return false;
        };

        // Helper: robustly resolve a field value, preferring evaluated outputs.
        const resolveFieldValue = (field) => {
          // Prefer evaluation.field.value, then evaluation.field, then currentInput[field]
          let v = undefined;
          if (evaluation && evaluation[field] !== undefined) {
            const ef = evaluation[field];
            v = (ef && typeof ef === 'object' && 'value' in ef) ? ef.value : ef;
          }
          if (v === undefined || v === null) v = currentInput[field];
          // Normalize common string formats like "RK1", "AK4", "1", "4"
          if (typeof v === 'string') {
            const digits = v.match(/\d+/);
            if (digits) return Number(digits[0]);
            const asNum = Number(v);
            if (!Number.isNaN(asNum)) return asNum;
          }
          // If object with value
          if (v && typeof v === 'object' && 'value' in v) return v.value;
          return v;
        };

        const currentInput = (typeof buildJsonFromForm === 'function') ? buildJsonFromForm() : {};
        // Detect gate flags and current states (supports multiple gates per category)
        const gateItems = category.items.filter(it => it.status === 'gate' && it.flag);
        const gateStates = {};
        gateItems.forEach(g => { gateStates[g.flag] = getGateState(g.flag); });

        category.items.forEach((item, iIdx) => {
          // Inline rendering for gate items respecting original order and gating dependencies
          if (item.status === 'gate' && item.flag) {
            const flag = item.flag;
            const enabled = !!gateStates[flag];
            // Apply gating to gate items themselves (supports requiresFlag/requiresAny/requiresAll)
            let gatedOff = false;
            if (item.requiresFlag) {
              if (Array.isArray(item.requiresFlag)) {
                gatedOff = !item.requiresFlag.every(f => gateStates[f]);
              } else {
                gatedOff = !gateStates[item.requiresFlag];
              }
            } else if (Array.isArray(item.requiresAny)) {
              gatedOff = !item.requiresAny.some(f => gateStates[f]);
            } else if (Array.isArray(item.requiresAll)) {
              gatedOff = !item.requiresAll.every(f => gateStates[f]);
            }
            if (gatedOff) { return; }

            if (!enabled) {
              itemsHtml += `
                <div class="req-item">
                  <div class="req-status-icon" style="color:#2b6cb0;">â“</div>
                  <div class="req-content" style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
                    <div>
                      <div class="req-title" id="gate-title-${categoryId}-${flag}">${item.title}</div>
                      <div class="req-description">${item.description || ''}</div>
                    </div>
                    <div style="margin-top:0; display:flex; align-items:center; gap:16px;">
                      <button id="gate-yes-${categoryId}-${flag}" class="btn-primary" style="padding:8px 16px; font-size:14px;">${item.labelOn || 'Ja'}</button>
                      <button id="gate-no-${categoryId}-${flag}" class="btn-secondary" style="padding:8px 16px; font-size:14px;">${item.labelOff || 'Nej'}</button>
                    </div>
                  </div>
                </div>
              `;
            }
            return;
          }
          let statusIcon = 'â„¹ï¸';
          let statusClass = '';
          let valueBadge = '';

          // Conditional gating: support requiresFlag (string), requiresAny (array), requiresAll (array)
          let gatedOff = false;
          if (item.requiresFlag) {
            if (Array.isArray(item.requiresFlag)) {
              // Backward-compat: treat array as requiresAll
              gatedOff = !item.requiresFlag.every(f => gateStates[f]);
            } else {
              gatedOff = !gateStates[item.requiresFlag];
            }
          } else if (Array.isArray(item.requiresAny)) {
            gatedOff = !item.requiresAny.some(f => gateStates[f]);
          } else if (Array.isArray(item.requiresAll)) {
            gatedOff = !item.requiresAll.every(f => gateStates[f]);
          }
          if (gatedOff) { return; }
          
          if (item.status === 'check' && item.checkField && item.checkCondition) {
            totalCheckable++;
            // Prefer evaluated outputs and normalize to numeric when applicable
            const fieldValue = resolveFieldValue(item.checkField);
            if (fieldValue !== undefined && evalCondition(item.checkCondition, fieldValue)) {
              statusIcon = 'âœ“';
              statusClass = 'style="color: #27ae60;"';
              checkedCount++;
            } else {
              statusIcon = 'âš ';
              statusClass = 'style="color: #e67e22;"';
            }
            // Show current input value when relevant
            const showVal = item.showValue === true || item.showValue === 'auto';
            const displayKey = item.displayField || item.checkField;
            const displayVal = resolveFieldValue(displayKey);
            if (showVal && displayVal !== undefined && displayVal !== null) {
              const prefix = item.valuePrefix || '';
              const suffix = item.valueSuffix || '';
              valueBadge = `<span style="margin-left:8px; font-size:12px; background:#eef2ff; color:#1e3a8a; padding:2px 6px; border-radius:10px;">${prefix}${displayVal}${suffix}</span>`;
            }
          } else if (item.status === 'advarsel') {
            // Warning items are highlighted but not checkable and do not affect counts
            statusIcon = 'âš ';
            statusClass = 'style="color: #b45309;"';
            const contentId = `req-content-${categoryId}-${idx}-${iIdx}`;
            itemsHtml += `
              <div class="req-item" style="background:#fff7ed; border:1px solid #fdba74; padding:12px; border-radius:8px;">
                <div class="req-status-icon" ${statusClass}>${statusIcon}</div>
                <div class="req-content" id="${contentId}">
                  <div class="req-title">${item.title}</div>
                  <div class="req-description">${item.description || ''}</div>
                  <div class="req-reference">${item.reference || ''}</div>
                </div>
              </div>
            `;
            return;
          } else if (item.status === 'info') {
            // Info items can be marked as fulfilled by the user
            totalCheckable++;
            // Optional value badge (shown next to title on the left)
            const displayKey = item.displayField;
            const displayVal = displayKey ? resolveFieldValue(displayKey) : undefined;
            if (displayVal !== undefined && displayVal !== null) {
              const prefix = item.valuePrefix || '';
              const suffix = item.valueSuffix || '';
              valueBadge = `<span style="margin-left:8px; font-size:12px; background:#f3f4f6; color:#374151; padding:2px 6px; border-radius:10px;">${prefix}${displayVal}${suffix}</span>`;
            }
            // Persist per session
            const infoKey = `${bilag}|${brandklasse}|${category.category}|${item.title}|${item.reference || ''}`;
            let infoStore = {};
            try { infoStore = JSON.parse(sessionStorage.getItem('reqInfoFulfilled') || '{}'); } catch(_) {}
            const infoChecked = !!infoStore[infoKey];
            if (infoChecked) {
              checkedCount++;
              statusClass = 'style="color: #27ae60;"';
            }
            // Choose icon based on checked state
            statusIcon = infoChecked ? 'âœ“' : 'â„¹ï¸';

            // Build a larger, right-aligned control for Overholdt
            const controlStyles = infoChecked
              ? 'padding:8px 14px; font-size:14px; color:#166534; border:1px solid #16a34a; border-radius:9999px; background:#dcfce7; display:inline-flex; align-items:center; gap:8px;'
              : 'padding:8px 14px; font-size:14px; color:#166534; border:1px solid #16a34a; border-radius:9999px; background:#f0fdf4; display:inline-flex; align-items:center; gap:8px;';
            const actionControl = `
              <label style="${controlStyles}">
                <input type="checkbox" style="width:18px; height:18px;" data-info-key="${encodeURIComponent(infoKey)}" ${infoChecked ? 'checked' : ''} />
                <span>Overholdt</span>
              </label>
            `;

            // Compose the item with right-aligned control
            const contentId = `req-content-${categoryId}-${idx}-${iIdx}`;
            const strikeStyle = (typeof sessionStorage !== 'undefined') ? 'text-decoration-color:#22c55e;' : '';
            itemsHtml += `
              <div class="req-item">
                <div class="req-status-icon" ${statusClass}>${statusIcon}</div>
                <div class="req-content" id="${contentId}" style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
                  <div>
                    <div class="req-title" style="${strikeStyle}">${item.title} ${valueBadge}</div>
                    <div class="req-description">${item.description}</div>
                    <div class="req-reference">${item.reference}</div>
                  </div>
                  ${actionControl}
                </div>
              </div>
            `;
            return;
          }
          
          const contentId = `req-content-${categoryId}-${idx}-${iIdx}`;
          const strikeStyle = (item.status === 'info' && (typeof sessionStorage !== 'undefined')) ? 'text-decoration-color:#22c55e;' : '';
          itemsHtml += `
            <div class="req-item">
              <div class="req-status-icon" ${statusClass}>${statusIcon}</div>
              <div class="req-content" id="${contentId}">
                <div class="req-title" style="${strikeStyle}">${item.title} ${valueBadge}</div>
                <div class="req-description">${item.description}</div>
                <div class="req-reference">${item.reference}</div>
              </div>
            </div>
          `;
        });
        
        let statusBadge = '';
        if (totalCheckable > 0) {
          if (checkedCount === 0) {
            statusBadge = `<span class="status-badge" style="background: #fdecea; color: #b02a37;">${checkedCount}/${totalCheckable} opfyldt</span>`;
          } else if (checkedCount === totalCheckable) {
            statusBadge = `<span class="status-badge" style="background: #d4edda; color: #155724;">${checkedCount}/${totalCheckable} opfyldt</span>`;
          } else {
            statusBadge = `<span class="status-badge" style="background: #fff3cd; color: #856404;">${checkedCount}/${totalCheckable} opfyldt</span>`;
          }
        }
        
        const categoryLabel = String(category.category || '').trim();
        const docsForCategory = categoryLabel ? getKravCategoryDocs(activeSectionIdx, categoryLabel) : [];
        const docsCount = Array.isArray(docsForCategory) ? docsForCategory.length : 0;
        const docsBadge = docsCount > 0
          ? `<span class="status-badge" style="background:#eef2ff; color:#1e3a8a;">ðŸ“Ž ${docsCount}</span>`
          : '';

        const docsListHtml = (docsCount > 0)
          ? docsForCategory.map(d => {
              const name = escapeHtml(d?.name || 'fil');
              const caption = escapeHtml(d?.caption || '');
              const description = escapeHtml(d?.description || '');
              const id = escapeHtml(d?.id || '');
              return `
                <div class="cat-doc-item" data-doc-id="${id}">
                  <div class="cat-doc-item-top">
                    <div class="cat-doc-name">${name}</div>
                    <button type="button" class="btn-secondary cat-doc-remove-btn" data-doc-id="${id}" data-category-label="${escapeHtml(categoryLabel)}" style="padding:6px 10px;">Fjern</button>
                  </div>
                  <div class="cat-doc-fields">
                    <label class="cat-doc-field">
                      <div class="cat-doc-field-label">Billedtekst</div>
                      <input type="text" class="cat-doc-input" data-doc-field="caption" data-doc-id="${id}" data-category-label="${escapeHtml(categoryLabel)}" value="${caption}" placeholder="fx Figur 1: Placering af brandvÃ¦g" />
                    </label>
                    <label class="cat-doc-field">
                      <div class="cat-doc-field-label">Kort forklaring (valgfri)</div>
                      <textarea class="cat-doc-textarea" data-doc-field="description" data-doc-id="${id}" data-category-label="${escapeHtml(categoryLabel)}" rows="2" placeholder="Hvad viser dokumentet/figuren â€“ og hvorfor er det relevant?">${description}</textarea>
                    </label>
                  </div>
                </div>
              `;
            }).join('')
          : `<div class="cat-doc-empty">Ingen dokumentation tilfÃ¸jet til denne kravgruppe endnu.</div>`;

        const docsBlockHtml = categoryLabel ? `
          <div class="cat-docs" data-category-label="${escapeHtml(categoryLabel)}">
            <div class="cat-docs-header">
              <div>
                <div class="cat-docs-title">Dokumentation til denne kravgruppe</div>
                <div class="cat-docs-sub">TilfÃ¸j relevante bilag, samt billedtekst og evt. en kort forklaring. Det kommer med i dokumentationen i trin 4.</div>
              </div>
              <div class="cat-docs-actions">
                <input class="cat-doc-file" type="file" multiple data-category-label="${escapeHtml(categoryLabel)}" style="display:none" />
                <button type="button" class="btn-secondary cat-doc-upload-btn" data-category-label="${escapeHtml(categoryLabel)}" style="padding:8px 12px;">TilfÃ¸j bilag</button>
              </div>
            </div>
            <div class="cat-docs-list">${docsListHtml}</div>
          </div>
        ` : '';

        html += `
          <div class="req-category ${openClass}">
            <div class="req-category-header">
              <span class="icon">${category.category.split(' ')[0]}</span>
              <span>${category.category.substring(category.category.indexOf(' ') + 1)}</span>
              ${statusBadge}
              ${docsBadge}
            </div>
            <div class="req-category-content">
              ${docsBlockHtml}
              ${itemsHtml}
            </div>
          </div>
        `;

        // Wire gate interactions for all gate items
        setTimeout(() => {
          gateItems.forEach(gateItem => {
            const flag = gateItem.flag;
            const yesBtn = document.getElementById(`gate-yes-${categoryId}-${flag}`);
            const noBtn = document.getElementById(`gate-no-${categoryId}-${flag}`);
            const titleEl = document.getElementById(`gate-title-${categoryId}-${flag}`);
            if (yesBtn) {
              yesBtn.addEventListener('click', () => {
                setGateState(flag, true);
                generateRequirements(bilag, brandklasse, evaluation);
              });
            }
            if (noBtn) {
              noBtn.addEventListener('click', () => {
                setGateState(flag, false);
                if (titleEl) {
                  titleEl.style.textDecoration = 'line-through';
                  titleEl.style.color = '#22c55e';
                }
              });
            }
          });
        }, 0);
      });
      
      container.innerHTML = html;
      // Wire info checkbox handlers (post-render)
      container.querySelectorAll('input[data-info-key]').forEach(cb => {
        cb.addEventListener('change', (e) => {
          const k = decodeURIComponent(e.target.getAttribute('data-info-key'));
          let store = {};
          try { store = JSON.parse(sessionStorage.getItem('reqInfoFulfilled') || '{}'); } catch(_) {}
          store[k] = !!e.target.checked;
          try { sessionStorage.setItem('reqInfoFulfilled', JSON.stringify(store)); } catch(_) {}
          // Re-generate to refresh counts and visuals
          generateRequirements(bilag, brandklasse, evaluation);
        });
      });

      // Make accordion toggle only when clicking the header
      container.querySelectorAll('.req-category').forEach(cat => {
        const header = cat.querySelector('.req-category-header');
        if (header) {
          header.addEventListener('click', (e) => {
            e.stopPropagation();
            cat.classList.toggle('open');
          });
        }
      });

      // Step 3: per-category documentation uploads (delegated handlers; bind once)
      if (!container.__kravCategoryDocsBound) {
        container.__kravCategoryDocsBound = true;

        container.addEventListener('click', (e) => {
          const btn = e.target?.closest?.('.cat-doc-upload-btn');
          if (btn) {
            const label = btn.getAttribute('data-category-label') || '';
            const input = container.querySelector(`input.cat-doc-file[data-category-label="${CSS.escape(label)}"]`);
            if (input) input.click();
            return;
          }

          const rm = e.target?.closest?.('.cat-doc-remove-btn');
          if (rm) {
            const label = rm.getAttribute('data-category-label') || '';
            const docId = rm.getAttribute('data-doc-id') || '';
            removeKravCategoryDoc(getActiveSectionIndex(), label, docId);
            try {
              const sIdx = getActiveSectionIndex();
              const eval3 = sectionsState.evaluations[sIdx] || latestEvaluation;
              const bilagNow = getBilagValueFromEvaluation(eval3) || bilag;
              const bkNow = (eval3 && eval3.brandklasse?.value) ? eval3.brandklasse.value : brandklasse;
              generateRequirements(bilagNow, bkNow, eval3);
            } catch(_) {}
            return;
          }
        });

        container.addEventListener('change', async (e) => {
          const input = e.target?.closest?.('input.cat-doc-file');
          if (!input) return;
          const label = input.getAttribute('data-category-label') || '';
          const files = input.files;
          if (files && files.length > 0) {
            try {
              const arr = Array.from(files);
              const pdfs = arr.filter(f => f && ((String(f.type || '').toLowerCase() === 'application/pdf') || /\.pdf$/i.test(String(f.name || ''))));
              let finalFiles = arr;
              if (pdfs.length > 0) {
                const ok = confirm('PDF-bilag bliver konverteret til billede (side 1) for at kunne indgÃ¥ i eksport. FortsÃ¦t?');
                if (ok) {
                  finalFiles = [];
                  for (const f of arr) {
                    if (f && ((String(f.type || '').toLowerCase() === 'application/pdf') || /\.pdf$/i.test(String(f.name || '')))) {
                      try {
                        const img = await pdfFileToPngFile(f, { pageNumber: 1, scale: 2 });
                        finalFiles.push(img);
                      } catch(err) {
                        finalFiles.push(f);
                      }
                    } else {
                      finalFiles.push(f);
                    }
                  }
                }
              }

              addKravCategoryDocsFromFiles(getActiveSectionIndex(), label, finalFiles);
            } catch(_) {
              addKravCategoryDocsFromFiles(getActiveSectionIndex(), label, files);
            }
          }
          // reset input so selecting the same file again still triggers change
          try { input.value = ''; } catch(_) {}

          try {
            const sIdx = getActiveSectionIndex();
            const eval3 = sectionsState.evaluations[sIdx] || latestEvaluation;
            const bilagNow = getBilagValueFromEvaluation(eval3) || bilag;
            const bkNow = (eval3 && eval3.brandklasse?.value) ? eval3.brandklasse.value : brandklasse;
            generateRequirements(bilagNow, bkNow, eval3);
          } catch(_) {}
        });

        container.addEventListener('input', (e) => {
          const el = e.target;
          if (!el) return;
          const field = el.getAttribute('data-doc-field');
          if (field !== 'caption' && field !== 'description') return;
          const label = el.getAttribute('data-category-label') || '';
          const docId = el.getAttribute('data-doc-id') || '';
          updateKravCategoryDocField(getActiveSectionIndex(), label, docId, field, el.value);
        });
      }
    }

    // Accordion toggling
    document.querySelectorAll('.acc-header').forEach(h=>{
      h.addEventListener('click', ()=>{
        const item = h.parentElement; item.classList.toggle('open');
      });
    });

    // Upload handling
    const uploadArea = document.getElementById('upload-area');
    const fileInput = document.getElementById('file-input');
    const jsonTextarea = document.getElementById('json-textarea');
    const bygningstypeSelect = document.getElementById('fld_bygningstype');

    // Track fields the user has manually edited so we don't overwrite their choices.
    const userTouchedFields = new Set();
    const autoFilledFields = new Map(); // controlId -> last auto-filled value

    function markUserTouched(controlId){
      if (!controlId) return;
      userTouchedFields.add(String(controlId));
    }

    function getControl(controlId){
      try { return document.getElementById(controlId); } catch(_) { return null; }
    }

    function setControlValue(controlId, value){
      const el = getControl(controlId);
      if (!el) return false;
      try {
        if (el.tagName === 'SELECT') {
          const desired = String(value);
          // Only set if option exists (avoid leaving select in invalid state).
          const hasOpt = Array.from(el.options || []).some(o => String(o.value) === desired);
          if (!hasOpt) return false;
          el.value = desired;
        } else if (el.type === 'checkbox') {
          el.checked = !!value;
        } else {
          el.value = (value === null || value === undefined) ? '' : String(value);
        }
        autoFilledFields.set(controlId, (el.type === 'checkbox') ? String(!!el.checked) : String(el.value));
        // Trigger listeners that rely on change.
        try { el.dispatchEvent(new Event('change', { bubbles:true })); } catch(_) {}
        return true;
      } catch(_) {
        return false;
      }
    }

    function canAutofill(controlId){
      const id = String(controlId);
      if (!id) return false;
      if (!getControl(id)) return false;
      // If user has touched, never overwrite.
      if (userTouchedFields.has(id)) return false;
      return true;
    }

    function normalizeBygningstypeForDefaults(v){
      return String(v ?? '').trim().toLowerCase()
        .normalize('NFD')
        .replace(/\p{Diacritic}/gu, '')
        .replace(/Ã¦/g, 'ae')
        .replace(/Ã¸/g, 'oe')
        .replace(/Ã¥/g, 'aa')
        .replace(/\s+/g, ' ')
        .trim();
    }

    // Easy-to-edit defaults per bygningstype.
    // Write keys in a human-friendly form; we normalize them automatically.
    // Values are input keys (without fld_ prefix) -> desired value.
    const RAW_BYGNINGSTYPE_DEFAULTS = {
      // Example requested:
      'enfamiliehus': {
        overnatning: true,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },

      'dobbelthus': {
        overnatning: true,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },

      'rÃ¦kkehus': {
        overnatning: true,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },

      'kÃ¦dehus': {
        overnatning: true,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },

      'gruppehus': {
        overnatning: true,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },

      'sommerhus': {
        overnatning: true,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },

      'campinghytte': {
        overnatning: true,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },

      'feriebolig': {
        overnatning: true,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },

      'Ã©n bolig til helÃ¥rsbeboelse': {
        overnatning: true,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },
      'garage': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },

      'carport': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },

      'udhus': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },

      'skur': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },

      'vaerksted': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },
      'mindre bygning med kortvarigt personophold': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },

      'hoensehus': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },

      'drivhus': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },

      'overdaekket terrasse': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },

      'mindre bygning med kortvarigt personophold (sekundaer bebyggelse)': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },
      'butik': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },

      'klinik': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },
      'pavillonbyggerier': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        area_BA: 150,
        area_total: 150,
        antal_personer_BA: 50,
        direkte_udgange: true,
      },

      'forsamlings- og opholdsbygninger': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        area_BA: 150,
        area_total: 150,
        antal_personer_BA: 50,
        direkte_udgange: true,
      },

      'midlertidige undervisnings- og institutionsbygninger': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        area_BA: 150,
        area_total: 150,
        antal_personer_BA: 50,
        direkte_udgange: true,
      },

      'undervisnings- og aktivitetsbygninger': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        area_BA: 150,
        area_total: 150,
        antal_personer_BA: 50,
        direkte_udgange: true,
      },

      'kultur- og formidlingsbygninger': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        area_BA: 150,
        area_total: 150,
        antal_personer_BA: 50,
        direkte_udgange: true,
      },

      'servicebygninger med personophold': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        area_BA: 150,
        area_total: 150,
        antal_personer_BA: 50,
        direkte_udgange: true,
      },

      'cafÃ©- og kioskbygninger med siddepladser': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        area_BA: 150,
        area_total: 150,
        antal_personer_BA: 50,
        direkte_udgange: true,
      },

      'sundheds- og socialbygninger': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        area_BA: 150,
        area_total: 150,
        antal_personer_BA: 50,
        direkte_udgange: true,
      },

      'forenings- og fritidsbygninger': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        area_BA: 150,
        area_total: 150,
        antal_personer_BA: 50,
        direkte_udgange: true,
      },
      'varmestue': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        area_BA: 150,
        area_total: 150,
        antal_personer_BA: 50,
        direkte_udgange: true,
      }





      // Add more types here, e.g.
      // 'sommerhus': { overnatning: true, kendskab_flugtveje: true, selvhjulpen: true },
      // 'campinghytte': { overnatning: true, kendskab_flugtveje: true, selvhjulpen: true },
    };

    const BYGNINGSTYPE_DEFAULTS = Object.fromEntries(
      Object.entries(RAW_BYGNINGSTYPE_DEFAULTS)
        .map(([k, v]) => [normalizeBygningstypeForDefaults(k), v])
    );

    function applyDefaultsForBygningstype(){
      const raw = String(bygningstypeSelect?.value ?? '').trim();
      if (!raw) return;
      const key = normalizeBygningstypeForDefaults(raw);
      const defaults = BYGNINGSTYPE_DEFAULTS[key];
      if (!defaults) return;

      Object.entries(defaults).forEach(([fieldKey, val]) => {
        const controlId = `fld_${fieldKey}`;
        if (!canAutofill(controlId)) return;

        // Booleans are represented as select values "true"/"false".
        if (typeof val === 'boolean') {
          setControlValue(controlId, val ? 'true' : 'false');
        } else {
          setControlValue(controlId, val);
        }
      });
    }

    // Auto-sum: antal_etager_BA = over + under (but allow manual override).
    function applyAutoSumEtager(){
      const overId = 'fld_antal_etager_over_terraen_BA';
      const underId = 'fld_antal_etager_under_terraen_BA';
      const totalId = 'fld_antal_etager_BA';

      const over = asNum(overId);
      const under = asNum(underId);
      if (over === null && under === null) return;
      const sum = Number(over ?? 0) + Number(under ?? 0);

      const totalEl = getControl(totalId);
      if (!totalEl) return;

      const totalTouched = userTouchedFields.has(totalId);
      const current = asNum(totalId);
      const lastAuto = autoFilledFields.get(totalId);
      const currentStr = (totalEl.value ?? '').toString();

      // Fill if user hasn't touched total, OR if total still equals the last auto-filled value.
      const allow = (!totalTouched) || (lastAuto !== undefined && String(lastAuto) === currentStr);
      if (!allow) return;

      setControlValue(totalId, String(sum));
    }

    // Auto-fill standard heights: etage_hoejde_BA = 3.2m * (etager over terrÃ¦n)
    // and etage_dybde_BA = 3.2m * (etager under terrÃ¦n). Users can still override.
    function applyAutoEtageHoedeDybde(){
      const overId = 'fld_antal_etager_over_terraen_BA';
      const underId = 'fld_antal_etager_under_terraen_BA';
      const hoejdeId = 'fld_etage_hoejde_BA';
      const dybdeId = 'fld_etage_dybde_BA';

      const over = asNum(overId);
      const under = asNum(underId);

      const setIfAllowed = (targetId, nextValNum) => {
        const el = getControl(targetId);
        if (!el) return;
        const touched = userTouchedFields.has(targetId);
        const lastAuto = autoFilledFields.get(targetId);
        const currentStr = (el.value ?? '').toString();
        const allow = (!touched) || (lastAuto !== undefined && String(lastAuto) === currentStr);
        if (!allow) return;
        const nextStr = (nextValNum === null || nextValNum === undefined || !Number.isFinite(Number(nextValNum)))
          ? ''
          : String(Number(nextValNum).toFixed(1));
        setControlValue(targetId, nextStr);
      };

      if (over !== null) setIfAllowed(hoejdeId, Number(over) * 3.2);
      if (under !== null) setIfAllowed(dybdeId, Number(under) * 3.2);
    }

    // If overnatning is true, assume all personer overnatter by default.
    // Still allow manual override of antal_overnattende.
    function applyAutoOvernattendeFromPersoner(){
      const overnatningEl = getControl('fld_overnatning');
      if (!overnatningEl) return;
      const overnatningVal = String(overnatningEl.value ?? '').toLowerCase();
      const isOvernatning = (overnatningVal === 'true');
      if (!isOvernatning) return;

      const personer = asNum('fld_antal_personer_BA');
      if (personer === null) return;

      const targetId = 'fld_antal_overnattende';
      const targetEl = getControl(targetId);
      if (!targetEl) return;

      const touched = userTouchedFields.has(targetId);
      const lastAuto = autoFilledFields.get(targetId);
      const currentStr = (targetEl.value ?? '').toString();
      const allow = (!touched) || (lastAuto !== undefined && String(lastAuto) === currentStr);
      if (!allow) return;

      setControlValue(targetId, String(personer));
    }

    // If overnatning is false, assume 0 overnattende.
    // This runs on overnatning-change so it doesn't fight the user if they override afterwards.
    function applyAutoOvernattendeZeroWhenNoOvernatning(){
      const overnatningEl = getControl('fld_overnatning');
      if (!overnatningEl) return;
      const overnatningVal = String(overnatningEl.value ?? '').toLowerCase();
      const isNoOvernatning = (overnatningVal === 'false');
      if (!isNoOvernatning) return;
      const targetId = 'fld_antal_overnattende';
      const targetEl = getControl(targetId);
      if (!targetEl) return;
      setControlValue(targetId, '0');
    }

    // Fast-track controls
    const btnUploadJson = document.getElementById('btn-upload-json');
    const btnDownloadTemplate = document.getElementById('btn-download-template');
    const btnToggleJson = document.getElementById('btn-toggle-json');
    const jsonAdvanced = document.getElementById('json-advanced');

    if (btnUploadJson) btnUploadJson.addEventListener('click', ()=> fileInput.click());

    if (btnToggleJson && jsonAdvanced) {
      btnToggleJson.addEventListener('click', ()=>{
        const open = (jsonAdvanced.style.display !== 'none');
        jsonAdvanced.style.display = open ? 'none' : 'block';
        btnToggleJson.textContent = open ? 'Vis avanceret JSON' : 'Skjul avanceret JSON';

        // When opening the advanced JSON pane, refresh it immediately so bilag extras are visible
        // (e.g., med_tilbygning / med_erhvervssammenbygning), without requiring a form change.
        if (!open) {
          try {
            if (syncingFromJson) return;
            try { if (typeof syncBrandklasseExtras === 'function') syncBrandklasseExtras(); } catch(_) {}

            let obj = null;
            const currentText = (jsonTextarea?.value ?? '').trim();

            // If user is editing JSON (or textarea already has content), prefer that as the source of truth.
            // This avoids unexpectedly overwriting their JSON while still ensuring required keys are visible.
            if (currentText.length > 0) {
              try {
                obj = JSON.parse(currentText);
              } catch (_) {
                obj = null;
              }
            }

            const base = obj ? canonicalizeInputData(obj) : canonicalizeInputData(buildJsonFromForm());
            const merged = { ...base, ...getActiveBilagExtras() };

            if (merged.med_tilbygning === undefined) merged.med_tilbygning = null;
            if (merged.med_erhvervssammenbygning === undefined) merged.med_erhvervssammenbygning = null;

            jsonTextarea.value = JSON.stringify(merged, null, 2);
          } catch(_) {}
        }
      });
    }

    function buildJsonTemplate(){
      // Include all known inputs + bilag extras. Use null/"" to signal "unknown".
      return {
        antal_etager_over_terraen_BA: null,
        antal_etager_under_terraen_BA: null,
        etage_hoejde_BA: null,
        etage_dybde_BA: null,
        etage_hoejde: null,
        antal_etager_BA: null,
        brandbelastning_BA: null,
        area_BA: null,
        area_total: null,
        bygningstype: "",

        med_erhvervssammenbygning: null,
        med_tilbygning: null,

        antal_personer_BA: null,
        antal_overnattende: null,
        overnatning: null,
        kendskab_flugtveje: null,
        selvhjulpen: null,
        fritstaaende: null,
        direkte_udgange: null,
        direkte_udgange_soverum: null,
        bygningsafsnit_i_RK4: null,
        antal_BA: null,
        antal_fravigelser_fra_praeaccepterede: null
      };
    }

    if (btnDownloadTemplate) btnDownloadTemplate.addEventListener('click', ()=>{
      const template = buildJsonTemplate();
      const blob = new Blob([JSON.stringify(template, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'input_template.json';
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=> URL.revokeObjectURL(url), 250);
    });

    if (uploadArea) {
      uploadArea.addEventListener('click', ()=> fileInput.click());
      uploadArea.addEventListener('dragover', (e)=>{ e.preventDefault(); });
      uploadArea.addEventListener('drop', (e)=>{ e.preventDefault(); handleFiles(e.dataTransfer.files); });
    }
    fileInput.addEventListener('change', (e)=> handleFiles(e.target.files));

    // Mark manual touches for specific controls we auto-fill.
    ['fld_overnatning','fld_kendskab_flugtveje','fld_selvhjulpen','fld_antal_personer_BA','fld_antal_overnattende','fld_antal_etager_over_terraen_BA','fld_antal_etager_under_terraen_BA','fld_antal_etager_BA','fld_etage_hoejde_BA','fld_etage_dybde_BA']
      .forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        el.addEventListener('input', (e)=>{ if (e && e.isTrusted === false) return; markUserTouched(id); });
        el.addEventListener('change', (e)=>{ if (e && e.isTrusted === false) return; markUserTouched(id); });
      });

    // When bygningstype changes: apply defaults, then auto-evaluate.
    bygningstypeSelect.addEventListener('change', ()=>{
      try { applyDefaultsForBygningstype(); } catch(_) {}
      updateStatus();
      scheduleEvaluate();
    });

    // When over/under etager changes: update total automatically (unless user overrode).
    ['fld_antal_etager_over_terraen_BA','fld_antal_etager_under_terraen_BA']
      .forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        el.addEventListener('input', ()=>{ try { applyAutoSumEtager(); applyAutoEtageHoedeDybde(); } catch(_) {} });
        el.addEventListener('change', ()=>{ try { applyAutoSumEtager(); applyAutoEtageHoedeDybde(); } catch(_) {} });
      });

    // When overnatning changes:
    // - If true: mirror antal_personer_BA into antal_overnattende
    // - If false: set antal_overnattende to 0
    {
      const el = document.getElementById('fld_overnatning');
      if (el) {
        el.addEventListener('input', ()=>{ try { applyAutoOvernattendeFromPersoner(); applyAutoOvernattendeZeroWhenNoOvernatning(); } catch(_) {} });
        el.addEventListener('change', ()=>{ try { applyAutoOvernattendeFromPersoner(); applyAutoOvernattendeZeroWhenNoOvernatning(); } catch(_) {} });
      }
    }

    // When person count changes, mirror only if overnatning is true.
    {
      const el = document.getElementById('fld_antal_personer_BA');
      if (el) {
        el.addEventListener('input', ()=>{ try { applyAutoOvernattendeFromPersoner(); } catch(_) {} });
        el.addEventListener('change', ()=>{ try { applyAutoOvernattendeFromPersoner(); } catch(_) {} });
      }
    }

    function handleFiles(files){
      const file = files[0];
      if(file){ const reader = new FileReader(); reader.onload = (e)=>{ jsonTextarea.value = e.target.result; jsonManualEdit = true; try { const obj = JSON.parse(jsonTextarea.value); syncingFromJson = true; updateFormFromJson(obj); } catch(_) {} finally { syncingFromJson = false; } updateStatus(); scheduleEvaluate(); }; reader.readAsText(file); }
    }

    // Populate bygningstype options from Brandklasse_Bestemmelse.json (fallback to defaults)
    async function populateBygningstypeOptions(){
      // Udvidet fallbackliste sÃ¥ upload JSON som "Dobbelthuse" m.fl. altid findes
      const simpleByggerier = [
        "pavillonbyggerier",
        "forsamlings- og opholdsbygninger",
        "Midlertidige undervisnings- og institutionsbygninger",
        "undervisnings- og aktivitetsbygninger",
        "kultur- og formidlingsbygninger",
        "servicebygninger med personophold",
        "cafÃ©- og kioskbygninger med siddepladser",
        "sundheds- og socialbygninger",
        "forenings- og fritidsbygninger",
        "Varmestue"
      ];

      const fallback = [
        "Enfamiliehus",
        "Dobbelthus",
        "RÃ¦kkehus",
        "KÃ¦dehus",
        "Gruppehus",
        "Sommerhus",
        "Campinghytte",
        "Feriebolig",
        "Ã‰n bolig til helÃ¥rsbeboelse",
        ...simpleByggerier
      ];

      // Categorization for dropdown optgroups.
      // Keep this in frontend (not in Brandklasse_Bestemmelse.json), so you can tweak grouping freely.
      const normalizeBygningstypeKey = (v) => {
        const s = String(v ?? '').trim().toLowerCase();
        const noDiacritics = s.normalize('NFD').replace(/\p{Diacritic}/gu, '');
        return noDiacritics
          .replace(/Ã¦/g, 'ae')
          .replace(/Ã¸/g, 'oe')
          .replace(/Ã¥/g, 'aa')
          .replace(/\s+/g, ' ')
          .trim();
      };

      const groupOrder = ['Beboelse', 'Simple byggerier', 'SekundÃ¦r bebyggelse', 'Erhverv', 'Andre'];

      const simpleKeys = new Set(simpleByggerier.map(v => normalizeBygningstypeKey(v)));

      const simpleCanonicalByKey = new Map(
        simpleByggerier.map(v => [normalizeBygningstypeKey(v), v])
      );

      const prettySimpleLabel = (v) => {
        const s = String(v ?? '').trim();
        if (!s) return s;
        return s.charAt(0).toUpperCase() + s.slice(1);
      };

      const categoryOverrides = new Map([
        // Beboelse
        ['enfamiliehus', 'Beboelse'],
        ['dobbelthus', 'Beboelse'],
        ['raekkehus', 'Beboelse'],
        ['kaedehus', 'Beboelse'],
        ['gruppehus', 'Beboelse'],
        ['sommerhus', 'Beboelse'],
        ['campinghytte', 'Beboelse'],
        ['feriebolig', 'Beboelse'],
        ['en bolig til heelaarsbeboelse', 'Beboelse'],

        // SekundÃ¦r bebyggelse
        ['garage', 'SekundÃ¦r bebyggelse'],
        ['carport', 'SekundÃ¦r bebyggelse'],
        ['udhus', 'SekundÃ¦r bebyggelse'],
        ['skur', 'SekundÃ¦r bebyggelse'],
        ['vaerksted', 'SekundÃ¦r bebyggelse'],
        ['hoensehus', 'SekundÃ¦r bebyggelse'],
        ['drivhus', 'SekundÃ¦r bebyggelse'],
        ['overdaekket terrasse', 'SekundÃ¦r bebyggelse'],
        ['mindre bygning med kortvarigt personophold', 'SekundÃ¦r bebyggelse'],
        ['mindre bygning med kortvarigt personophold (sekundaer bebyggelse)', 'SekundÃ¦r bebyggelse'],

        // Erhverv
        ['butik', 'Erhverv'],
        ['klinik', 'Erhverv'],

        // Erhverv
        ['butik', 'Erhverv'],
        ['klinik', 'Erhverv'],

      ]);

      const categorizeBygningstype = (val) => {
        const raw = String(val ?? '').trim();
        if (!raw) return 'Andre';
        const s = normalizeBygningstypeKey(raw);
        if (!s || s === 'andet') return 'Andre';

        if (simpleKeys.has(s)) return 'Simple byggerier';

        const forced = categoryOverrides.get(s);
        if (forced) return forced;

        const hasAny = (keywords) => keywords.some(k => s.includes(k));

        if (hasAny(['enfamilie', 'dobbel', 'raekke', 'kaede', 'gruppe', 'sommer', 'ferie', 'camping', 'bolig', 'heelaar'])) return 'Beboelse';
        if (hasAny(['hoense', 'drivhus', 'udhus', 'skur', 'garage', 'carport', 'redskab', 'anneks', 'overdaekket', 'sekundaer'])) return 'SekundÃ¦r bebyggelse';
        if (hasAny(['erhverv', 'kontor', 'butik', 'industri', 'lager', 'vaerksted', 'stald', 'landbrug', 'produktion', 'klinik'])) return 'Erhverv';
        return 'Andre';
      };

      const renderOptions = (options, prev) => {
        bygningstypeSelect.innerHTML = '';
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = 'VÃ¦lg bygningstypeâ€¦';
        placeholder.disabled = true;
        placeholder.selected = true;
        bygningstypeSelect.appendChild(placeholder);

        const groups = new Map(groupOrder.map(g => [g, []]));
        options.forEach(val => {
          const cat = categorizeBygningstype(val);
          if (!groups.has(cat)) groups.set(cat, []);
          groups.get(cat).push(val);
        });

        // Force the "Simple byggerier" group to contain exactly the canonical list in the desired order.
        // This keeps the dropdown stable and aligned with JSON input values.
        groups.set('Simple byggerier', simpleByggerier.slice());
        for (const [g, arr] of groups.entries()) {
          const without = arr.filter(v => v !== 'andet');
          const hasAndet = arr.includes('andet');
          groups.set(g, hasAndet ? without.concat(['andet']) : without);
        }

        for (const g of groupOrder) {
          const arr = groups.get(g) || [];
          if (!arr.length) continue;
          const og = document.createElement('optgroup');
          og.label = g;
          arr.forEach(val => {
            const opt = document.createElement('option');
            opt.value = val;
            opt.textContent = (g === 'Simple byggerier' || simpleKeys.has(normalizeBygningstypeKey(val)))
              ? prettySimpleLabel(val)
              : val;
            og.appendChild(opt);
          });
          bygningstypeSelect.appendChild(og);
        }

        if (prev && options.includes(prev)) bygningstypeSelect.value = prev;
      };

      const prev = String(bygningstypeSelect.value || '');

      try {
        const apiBase = (typeof API_BASE === 'string' && API_BASE.trim()) ? API_BASE.trim().replace(/\/+$/,'') : '';
        const urls = [
          apiBase ? `${apiBase}/Brandklasse_Bestemmelse.json` : null,
          '/Brandklasse_Bestemmelse.json',
          '../Brandklasse_Bestemmelse.json',
          './Brandklasse_Bestemmelse.json'
        ].filter(Boolean);

        let tree = null;
        let loadedFrom = null;
        for (const url of urls){
          try {
            const bust = `t=${Date.now()}`;
            const fetchUrl = url + (url.includes('?') ? '&' : '?') + bust;
            const resp = await fetch(fetchUrl, { cache: 'no-store' });
            if(resp.ok){ tree = await resp.json(); loadedFrom = url; break; }
          } catch(_) {}
        }
        if(!tree) throw new Error('Kan ikke hente Brandklasse_Bestemmelse.json');

        window.BRANDKLASSE_MODEL = tree;

        const values = [];
        const added = new Set();
        const addVal = (s)=>{
          if(typeof s !== 'string') return;
          let t = s.trim();
          if(!t) return;
          const key = normalizeBygningstypeKey(t);
          if (simpleCanonicalByKey.has(key)) t = simpleCanonicalByKey.get(key);
          if (added.has(t)) return;
          added.add(t);
          values.push(t);
        };

        const mergeUnique = (primary, extras) => {
          const out = primary.slice();
          const seen = new Set(out.map(x => String(x ?? '').trim()).filter(Boolean));
          for (const e of extras) {
            const t = String(e ?? '').trim();
            if (!t || seen.has(t)) continue;
            seen.add(t);
            out.push(t);
          }
          return out;
        };

        const addFromRuleValue = (val, depth = 0) => {
          if (depth > 4) return;
          if (val === null || val === undefined) return;
          if (Array.isArray(val)) {
            val.forEach(v => addFromRuleValue(v, depth + 1));
            return;
          }
          if (typeof val === 'string') {
            const s = val.trim();
            if (!s) return;
            const extracted = [];
            const re = /"([^"]+)"|'([^']+)'/g;
            let m;
            while ((m = re.exec(s)) !== null) extracted.push((m[1] ?? m[2] ?? '').trim());
            if (extracted.length) {
              extracted.forEach(x => addVal(x));
              return;
            }
            if (/[,;\n]/.test(s)) {
              s.split(/[,;\n]/g).map(x => x.trim()).filter(Boolean).forEach(x => addVal(x));
              return;
            }
            addVal(s);
            return;
          }
          if (typeof val === 'object') {
            if (Array.isArray(val.values)) { val.values.forEach(v => addFromRuleValue(v, depth + 1)); return; }
            if (Array.isArray(val.$in)) { val.$in.forEach(v => addFromRuleValue(v, depth + 1)); return; }
            if (Array.isArray(val.in)) { val.in.forEach(v => addFromRuleValue(v, depth + 1)); return; }
            Object.values(val).forEach(v => addFromRuleValue(v, depth + 1));
          }
        };

        const nodes = Array.isArray(tree.nodes) ? tree.nodes : [];
        nodes.forEach(node => {
          const content = node && node.content;
          const inputs = content && Array.isArray(content.inputs) ? content.inputs : [];
          const rules = content && Array.isArray(content.rules) ? content.rules : [];
          const bygIds = inputs.filter(inp => inp.field === 'bygningstype').map(inp => inp.id);
          if (!bygIds.length || !rules.length) return;
          rules.forEach(rule => {
            bygIds.forEach(id => addFromRuleValue(rule[id]));
          });
        });

        try {
          console.info('[Bygningstype] Loaded Brandklasse_Bestemmelse.json from', loadedFrom || '(unknown)', '- extracted', values.length, 'values');
          if (!values.length) console.warn('[Bygningstype] No values extracted from model; using fallback list.');
        } catch(_) {}

        const merged = values.length ? mergeUnique(values, fallback) : fallback.slice();
        renderOptions(merged, prev);
      } catch (err) {
        try { console.warn('[Bygningstype] Could not load model; using fallback list.', err); } catch(_) {}
        renderOptions(fallback.slice(), prev);
      }

      // Re-initialize custom selects after options are populated
      setTimeout(() => {
        if (typeof initCustomSelects === 'function') initCustomSelects();
      }, 100);
    }

    // Helpers to read form values
    const asBool = (id, fallback = null) => {
      const el = document.getElementById(id);
      if (!el) return fallback;
      const v = String(el.value);
      if (v === 'true') return true;
      if (v === 'false') return false;
      return null;
    };
    const asNum = (id, fallback = null) => {
      const el = document.getElementById(id);
      if (!el) return fallback;
      const v = el.value;
      const n = v === '' ? null : Number(v);
      return Number.isFinite(n) ? n : null;
    };
    const asStr = (id, fallback = '') => {
      const el = document.getElementById(id);
      if (!el) return fallback;
      return el.value || '';
    };

    // Bilag-specific inputs (asked in step 2 templates)
    function getActiveBilagExtras(){
      const idx = getActiveSectionIndex();
      return sectionsState.bilagExtras?.[idx] || {};
    }
    function setActiveBilagExtra(key, value){
      const idx = getActiveSectionIndex();
      sectionsState.bilagExtras = sectionsState.bilagExtras || {};
      sectionsState.bilagExtras[idx] = { ...(sectionsState.bilagExtras[idx] || {}), [key]: value };
    }

    // Keep the JSON shown/sent in a canonical shape.
    // This prevents legacy/alias keys (e.g. 'tilbygning', 'fritliggende_BA') from appearing in the right-side JSON.
    function canonicalizeInputData(obj){
      const src = (obj && typeof obj === 'object') ? obj : {};
      const pickNum = (key) => {
        const v = src[key];
        if (v === null || v === undefined || v === '') return null;
        const n = Number(v);
        return Number.isFinite(n) ? n : null;
      };
      const pickStr = (key) => {
        const v = src[key];
        return (v === null || v === undefined) ? '' : String(v);
      };
      const pickBool = (key, fallbackKey) => {
        const v = (src[key] !== undefined) ? src[key] : (fallbackKey ? src[fallbackKey] : undefined);
        if (v === undefined || v === null || v === '') return null;
        if (typeof v === 'boolean') return v;
        if (typeof v === 'string') {
          const vv = v.toLowerCase();
          if (vv === 'true') return true;
          if (vv === 'false') return false;
          return null;
        }
        return !!v;
      };

      // 'med_tilbygning' asked in bilag-step (step 2). Keep key only if present.
      const medTilbygning = (src['med_tilbygning'] !== undefined || src['tilbygning'] !== undefined)
        ? ((src['med_tilbygning'] !== undefined) ? pickBool('med_tilbygning') : pickBool('tilbygning'))
        : undefined;
      const fritstaaende = (src['fritstaaende'] !== undefined)
        ? pickBool('fritstaaende')
        : pickBool('fritliggende_BA');

      const out = {
        antal_etager_over_terraen_BA: pickNum('antal_etager_over_terraen_BA'),
        antal_etager_under_terraen_BA: pickNum('antal_etager_under_terraen_BA'),
        etage_hoejde_BA: pickNum('etage_hoejde_BA'),
        etage_dybde_BA: pickNum('etage_dybde_BA'),
        etage_hoejde: pickNum('etage_hoejde'),
        antal_etager_BA: pickNum('antal_etager_BA'),
        brandbelastning_BA: pickNum('brandbelastning_BA'),
        area_BA: pickNum('area_BA'),
        area_total: pickNum('area_total'),
        bygningstype: pickStr('bygningstype'),
        // 'med_erhvervssammenbygning' asked in bilag-step (step 2). Keep key only if present.
        med_erhvervssammenbygning: (src['med_erhvervssammenbygning'] !== undefined) ? pickBool('med_erhvervssammenbygning') : undefined,
        med_tilbygning: medTilbygning,
        antal_personer_BA: pickNum('antal_personer_BA'),
        antal_overnattende: pickNum('antal_overnattende'),
        overnatning: pickBool('overnatning'),
        kendskab_flugtveje: pickBool('kendskab_flugtveje'),
        selvhjulpen: pickBool('selvhjulpen'),
        fritstaaende: fritstaaende,
        direkte_udgange: pickBool('direkte_udgange'),
        direkte_udgange_soverum: pickBool('direkte_udgange_soverum'),
        bygningsafsnit_i_RK4: pickBool('bygningsafsnit_i_RK4'),
        antal_BA: pickNum('antal_BA'),
        antal_fravigelser_fra_praeaccepterede: pickNum('antal_fravigelser_fra_praeaccepterede')
      };

      // Remove undefined optional keys for a cleaner canonical JSON.
      Object.keys(out).forEach(k => { if (out[k] === undefined) delete out[k]; });
      return out;
    }

    function buildJsonFromForm(){
      const data = {
        antal_etager_over_terraen_BA: asNum('fld_antal_etager_over_terraen_BA'),
        antal_etager_under_terraen_BA: asNum('fld_antal_etager_under_terraen_BA'),
        etage_hoejde_BA: asNum('fld_etage_hoejde_BA'),
        etage_dybde_BA: asNum('fld_etage_dybde_BA'),
        etage_hoejde: asNum('fld_etage_hoejde'),
        antal_etager_BA: asNum('fld_antal_etager_BA'),
        brandbelastning_BA: asNum('fld_brandbelastning_BA'),
        area_BA: asNum('fld_area_BA'),
        area_total: asNum('fld_area_total'),
        bygningstype: asStr('fld_bygningstype'),
        antal_personer_BA: asNum('fld_antal_personer_BA'),
        antal_overnattende: asNum('fld_antal_overnattende'),
        overnatning: asBool('fld_overnatning'),
        kendskab_flugtveje: asBool('fld_kendskab_flugtveje'),
        selvhjulpen: asBool('fld_selvhjulpen'),
        fritstaaende: asBool('fld_fritliggende_BA'),
        direkte_udgange: asBool('fld_direkte_udgange'),
        direkte_udgange_soverum: asBool('fld_direkte_udgange_soverum'),
        bygningsafsnit_i_RK4: asBool('fld_bygningsafsnit_i_RK4'),
        antal_BA: sectionsState.count,
        antal_fravigelser_fra_praeaccepterede: asNum('fld_antal_fravigelser_fra_praeaccepterede')
      };
      return canonicalizeInputData(data);
    }

    function updateFormFromJson(obj){
      const hasNum = (v) => (v !== undefined && v !== null && v !== '');
      const hasStr = (v) => (v !== undefined && v !== null && String(v).trim() !== '');
      const hasBool = (v) => (typeof v === 'boolean' || v === 'true' || v === 'false');

      // Only apply values that are actually provided. This enables partial JSON uploads.
      const setNum = (id, key) => {
        const el = document.getElementById(id);
        if (!el) return;
        const v = obj[key];
        if (hasNum(v)) el.value = v;
      };
      const setBool = (id, key) => {
        const el = document.getElementById(id);
        if (!el) return;
        const v = obj[key];
        if (!hasBool(v)) return;
        const b = (typeof v === 'boolean') ? v : (String(v) === 'true');
        el.value = String(!!b);
      };
      const setStr = (id, key) => {
        const el = document.getElementById(id);
        if (!el) return;
        const v = obj[key];
        if (hasStr(v)) el.value = String(v);
      };

      // Numerics
      setNum('fld_antal_etager_over_terraen_BA','antal_etager_over_terraen_BA');
      setNum('fld_antal_etager_under_terraen_BA','antal_etager_under_terraen_BA');
      // etage_hoejde was historically reused for BA; keep a soft fallback when etage_hoejde_BA isn't provided
      if (obj['etage_hoejde'] !== undefined) setNum('fld_etage_hoejde','etage_hoejde');
      if (obj['etage_hoejde_BA'] !== undefined) setNum('fld_etage_hoejde_BA','etage_hoejde_BA');
      else if (obj['etage_hoejde'] !== undefined) setNum('fld_etage_hoejde_BA','etage_hoejde');
      setNum('fld_etage_dybde_BA','etage_dybde_BA');
      setNum('fld_antal_etager_BA','antal_etager_BA');
      setNum('fld_brandbelastning_BA','brandbelastning_BA');
      setNum('fld_area_BA','area_BA');
      setNum('fld_area_total','area_total');
      setNum('fld_antal_personer_BA','antal_personer_BA');
      setNum('fld_antal_overnattende','antal_overnattende');
      // antal_BA uses sectionsState.count instead of form field

      // Booleans
      setBool('fld_overnatning','overnatning');
      setBool('fld_kendskab_flugtveje','kendskab_flugtveje');
      setBool('fld_selvhjulpen','selvhjulpen');
      setBool('fld_direkte_udgange','direkte_udgange');
      setBool('fld_direkte_udgange_soverum','direkte_udgange_soverum');
      setBool('fld_bygningsafsnit_i_RK4','bygningsafsnit_i_RK4');

      // Numerics (nye felter)
      setNum('fld_antal_fravigelser_fra_praeaccepterede','antal_fravigelser_fra_praeaccepterede');

      // Bilag-specific keys (asked in step 2) - store as extras when loaded from JSON
      if (obj['med_tilbygning'] === true || obj['med_tilbygning'] === false) {
        setActiveBilagExtra('med_tilbygning', obj['med_tilbygning']);
        setBool('fld_med_tilbygning', 'med_tilbygning');
      } else if (obj['tilbygning'] === true || obj['tilbygning'] === false) {
        setActiveBilagExtra('med_tilbygning', obj['tilbygning']);
        // Backwards compatible key
        setBool('fld_med_tilbygning', 'tilbygning');
      }
      if (obj['med_erhvervssammenbygning'] === true || obj['med_erhvervssammenbygning'] === false) {
        setActiveBilagExtra('med_erhvervssammenbygning', obj['med_erhvervssammenbygning']);
        setBool('fld_med_erhvervssammenbygning', 'med_erhvervssammenbygning');
      }

      // Backwards/forwards compatible: fritstaaende (preferred) / fritliggende_BA
      if (document.getElementById('fld_fritliggende_BA')){
        // IMPORTANT: don't coerce null/undefined to false ("Nej"). Only set when a real boolean is provided.
        if (obj['fritstaaende'] === true || obj['fritstaaende'] === false) {
          document.getElementById('fld_fritliggende_BA').value = String(obj['fritstaaende']);
        } else if (obj['fritliggende_BA'] === true || obj['fritliggende_BA'] === false) {
          document.getElementById('fld_fritliggende_BA').value = String(obj['fritliggende_BA']);
        } else {
          try { document.getElementById('fld_fritliggende_BA').value = ''; } catch(_) {}
        }
      }

      // Strings
      if (obj['bygningstype'] !== undefined && obj['bygningstype'] !== null && String(obj['bygningstype']).trim() !== '' && document.getElementById('fld_bygningstype')){
        const sel = document.getElementById('fld_bygningstype');
        const val = String(obj['bygningstype']);
        // If option not present, keep current selection to avoid empty state
        const exists = Array.from(sel.options).some(o => o.value === val);
        sel.value = exists ? val : sel.value;
      }

      // If JSON load provided enough for brandklasse, trigger evaluation on Step 1.
      try {
        if (currentStep === 1) {
          // Always run /evaluate-complete after JSON load so we can compute BK or at least
          // show BK suggestions (even when totalareal is missing).
          scheduleBrandklasseEvaluate();
        }
      } catch(_) {}
      
      // Re-initialize custom selects after form values are updated
      setTimeout(() => {
        if (typeof initCustomSelects === 'function') initCustomSelects();
      }, 50);
    }

    // Auto-evaluate: prefer form data; use textarea when visible and non-empty
    let evalTimer = null;
    function scheduleEvaluate(){
      if(evalTimer) clearTimeout(evalTimer);
      // Keep JSON in sync with form unless we're currently syncing from JSON or user is editing JSON manually
      if(!syncingFromJson && !jsonManualEdit){
        const data = { ...canonicalizeInputData(buildJsonFromForm()), ...getActiveBilagExtras() };
        // Always include these keys in the JSON view (null = unknown) so they don't "pop in" later.
        if (data.med_tilbygning === undefined) data.med_tilbygning = null;
        if (data.med_erhvervssammenbygning === undefined) data.med_erhvervssammenbygning = null;
        jsonTextarea.value = JSON.stringify(data, null, 2);
      }
      evalTimer = setTimeout(evaluateNow, 300);
    }

    async function evaluateNow(){
      try {
        let data;
        // Prefer form unless user manually edited JSON
        const jsonPaneVisible = (() => {
          try {
            if (!jsonAdvanced) return false;
            return window.getComputedStyle(jsonAdvanced).display !== 'none';
          } catch (_) {
            return false;
          }
        })();
        const useTextarea = jsonPaneVisible && jsonManualEdit && jsonTextarea.value.trim().length > 0;
        if(useTextarea){
          try {
            const parsed = JSON.parse(jsonTextarea.value);
            data = canonicalizeInputData(parsed);
            // Keep textarea clean even if JSON was loaded/edited with legacy keys.
            // IMPORTANT: Always include bilag extras keys so they don't flicker in/out.
            const view = { ...getActiveBilagExtras(), ...data };
            if (view.med_tilbygning === undefined) view.med_tilbygning = null;
            if (view.med_erhvervssammenbygning === undefined) view.med_erhvervssammenbygning = null;
            jsonTextarea.value = JSON.stringify(view, null, 2);
          } catch(parseErr){
            // Invalid JSON; show dashes
            displayResults({});
            updateStatus();
            return;
          }
        } else {
          data = canonicalizeInputData(buildJsonFromForm());
          // Keep textarea consistent with scheduleEvaluate() (includes bilag extras and stable keys)
          const view = { ...data, ...getActiveBilagExtras() };
          if (view.med_tilbygning === undefined) view.med_tilbygning = null;
          if (view.med_erhvervssammenbygning === undefined) view.med_erhvervssammenbygning = null;
          jsonTextarea.value = JSON.stringify(view, null, 2);
        }
        // Persist inputs for the active section so tab switches retain state
        try { captureInputsToSection(getActiveSectionIndex()); } catch(_) {}
        // Step 1 uses basic evaluation (AK/RK/Bilag). Brandklasse is evaluated separately on Step 1.
        const response = await fetch(`${API_BASE}/evaluate-basic`, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(data)});
        if(!response.ok){
          // Not enough input or server error; show dashes
          displayResults({});
          updateStatus();
          return;
        }
        const result = await response.json();
        displayResults(result);
        const idx = getActiveSectionIndex();
        // Merge basic result into existing evaluation to avoid wiping brandklasse/bilag_outputs.
        const previous = sectionsState.evaluations[idx] ?? latestEvaluation ?? {};
        const merged = { ...previous, ...result };
        if (!('brandklasse' in result) && previous.brandklasse !== undefined) merged.brandklasse = previous.brandklasse;

        // IMPORTANT: /evaluate-basic should not wipe figure refs coming from /evaluate-complete.
        // Some backends may include an empty bilag_outputs object in the basic response.
        const prevOut = previous.bilag_outputs;
        const resOut = result.bilag_outputs;
        const isPlainObject = (v) => v !== null && v !== undefined && typeof v === 'object' && !Array.isArray(v);
        if (isPlainObject(prevOut) && isPlainObject(resOut)) {
          const resKeys = Object.keys(resOut);
          merged.bilag_outputs = resKeys.length === 0 ? prevOut : { ...prevOut, ...resOut };
        } else if (
          // If basic didn't include bilag_outputs (or included null/empty), keep previous.
          (!('bilag_outputs' in result) || resOut === null || (isPlainObject(resOut) && Object.keys(resOut).length === 0))
          && previous.bilag_outputs !== undefined
        ) {
          merged.bilag_outputs = previous.bilag_outputs;
        }
        latestEvaluation = merged;
        sectionsState.evaluations[idx] = merged;
        // Store input data for explanations
        sectionsState.inputData[idx] = data;
        sectionsState.progress[idx] = { ...(sectionsState.progress[idx]||{}), evaluated:true };
        renderSectionTabs();
        try { updateStep1BrandklasseCard(); } catch(_) {}
        updateStatus();
      } catch(err){
        // Network or other error; keep dashes
        displayResults({});
        updateStatus();
      }
    }

    // Store matched rule IDs for current evaluation
    let currentMatchedRules = {
      anvendelseskategori: null,
      risikoklasse: null,
      relevant_bilag: null,
      brandklasse: null
    };

    // Check if a specific rule path is validated
    function isRuleValidated(ruleId) {
      if (!ruleId || !validationData.decisionTables) {
        console.log(`[Validation] Rule ${ruleId} check: No ruleId or validation data`);
        return false;
      }
      const validated = validationData.decisionTables[ruleId]?.validated === true;
      console.log(`[Validation] Checking rule ${ruleId}: ${validated ? 'VALIDATED' : 'NOT VALIDATED'}`);
      return validated;
    }

    // Update validation status for all current results
    function updateResultValidationStatus() {
      console.log('[Validation] Updating result validation status...');
      console.log('[Validation] Current matched rules:', currentMatchedRules);
      console.log('[Validation] Validation data:', validationData);
      
      // Don't show topbar badge
      
      // Update individual result badges
      const fields = ['anvendelseskategori', 'risikoklasse', 'relevant_bilag', 'brandklasse'];
      
      for (const field of fields) {
        const ruleId = currentMatchedRules[field];
        if (ruleId) {
          const validated = isRuleValidated(ruleId);
          updateResultBadge(field, validated);
        } else {
          console.log(`[Validation] No rule ID for field: ${field}`);
        }
      }
    }

    // Update validation badge for a specific result
    function updateResultBadge(field, validated) {
      const mapping = {
        'anvendelseskategori': 'anvendelse',
        'risikoklasse': 'risiko',
        'relevant_bilag': 'bilag',
        'brandklasse': 'brandklasse'
      };
      const rowId = mapping[field];
      if (!rowId) return;
      
      const row = document.querySelector(`[data-result-row="${rowId}"]`);
      if (!row) {
        console.warn(`[Validation] Could not find row for field: ${field}, rowId: ${rowId}`);
        return;
      }
      
      // Remove existing badge
      const existingBadge = row.querySelector('.validation-badge');
      if (existingBadge) existingBadge.remove();
      
      // Check if there's actually a result value to validate
      const valueEl = row.querySelector('.result-value');
      if (!valueEl) return;
      
      const valueText = valueEl.textContent.trim();
      // Only show badge if there's an actual result (not "-" or empty)
      if (!valueText || valueText === '-') return;
      
      // Add new badge
      const badge = document.createElement('span');
      badge.className = 'validation-badge';
      badge.style.cssText = `
        display: inline-flex; 
        align-items: center; 
        gap: 4px; 
        padding: 3px 8px; 
        border-radius: 12px; 
        font-size: 11px; 
        font-weight: 600; 
        margin-left: 8px;
        ${validated 
          ? 'background: #d1fae5; color: #065f46;' 
          : 'background: #fed7aa; color: #92400e;'}
      `;
      badge.className = 'validation-badge';
      badge.innerHTML = validated ? 'âœ“ Valideret' : 'âš  Ikke valideret';
      badge.setAttribute('data-tip', validated ? 'Denne regel er tjekket af en brandrÃ¥dgiver' : 'Denne regel er ikke tjekket');
      
      valueEl.appendChild(badge);
    }

    function displayResults(result){
      const hasText = (v) => v !== null && v !== undefined && String(v).trim() !== '';

      // Collect the exact questions we actually show on the right.
      const displayedHighlightQuestions = [];
      const addHL = (arr)=>{
        if (!Array.isArray(arr)) return;
        arr.forEach(q => {
          if (q === null || q === undefined) return;
          if (typeof q === 'object') {
            // Prefer stable backend fields whenever present.
            if (q.field) {
              displayedHighlightQuestions.push({ field: q.field, question: q.question || null, kind: q.kind || null });
              return;
            }
            return;
          }
          // No fallback to question-text highlighting (ID-based only).
        });
      };

      const uniqStrings = (arr) => Array.from(new Set((Array.isArray(arr) ? arr : [])
        .map(v => String(v ?? '').trim())
        .filter(Boolean)));

      const pickMissing = (nodeHints, fallbackCandidates) => {
        const hints = (Array.isArray(nodeHints) ? nodeHints : []).map(h => String(h).toLowerCase());
        const missing = Array.isArray(result?.missing_inputs) ? result.missing_inputs : [];

        const fromMissing = missing
          .filter(mi => {
            const node = String(mi?.node_name ?? mi?.node ?? '').toLowerCase();
            return hints.some(h => node.includes(h));
          })
          .sort((a, b) => Number(b?.score ?? 0) - Number(a?.score ?? 0));

        // Display text: prefer human question strings.
        const displayFromMissing = fromMissing.map(mi => mi?.question).filter(Boolean);

        // Highlight: prefer stable backend fields (field -> fld_<field>).
        const highlightFromMissing = fromMissing
          .map(mi => (mi?.field ? { field: mi.field, question: mi?.question || null, kind: 'missing' } : null))
          .filter(Boolean);

        const candList = Array.isArray(fallbackCandidates) ? fallbackCandidates : [];
        const candDisplay = candList.flatMap(c => Array.isArray(c?.missing_questions) ? c.missing_questions : [])
          .map(v => String(v ?? '').trim())
          .filter(Boolean);
        const candFields = candList.flatMap(c => Array.isArray(c?.missing_fields) ? c.missing_fields : [])
          .map(v => String(v ?? '').trim())
          .filter(Boolean);
        const candHighlight = Array.from(new Set(candFields)).slice(0, 6).map(f => ({ field: f, kind: 'missing' }));

        const display = uniqStrings(displayFromMissing.length ? displayFromMissing : candDisplay).slice(0, 4);
        const highlight = (highlightFromMissing.length ? highlightFromMissing : candHighlight);
        return { display, highlight };
      };

      const pickCandidateValues = (list, prefix = '') => {
        if (!Array.isArray(list) || list.length === 0) return [];
        const values = uniqStrings(list.map(c => c?.value).filter(v => v !== null && v !== undefined));
        return values.map(v => `${prefix}${v}`);
      };

      const pickOptimizationTargets = (list, prefix = '') => {
        if (!Array.isArray(list) || list.length === 0) return [];
        const targets = uniqStrings(list.map(s => s?.target_value).filter(v => v !== null && v !== undefined));
        return targets.map(t => `${prefix}${t}`);
      };

      const formatOptimizationDetails = (list, labelPrefix) => {
        if (!Array.isArray(list) || list.length === 0) return '';
        const lines = ['Optimering:'];
        list.slice(0, 3).forEach((s)=>{
          const target = s?.target_value;
          if (target === null || target === undefined) return;

          const parts = [];

          const missing = Array.isArray(s?.missing_questions) ? s.missing_questions : [];
          if (missing.length) parts.push(`Udfyld: ${missing.slice(0, 4).join(', ')}`);

          const req = Array.isArray(s?.required_fields) ? s.required_fields : [];
          const reqTxt = req
            .map(r => {
              const q = r?.question;
              const exp = r?.expected_value;
              if (!q) return '';
              if (exp === null || exp === undefined || String(exp).trim() === '') return `${q}`;
              return `${q} = ${exp}`;
            })
            .filter(Boolean);
          if (reqTxt.length) parts.push(`SÃ¦t: ${reqTxt.slice(0, 3).join('; ')}`);

          const nums = Array.isArray(s?.numeric_adjustments) ? s.numeric_adjustments : [];
          const numsTxt = nums
            .map(a => {
              const q = a?.question;
              const exp = a?.expected;
              const d = a?.delta_abs;
              if (!q || !exp) return '';
              const deltaTxt = (d !== null && d !== undefined && Number.isFinite(Number(d)))
                ? ` (afvigelse: ${Number(d).toFixed(0)})`
                : '';
              return `${q} ${exp}${deltaTxt}`;
            })
            .filter(Boolean);
          if (numsTxt.length) parts.push(`JustÃ©r: ${numsTxt.slice(0, 3).join('; ')}`);

          const detail = parts.length ? ` ${parts.join(' | ')}` : '';
          lines.push(`â€¢ ${labelPrefix}${target}:${detail}`);
        });
        return lines.length > 1 ? lines.join('\n') : '';
      };

      const buildActionHelp = ({ ok, okText, candidates, missingQuestions, optimizationTargets }) => {
        const lines = [];
        if (ok) {
          if (okText) lines.push(okText);
          if (optimizationTargets && optimizationTargets.length) {
            lines.push(`Mulig optimering: ${optimizationTargets.slice(0, 3).join(', ')}`);
          }
          return lines.join('\n');
        }

        if (candidates && candidates.length) {
          lines.push(`Kan blive: ${candidates.slice(0, 6).join(' eller ')}`);
        }
        if (missingQuestions && missingQuestions.length) {
          lines.push('For at afgÃ¸re:');
          missingQuestions.forEach(q => lines.push(`â€¢ ${q}`));
        }
        if (!lines.length) lines.push('VÃ¦rktÃ¸j er ikke udvidet til flere bilag end 1a og 1b pÃ¥ nuvÃ¦rende tidspunkt.');
        return lines.join('\n');
      };

      const formatCandidates = (list, kindLabel) => {
        if (!Array.isArray(list) || list.length === 0) return '';
        const parts = list.slice(0, 6).map((c)=>{
          const v = (c && c.value !== undefined && c.value !== null) ? String(c.value) : '';
          const missing = Array.isArray(c?.missing_questions) ? c.missing_questions
                        : (Array.isArray(c?.missing_fields) ? c.missing_fields : []);
          const missTxt = (missing && missing.length) ? ` (mangler: ${missing.join(', ')})` : '';
          return `${v}${missTxt}`.trim();
        }).filter((x)=>x && x !== '-');
        if (parts.length === 0) return '';
        const prefix = kindLabel ? `${kindLabel}: ` : '';
        return `${prefix}Mulige: ${parts.join(' eller ')}`;
      };

      const formatOptimizations = (list, label) => {
        if (!Array.isArray(list) || list.length === 0) return '';
        const parts = list.slice(0, 2).map((s)=>{
          const target = s?.target_value;
          if (target === null || target === undefined) return '';

          const missing = Array.isArray(s?.missing_questions) ? s.missing_questions : [];
          const req = Array.isArray(s?.required_fields) ? s.required_fields.map(r => r?.question).filter(Boolean) : [];
          const nums = Array.isArray(s?.numeric_adjustments)
            ? s.numeric_adjustments.map(a => {
                const q = a?.question;
                const exp = a?.expected;
                const cur = a?.current;
                const d = a?.delta_abs;
                if (!q || !exp) return '';
                const deltaTxt = (d !== null && d !== undefined && Number.isFinite(Number(d))) ? ` (afvigelse: ${Number(d).toFixed(0)})` : '';
                return `${q} ${exp}${deltaTxt}`;
              }).filter(Boolean)
            : [];

          const needs = [...missing, ...req, ...nums].filter(Boolean);
          const needsTxt = needs.length ? ` â€” hvis: ${needs.join(', ')}` : '';
          return `${label}${target}${needsTxt}`;
        }).filter(Boolean);

        return parts.length ? `Optimering: ${parts.join(' | ')}` : '';
      };

      // Store matched rule IDs
      console.log('[Display] Full result object:', JSON.stringify(result, null, 2));
      console.log('[Display] anvendelseskategori object:', result?.anvendelseskategori);
      console.log('[Display] anvendelseskategori.matched_rule_id:', result?.anvendelseskategori?.matched_rule_id);
      console.log('[Display] risikoklasse object:', result?.risikoklasse);
      console.log('[Display] risikoklasse.matched_rule_id:', result?.risikoklasse?.matched_rule_id);
      
      currentMatchedRules.anvendelseskategori = result?.anvendelseskategori?.matched_rule_id || null;
      currentMatchedRules.risikoklasse = result?.risikoklasse?.matched_rule_id || null;
      currentMatchedRules.relevant_bilag = result?.relevant_bilag?.matched_rule_id || null;
      currentMatchedRules.brandklasse = result?.brandklasse?.matched_rule_id || null;
      
      console.log('[Display] Stored matched rules:', currentMatchedRules);

      const akVal = hasText(result?.anvendelseskategori?.value) ? String(result.anvendelseskategori.value) : '-';
      const akCand = result?.candidates?.anvendelseskategori;
      const akMissing = (akVal === '-') ? pickMissing(['anvendelseskategori'], akCand) : { display: [], highlight: [] };
      const akDesc = buildActionHelp({
        ok: akVal !== '-',
        okText: '',
        candidates: pickCandidateValues(akCand, ''),
        missingQuestions: akMissing.display,
        optimizationTargets: []
      });
      addHL(akMissing.highlight);
      setResultRowValue('anvendelse', akVal, akDesc);
      setResultRowStatus('anvendelse', akVal !== '-');

      const rkVal = hasText(result?.risikoklasse?.value) ? String(result.risikoklasse.value) : '-';
      const rkCand = result?.candidates?.risikoklasse;
      const rkOptDetail = formatOptimizationDetails(result?.suggestions?.risikoklasse, 'RK');
      let rkDesc = '';
      if (rkVal !== '-') {
        rkDesc = (rkOptDetail || '');

        // If we show optimization, highlight the questions that appear in it.
        const optList = Array.isArray(result?.suggestions?.risikoklasse) ? result.suggestions.risikoklasse : [];
        optList.slice(0, 3).forEach(s => {
          // Prefer fields over text.
          addHL(Array.isArray(s?.missing_fields) ? s.missing_fields.map(f => ({ field: f, kind: 'missing' })) : []);
          addHL(Array.isArray(s?.required_fields) ? s.required_fields.map(r => ({ ...r, kind: 'opt' })) : []);
          addHL(Array.isArray(s?.numeric_adjustments) ? s.numeric_adjustments.map(a => ({ ...a, kind: 'opt' })) : []);
        });
      } else {
        // RK depends on AK â€” don't show RK missing-field prompts until AK is known.
        if (akVal === '-') {
          rkDesc = 'Afventer: Anvendelseskategori';
        } else {
          const rkMissing = pickMissing(['risikoklasse'], rkCand);
          rkDesc = buildActionHelp({
            ok: false,
            okText: '',
            candidates: pickCandidateValues(rkCand, ''),
            missingQuestions: rkMissing.display,
            optimizationTargets: []
          });
          addHL(rkMissing.highlight);
        }
      }
      setResultRowValue('risiko', rkVal, rkDesc);
      setResultRowStatus('risiko', rkVal !== '-');

      const bilagRaw = result?.relevant_bilag?.value ?? result?.relevant_bilag ?? result?.bilag;
      const bilagVal = hasText(bilagRaw) ? String(bilagRaw) : '-';
      const bilagTitleRaw = (result?.bilag_titel && typeof result.bilag_titel === 'object' && ('value' in result.bilag_titel))
        ? result.bilag_titel.value
        : result?.bilag_titel;
      const bilagInfoRaw = result?.bilagsinformation ?? result?.relevant_bilag?.description;
      const bilagDesc = hasText(bilagTitleRaw)
        ? String(bilagTitleRaw)
        : (hasText(bilagInfoRaw) ? String(bilagInfoRaw) : '');

      let bilagDescOut = bilagDesc;
      if (bilagVal === '-') {
        // Bilag depends on AK + RK â€” wait with prompts until both are known.
        const waiting = [];
        if (akVal === '-') waiting.push('Anvendelseskategori');
        if (rkVal === '-') waiting.push('Risikoklasse');
        if (waiting.length) {
          bilagDescOut = `Afventer: ${waiting.join(', ')}`;
        } else {
          const cand = result?.candidates?.relevant_bilag;
          const bilagMissing = pickMissing(['bilag', 'relevant bilag'], cand);
          bilagDescOut = buildActionHelp({
            ok: false,
            okText: '',
            candidates: pickCandidateValues(cand, ''),
            missingQuestions: bilagMissing.display,
            optimizationTargets: []
          });
          addHL(bilagMissing.highlight);
        }
      }

      setResultRowValue('bilag', bilagVal, bilagDescOut);
      setResultRowStatus('bilag', bilagVal !== '-');

      const headline = document.getElementById('headline-results');
      if (headline) headline.textContent = `Risikoklasse ${rkVal} â€“ Bilag ${bilagVal}`;
      
      // Update validation badges
      updateResultValidationStatus();

      // Show backend error/debug info if present
      const hasErrors = Array.isArray(result.errors) && result.errors.length > 0;
      const headlineEl = document.getElementById('headline-results');
      if (hasErrors && headlineEl) {
        console.warn('Evaluator errors:', result.errors, result.debug_ak, result.debug_rk, result.debug_bilag, result.debug_bk);
        const parent = headlineEl.parentElement;
        let banner = document.getElementById('eval-error-banner');
        if (!banner) {
          banner = document.createElement('div');
          banner.id = 'eval-error-banner';
          banner.style.background = '#fff3cd';
          banner.style.color = '#856404';
          banner.style.border = '1px solid #ffeeba';
          banner.style.borderRadius = '8px';
          banner.style.padding = '8px 12px';
          banner.style.marginTop = '8px';
          parent.appendChild(banner);
        }
        banner.textContent = `âš ï¸ Evaluering kunne ikke fuldfÃ¸res: ${result.errors.join('; ')}`;
      } else {
        const banner = document.getElementById('eval-error-banner');
        if (banner) banner.remove();
      }

      // Mark requirements viewed for active section when in step 2
      if (currentStep === 2){
        const idx = getActiveSectionIndex();
        sectionsState.progress[idx] = { ...(sectionsState.progress[idx]||{}), requirementsViewed:true };
        renderSectionTabs();
      }

      // Store + apply highlights for AK/RK/Bilag only.
      latestDisplayedHighlightQuestionsBase = displayedHighlightQuestions;
      try { applyHighlightsFromDisplayedQuestions(displayedHighlightQuestions); } catch(_) {}
    }

    // Final overview: aggregate per-section titles and key results
    function renderFinalOverview(){
      const cont = document.getElementById('final-overview');
      if (!cont) return;
      cont.innerHTML = '';

      let completed = 0;
      let total = 0;

      for (let bIdx = 0; bIdx < buildingsState.count; bIdx++){
        const buildingTitle = buildingsState.titles[bIdx] || `Bygning ${bIdx+1}`;
        const b = buildingsState.buildings[bIdx];
        if (!b) continue;

        // Building header
        const header = document.createElement('div');
        header.style.cssText = 'margin-top: 6px; padding: 10px 12px; font-weight: 800; color:#0f172a; background:#f8fafc; border:1px solid #e6e8ef; border-radius: 10px;';
        header.textContent = buildingTitle;
        cont.appendChild(header);

        for (let i = 0; i < (b.count || 1); i++){
          const title = b.titles[i] || `Bygningsafsnit ${i+1}`;
          const evalRes = b.evaluations[i];
          const ak = evalRes?.anvendelseskategori?.value ?? '-';
          const rk = evalRes?.risikoklasse?.value ?? '-';
          const bilagRaw = evalRes?.relevant_bilag?.value ?? evalRes?.relevant_bilag ?? '-';
          const bk = evalRes?.brandklasse?.value ?? '-';
          const done = (b.progress[i]?.evaluated && b.progress[i]?.requirementsViewed);

          total++;
          if (done) completed++;

          const row = document.createElement('div');
          row.style.cssText = 'display:flex; align-items:stretch; gap:0; border:1px solid #e6e8ef; border-radius:12px; overflow:hidden; background:white; transition: transform 0.2s, box-shadow 0.2s;';
          row.onmouseenter = () => { row.style.transform = 'translateY(-2px)'; row.style.boxShadow = '0 4px 12px rgba(0,0,0,0.1)'; };
          row.onmouseleave = () => { row.style.transform = ''; row.style.boxShadow = ''; };
          row.innerHTML = `
            <div style="flex:2; padding:16px; border-right:1px solid #e6e8ef;">
              <div style="font-weight:700; font-size:16px; color:#1f2937; margin-bottom:8px;">${title}</div>
              <div style="display:flex; gap:8px; align-items:center;">
                <span style="display:inline-flex; align-items:center; padding:4px 8px; background:${done ? '#d1fae5' : '#fed7aa'}; color:${done ? '#065f46' : '#92400e'}; border-radius:6px; font-size:12px; font-weight:600;">
                  ${done ? 'âœ“ FÃ¦rdig' : 'âš  Mangler'}
                </span>
              </div>
            </div>
            <div style="flex:1; padding:16px; border-right:1px solid #e6e8ef; background:#fafafa;">
              <div style="font-size:11px; color:#6b7280; margin-bottom:4px; text-transform:uppercase; letter-spacing:0.5px;">Anvendelseskategori</div>
              <div style="font-weight:600; font-size:18px; color:#1f2937;">${ak}</div>
            </div>
            <div style="flex:1; padding:16px; border-right:1px solid #e6e8ef; background:#fafafa;">
              <div style="font-size:11px; color:#6b7280; margin-bottom:4px; text-transform:uppercase; letter-spacing:0.5px;">Risikoklasse</div>
              <div style="font-weight:600; font-size:18px; color:#1f2937;">${rk}</div>
            </div>
            <div style="flex:1; padding:16px; border-right:1px solid #e6e8ef; background:#fafafa;">
              <div style="font-size:11px; color:#6b7280; margin-bottom:4px; text-transform:uppercase; letter-spacing:0.5px;">Bilag</div>
              <div style="font-weight:600; font-size:18px; color:#1f2937;">${bilagRaw}</div>
            </div>
            <div style="flex:1; padding:16px; background:#f0f9ff;">
              <div style="font-size:11px; color:#0369a1; margin-bottom:4px; text-transform:uppercase; letter-spacing:0.5px;">Brandklasse</div>
              <div style="font-weight:700; font-size:24px; color:#0284c7;">${bk}</div>
            </div>
          `;

          row.style.cursor = 'pointer';
          row.onclick = () => {
            setActiveBuildingIndex(bIdx);
            setActiveSectionIndex(i);
            goToStep(buildingsState.buildings[bIdx]?.lastStep?.[i] || 1);
          };

          cont.appendChild(row);
        }
      }

      // Update summary counts
      const sum = document.getElementById('final-summary');
      
      if (sum){
        if (completed === total && total > 0) {
          sum.innerHTML = `<strong>âœ“ Alle ${total} bygningsafsnit er fÃ¦rdige!</strong><br>Du kan nu eksportere dataene eller starte et nyt projekt.`;
          sum.style.background = '#d1fae5';
          sum.style.color = '#065f46';
        } else {
          sum.innerHTML = `<strong>${completed} af ${total} bygningsafsnit er fÃ¦rdige.</strong><br>GÃ¥ tilbage til de manglende afsnit for at fÃ¦rdiggÃ¸re projektet.`;
          sum.style.background = '#fef3c7';
          sum.style.color = '#92400e';
        }
      }
      
      // Update header counts
      document.getElementById('summary-completed-count').textContent = completed;
      document.getElementById('summary-total-count').textContent = total;
      
      // Show next steps guide based on highest brandklasse
      updateNextStepsGuide();
    }
    
    function updateNextStepsGuide() {
      const guideContainer = document.getElementById('next-steps-guide');
      if (!guideContainer) return;
      
      // Collect all evaluations
      const allEvals = [];
      for (let bIdx = 0; bIdx < buildingsState.count; bIdx++) {
        const b = buildingsState.buildings[bIdx];
        if (!b) continue;
        const buildingTitle = buildingsState.titles[bIdx] || `Bygning ${bIdx+1}`;
        for (let i = 0; i < (b.count || 1); i++) {
          const evalRes = b.evaluations[i];
          if (evalRes && evalRes.brandklasse?.value) {
            allEvals.push({
              buildingIndex: bIdx,
              index: i,
              title: `${buildingTitle} â€” ${b.titles[i] || `Bygningsafsnit ${i+1}`}`,
              brandklasse: parseInt(evalRes.brandklasse.value) || null,
              anvendelseskategori: evalRes.anvendelseskategori?.value,
              risikoklasse: evalRes.risikoklasse?.value,
              relevant_bilag: evalRes.relevant_bilag?.value || evalRes.relevant_bilag,
              bygningstype: b.inputData?.[i]?.bygningstype || 'N/A',
              certificeringsniveau: evalRes.bilag_outputs?.brandrÃ¥dgiver_certificeringsniveau || 
                                   evalRes.bilag_outputs?.['brandrÃ¥dgiver_certificeringsniveau'] ||
                                   null
            });
          }
        }
      }
      
      if (allEvals.length === 0) {
        guideContainer.style.display = 'none';
        return;
      }
      
      // Find highest brandklasse (worst case) and corresponding certification level
      const highestBK = Math.max(...allEvals.map(e => e.brandklasse || 0));
      const highestBKSection = allEvals.find(e => e.brandklasse === highestBK);
      const bk1Sections = allEvals.filter(e => e.brandklasse === 1);
      
      guideContainer.style.display = 'block';
      
      if (highestBK === 1) {
        // All sections are Brandklasse 1 - show documentation helper
        const bilagText = bk1Sections[0]?.relevant_bilag ? `bilag ${bk1Sections[0].relevant_bilag}` : 'de prÃ¦-accepterede lÃ¸sninger';
        guideContainer.innerHTML = `
          <div style="border: 2px solid #10b981; border-radius: 12px; overflow: hidden;">
            <div style="background: #10b981; color: white; padding: 20px 24px;">
              <h3 style="margin: 0 0 8px 0; font-size: 20px; font-weight: 700;">âœ… NÃ¦ste skridt: Dokumentation</h3>
              <p style="margin: 0; font-size: 15px; opacity: 0.95;">Dit projekt er indplaceret i <strong>Brandklasse 1</strong></p>
            </div>
            
            <div style="padding: 28px;">
              <p style="margin: 0 0 20px 0; font-size: 15px; color: #0f172a; line-height: 1.7;">
                Dit projekt er indplaceret i <strong>Brandklasse 1</strong> ud fra de prÃ¦-accepterede lÃ¸sninger i henhold til <strong>${bilagText}</strong>. 
                NÃ¦ste skridt er derfor at udfylde dokumentation for dit byggeri og indsende det til kommunalbestyrelsen.
              </p>
              
              <p style="margin: 0 0 24px 0; font-size: 15px; color: #0f172a; line-height: 1.7;">
                VÃ¦rktÃ¸jet her har allerede en del information, der er brugbar til denne udfyldelse, sÃ¥ hvis du Ã¸nsker det, kan det hjÃ¦lpe med at generere dokumentationen.
              </p>
              
              <button id="btn-open-doc-generator" class="btn-primary" style="padding: 14px 28px; font-size: 15px; font-weight: 600;">
                ðŸ“„ Generer dokumentation til kommunalbestyrelsen
              </button>
            </div>
          </div>
        `;
      } else {
        // Brandklasse 2, 3, or 4 - need certified advisor
        // Use the actual certification level from the decision model
        const certLevel = highestBKSection?.certificeringsniveau || highestBK;
        const certRequirement = getCertificationRequirement(certLevel);
        guideContainer.innerHTML = `
          <div style="border: 2px solid #dc2626; border-radius: 12px; overflow: hidden;">
            <div style="background: #dc2626; color: white; padding: 20px 24px;">
              <h3 style="margin: 0 0 8px 0; font-size: 20px; font-weight: 700;">âš ï¸ NÃ¦ste skridt: Kontakt brandrÃ¥dgiver</h3>
              <p style="margin: 0; font-size: 15px; opacity: 0.95;">Dit projekt er indplaceret i <strong>Brandklasse ${highestBK}</strong></p>
            </div>
            
            <div style="padding: 28px;">
              <p style="margin: 0 0 20px 0; font-size: 15px; color: #0f172a; line-height: 1.7;">
                Dit projekt er indplaceret i <strong>Brandklasse ${highestBK}</strong>, hvilket betyder at du skal kontakte en brandrÃ¥dgiver 
                med den korrekte certificering for at udarbejde den nÃ¸dvendige dokumentation.
              </p>
              
              <div style="background: #fef2f2; border: 2px solid #fecaca; border-radius: 10px; padding: 20px; margin-bottom: 24px;">
                <h4 style="margin: 0 0 12px 0; font-size: 16px; font-weight: 700; color: #991b1b;">KrÃ¦vet certificering:</h4>
                <p style="margin: 0; font-size: 15px; color: #7f1d1d; line-height: 1.6;">
                  <strong>${certRequirement}</strong>
                </p>
              </div>
              
              <p style="margin: 0; font-size: 14px; color: #64748b; line-height: 1.6;">
                <strong>BemÃ¦rk:</strong> VÃ¦rktÃ¸jet har givet dig en indledende klassificering, men den endelige vurdering og dokumentation 
                skal udarbejdes af en certificeret brandrÃ¥dgiver. Kontakt en rÃ¥dgiver med ovenstÃ¥ende certificering for at fortsÃ¦tte dit projekt.
              </p>
            </div>
          </div>
        `;
      }
    }
    
    function getCertificationRequirement(certLevel) {
      // certLevel can be a number (2, 3, 4) or a string
      const level = parseInt(certLevel) || certLevel;
      
      if (level === 2 || level === '2') {
        return 'BrandrÃ¥dgiver certificeret til Brandklasse 2 (BK2)';
      } else if (level === 3 || level === '3') {
        return 'BrandrÃ¥dgiver certificeret til Brandklasse 3 (BK3) eller hÃ¸jere';
      } else if (level === 4 || level === '4') {
        return 'BrandrÃ¥dgiver certificeret til Brandklasse 4 (BK4) - hÃ¸jeste certificeringsniveau';
      }
      // Fallback - should not happen if data is correct
      return 'Certificeret brandrÃ¥dgiver';
    }

    function updateStatus(){
      const d = new Date();
      const hh = String(d.getHours()).padStart(2,'0');
      const mm = String(d.getMinutes()).padStart(2,'0');
      document.getElementById('status-line').textContent = `Sidst opdateret: ${hh}:${mm}`;
    }
    
    function openDocGeneratorOverlay() {
      const overlay = document.getElementById('doc-generator-overlay');
      if (!overlay) return;

      // Cross-field sync state (avoid left/right override loops)
      if (!overlay.__docSyncState) {
        overlay.__docSyncState = { syncingFromInputs: false, syncingFromDraft: false, draftSyncTimer: null };
      }

      const liveText = document.getElementById('doc-live-text');
      const refreshBtn = document.getElementById('doc-gen-refresh');
      const placeholderRoot = document.getElementById('doc-placeholder-fields');
      const placeholderSummary = document.getElementById('doc-placeholder-summary');

      const getProjectInfoFromInputs = () => ({
        projektnavn: (document.getElementById('doc-projektnavn')?.value || '').trim(),
        adresse: (document.getElementById('doc-adresse')?.value || '').trim(),
        bygherre: (document.getElementById('doc-bygherre')?.value || '').trim(),
        raadgiver: (document.getElementById('doc-raadgiver')?.value || '').trim(),
      });

      const normalizePlaceholderLabel = (label) => {
        return String(label || '')
          .replace(/\s+/g, ' ')
          .replace(/\u00A0/g, ' ')
          .trim();
      };

      const placeholderKey = (type, label) => {
        const t = String(type || '').trim().toUpperCase();
        const l = normalizePlaceholderLabel(label).toLowerCase();
        return `${t}:${l}`;
      };

      const extractDocPlaceholders = (text) => {
        const out = [];
        const s = String(text || '');
        const re = /\[(UDFYLD|VEDLÃ†G):\s*([\s\S]*?)\]/g;
        let m;
        while ((m = re.exec(s)) !== null) {
          const type = String(m[1] || '').trim().toUpperCase();
          const rawLabel = String(m[2] || '');
          const label = normalizePlaceholderLabel(rawLabel);
          const token = m[0];
          if (!label) continue;

          // Avoid duplicating the 4 header placeholders already covered by Projektinformation.
          const headerLabels = new Set([
            'projektnavn',
            'adresse/matrikel',
            'adresse og matrikel',
            'adresse',
            'bygherre',
            'rÃ¥dgiver',
            'raadgiver'
          ]);
          if (type === 'UDFYLD' && headerLabels.has(label.toLowerCase())) continue;

          out.push({ type, label, token, key: placeholderKey(type, label) });
        }

        // De-duplicate by key (keep the first occurrence's token for replacement)
        const seen = new Set();
        const uniq = [];
        for (const p of out) {
          if (seen.has(p.key)) continue;
          seen.add(p.key);
          uniq.push(p);
        }
        return uniq;
      };

      const ensurePlaceholderState = () => {
        if (!overlay.__docPlaceholderState) {
          overlay.__docPlaceholderState = {
            values: {},
            attachments: {},
            placeholders: null,
            baseDraft: null,
            renderTimer: null,
            applyTimer: null
          };
        }
        return overlay.__docPlaceholderState;
      };

      const ACCEPT_ATTACHMENT_TYPES = '.pdf,.png,.jpg,.jpeg';

      const getAttachmentFilesFor = (key) => {
        const state = ensurePlaceholderState();
        const entry = state.attachments?.[key];
        if (!entry || !Array.isArray(entry.files)) return [];
        return entry.files;
      };

      const setAttachmentFilesFor = (key, files) => {
        const state = ensurePlaceholderState();
        state.attachments[key] = { files: Array.isArray(files) ? files : [] };
      };

      const formatVedlaegReplacementText = (placeholder, files) => {
        const p = placeholder;
        const list = Array.isArray(files) ? files : [];
        if (list.length === 0) return '';

        const isMulti = /brandplan|brandtegning|brandtegn/i.test(String(p?.label || ''));
        const formatOne = (f) => {
          const name = f?.file?.name || f?.name || '';
          const caption = String(f?.caption || '').trim();
          if (!name) return '';
          return caption ? `${name} â€” ${caption}` : name;
        };

        if (!isMulti) {
          const line = formatOne(list[0]);
          return line ? `Vedlagt: ${line}` : '';
        }

        const lines = list.map(formatOne).filter(Boolean);
        if (lines.length === 0) return '';
        return ['Vedlagte filer:', ...lines.map(l => `- ${l}`)].join('\n');
      };

      const updateVedlaegValueForPlaceholder = (placeholder) => {
        const state = ensurePlaceholderState();
        const files = getAttachmentFilesFor(placeholder.key);
        const text = formatVedlaegReplacementText(placeholder, files);
        if (text) state.values[placeholder.key] = text;
        else state.values[placeholder.key] = '';
      };

      const setBaseDraftIfPossible = (nextBaseDraft) => {
        const state = ensurePlaceholderState();
        const s = String(nextBaseDraft || '');
        if (!s.trim()) return;
        state.baseDraft = s;
        state.placeholders = extractDocPlaceholders(s);
      };

      const getStablePlaceholders = () => {
        const state = ensurePlaceholderState();
        if (Array.isArray(state.placeholders)) return state.placeholders;
        // Fallback: derive from current draft once.
        const derived = extractDocPlaceholders(liveText?.value || '');
        state.placeholders = derived;
        return derived;
      };

      const updatePlaceholderSummaryText = () => {
        const state = ensurePlaceholderState();
        const placeholders = getStablePlaceholders();
        if (!placeholderSummary) return;
        if (!placeholders.length) {
          placeholderSummary.textContent = 'Ingen [UDFYLD: â€¦] / [VEDLÃ†G: â€¦] felter fundet i udkastet.';
          return;
        }
        let missingCount = 0;
        for (const p of placeholders) {
          if (p.type === 'VEDLÃ†G') {
            const files = getAttachmentFilesFor(p.key);
            if (!files.length) missingCount++;
          } else {
            const currentVal = String(state.values?.[p.key] ?? '').trim();
            if (!currentVal) missingCount++;
          }
        }
        placeholderSummary.textContent = `Manglende udfyldning: ${missingCount} / ${placeholders.length}`;
      };

      const applyPlaceholderValuesIntoDraft = () => {
        if (!liveText) return;
        if (!placeholderRoot) return;
        if (overlay.__docSyncState?.syncingFromDraft) return;

        const state = ensurePlaceholderState();
        const placeholders = getStablePlaceholders();
        if (!placeholders.length) return;

        const base = (state.baseDraft && String(state.baseDraft).trim().length > 0)
          ? state.baseDraft
          : liveText.value;

        const s0 = liveText.selectionStart;
        const s1 = liveText.selectionEnd;

        overlay.__docSyncState.syncingFromInputs = true;
        try {
          let next = String(base);
          for (const p of placeholders) {
            const value = String(state.values?.[p.key] ?? '').trim();
            if (!value) continue;
            // Replace all occurrences of the *current* token string.
            next = next.split(p.token).join(value);
          }
          liveText.value = next;
          liveText.setAttribute('data-dirty', 'true');
        } finally {
          overlay.__docSyncState.syncingFromInputs = false;
        }

        try {
          if (typeof s0 === 'number' && typeof s1 === 'number') {
            liveText.setSelectionRange(Math.min(s0, liveText.value.length), Math.min(s1, liveText.value.length));
          }
        } catch(_) {}
      };

      const renderDocPlaceholderInputs = () => {
        if (!placeholderRoot || !liveText) return;
        const state = ensurePlaceholderState();

        const placeholders = getStablePlaceholders();
        placeholderRoot.innerHTML = '';

        if (!placeholders.length) {
          if (placeholderSummary) placeholderSummary.textContent = 'Ingen [UDFYLD: â€¦] / [VEDLÃ†G: â€¦] felter fundet i udkastet.';
          const empty = document.createElement('div');
          empty.className = 'muted';
          empty.style.marginTop = '10px';
          empty.textContent = 'NÃ¥r udkastet indeholder udfyldningsfelter, vises de her.';
          placeholderRoot.appendChild(empty);
          return;
        }

        const buildStep3DocsSummary = () => {
          const box = document.createElement('div');
          box.style.marginTop = '12px';
          box.style.border = '1px solid #e2e8f0';
          box.style.borderRadius = '12px';
          box.style.padding = '12px';
          box.style.background = '#f8fafc';

          const title = document.createElement('div');
          title.style.fontWeight = '700';
          title.style.color = '#0f172a';
          title.textContent = 'Bilag fra trin 3 (tilknyttet krav)';

          const sub = document.createElement('div');
          sub.className = 'muted';
          sub.style.marginTop = '4px';
          sub.style.lineHeight = '1.5';
          sub.textContent = 'Bilag du har uploadet ud for krav/kravgrupper i trin 3. RedigÃ©r/tilfÃ¸j bilag i trin 3.';

          const list = document.createElement('div');
          list.style.marginTop = '10px';

          const collectDocsAcrossBuildings = () => {
            const out = [];
            const buildingCount = Number.isFinite(Number(buildingsState?.count))
              ? Number(buildingsState.count)
              : (buildingsState?.buildings ? Object.keys(buildingsState.buildings).length : 1);

            for (let b = 0; b < buildingCount; b++) {
              const st = buildingsState?.buildings?.[b];
              if (!st) continue;
              const sectionCount = Number.isFinite(Number(st.count)) ? Number(st.count) : 0;
              for (let i = 0; i < sectionCount; i++) {
                const docsByCategory = st.kravCategoryDocs?.[String(i)] || {};
                const order = st.kravCategoryOrder?.[String(i)];
                const categories = sortCategoryLabelsByOrder(
                  Object.keys(docsByCategory)
                    .filter(k => Array.isArray(docsByCategory[k]) && docsByCategory[k].length > 0),
                  order
                );
                if (!categories.length) continue;

                const evalRes = st.evaluations?.[i];
                const bk = (evalRes && evalRes.brandklasse?.value !== undefined) ? evalRes.brandklasse.value : (evalRes?.brandklasse ?? null);

                out.push({
                  buildingIndex: b,
                  sectionIndex: i,
                  sectionTitle: st.titles?.[i] || `Bygningsafsnit ${i+1}`,
                  brandklasse: bk,
                  docsByCategory
                });
              }
            }
            return out;
          };

          const entries = collectDocsAcrossBuildings();
          if (!entries.length) {
            const empty = document.createElement('div');
            empty.className = 'muted';
            empty.textContent = 'Ingen bilag tilfÃ¸jet i trin 3 endnu.';
            list.appendChild(empty);
          } else {
            for (const entry of entries) {
              const sectionHdr = document.createElement('div');
              sectionHdr.style.fontWeight = '700';
              sectionHdr.style.marginTop = '10px';

              const bkTxt = (entry.brandklasse !== null && entry.brandklasse !== undefined && String(entry.brandklasse).trim() !== '')
                ? ` (BK${entry.brandklasse})`
                : '';
              sectionHdr.textContent = `Bygning ${entry.buildingIndex + 1} / Bygningsafsnit ${entry.sectionIndex + 1}: ${entry.sectionTitle}${bkTxt}`;
              list.appendChild(sectionHdr);

              const cats = Object.keys(entry.docsByCategory)
                .filter(k => Array.isArray(entry.docsByCategory[k]) && entry.docsByCategory[k].length > 0)
                .slice();

              const catsOrdered = sortCategoryLabelsByOrder(cats, buildingsState?.buildings?.[entry.buildingIndex]?.kravCategoryOrder?.[String(entry.sectionIndex)]);

              for (const cat of catsOrdered) {
                const catEl = document.createElement('div');
                catEl.style.marginTop = '6px';
                catEl.style.fontWeight = '600';
                catEl.textContent = cat;
                list.appendChild(catEl);

                const ul = document.createElement('ul');
                ul.style.margin = '6px 0 0 18px';
                ul.style.padding = '0';
                for (const d of (entry.docsByCategory[cat] || [])) {
                  const li = document.createElement('li');
                  const name = String(d?.name || 'fil');
                  const caption = String(d?.caption || '').trim();
                  const desc = String(d?.description || '').trim();
                  li.textContent = caption ? `${name} â€” ${caption}` : name;
                  if (desc) {
                    const div = document.createElement('div');
                    div.className = 'muted';
                    div.style.marginTop = '2px';
                    div.textContent = desc;
                    li.appendChild(div);
                  }
                  ul.appendChild(li);
                }
                list.appendChild(ul);
              }
            }
          }

          box.appendChild(title);
          box.appendChild(sub);
          box.appendChild(list);
          return box;
        };

        let insertedStep3Docs = false;

        for (const p of placeholders) {
          const currentVal = String(state.values?.[p.key] ?? '').trim();

          const wrapper = document.createElement('div');
          wrapper.className = 'form-field';

          const label = document.createElement('label');
          const typePrefix = (p.type === 'VEDLÃ†G') ? 'VedlÃ¦g' : 'Udfyld';
          if (p.type === 'VEDLÃ†G') {
            const raw = String(p.label || '').trim();
            if (/^situationsplan\b/i.test(raw)) {
              label.textContent = 'VedlÃ¦g situationsplan';
            } else if (/^brandplan/i.test(raw) || /^brandplaner/i.test(raw) || /brandtegning|brandtegn/i.test(raw)) {
              label.textContent = 'VedlÃ¦g brandplaner';
            } else {
              label.textContent = `${typePrefix}: ${p.label}`;
            }
          } else {
            label.textContent = `${typePrefix}: ${p.label}`;
          }
          wrapper.appendChild(label);

          const wantsYesNo = /\bja\s*\/\s*nej\b/i.test(p.label);
          const useTextarea = (!wantsYesNo) && (p.label.length > 80 || /\bbeskriv\b|\bsuppl[Ã©e]r\b|\bforuds[Ã¦a]tninger\b/i.test(p.label));

          let input;

          const addHelpText = (text) => {
            const t = String(text || '').trim();
            if (!t) return;
            const help = document.createElement('div');
            help.className = 'muted';
            help.style.marginTop = '2px';
            help.style.lineHeight = '1.5';
            help.textContent = t;
            wrapper.appendChild(help);
          };

          // Guidance for the notat field (shown above the textarea)
          if (p.type === 'UDFYLD' && /^notat\b/i.test(String(p.label || '').trim())) {
            addHelpText('For overskuelighedens skyld bÃ¸r der herudover vedlÃ¦gges et notat, som beskriver, hvorledes afstandsforhold, bÃ¦rende konstruktioner, indvendige og udvendige overflader samt redningsberedskabets indsatsforhold udfÃ¸res i henhold til de prÃ¦-accepterede lÃ¸sninger.');
          }

          if (p.type === 'VEDLÃ†G') {
            // Render upload UI + per-file caption, and auto-insert into draft.
            const isMulti = /brandplan|brandtegning|brandtegn/i.test(String(p.label || ''));
            const isSituationsplan = /^situationsplan\b/i.test(String(p.label || '').trim());

            if (isSituationsplan) {
              addHelpText('Dokumentationen skal endvidere omfatte relevant tegningsmateriale, herunder en situationsplan, der viser bygningernes placering pÃ¥ ejendommen i forhold til anden bebyggelse, naboskel samt vej- og stimidte.');
            } else if (isMulti) {
              addHelpText('Der skal desuden udarbejdes en brandplan, som viser bygningens eventuelle opdeling i brandmÃ¦ssige enheder samt placering af rÃ¸galarmer og eventuelle redningsÃ¥bninger.');
            }

            const box = document.createElement('div');
            box.className = 'doc-attachment-box';

            const row = document.createElement('div');
            row.className = 'doc-attachment-row';

            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = ACCEPT_ATTACHMENT_TYPES;
            fileInput.multiple = !!isMulti;

            const hint = document.createElement('div');
            hint.className = 'muted';
            hint.style.fontSize = '12px';
            hint.textContent = isMulti
              ? 'Upload Ã©n eller flere filer (PDF/JPG/PNG). TilfÃ¸j billedtekst pr. fil.'
              : 'Upload en fil (PDF/JPG/PNG) og angiv en billedtekst.';

            row.appendChild(fileInput);
            box.appendChild(row);
            box.appendChild(hint);

            const list = document.createElement('div');
            list.className = 'doc-attachment-list';
            box.appendChild(list);

            const renderList = () => {
              list.innerHTML = '';
              const files = getAttachmentFilesFor(p.key);
              if (!files.length) {
                const empty = document.createElement('div');
                empty.className = 'muted';
                empty.textContent = 'Ingen filer valgt endnu.';
                list.appendChild(empty);
                return;
              }

              files.forEach((f, idx) => {
                const item = document.createElement('div');
                item.className = 'doc-attachment-item';

                const meta = document.createElement('div');
                meta.className = 'doc-attachment-meta';

                const left = document.createElement('div');
                const fname = f?.file?.name || f?.name || '';
                const ftype = f?.file?.type || f?.type || '';
                left.textContent = fname || `Fil ${idx + 1}`;

                const right = document.createElement('div');
                right.className = 'muted';
                right.textContent = ftype ? ftype : '';

                meta.appendChild(left);
                meta.appendChild(right);
                item.appendChild(meta);

                const caption = document.createElement('input');
                caption.type = 'text';
                caption.placeholder = 'Billedtekst (valgfri)â€¦';
                caption.value = String(f?.caption || '');
                caption.addEventListener('input', () => {
                  const next = getAttachmentFilesFor(p.key);
                  if (!next[idx]) return;
                  next[idx].caption = String(caption.value || '');
                  setAttachmentFilesFor(p.key, next);
                  updateVedlaegValueForPlaceholder(p);
                  scheduleApplyPlaceholdersIntoDraft();
                });
                item.appendChild(caption);

                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'btn-secondary';
                removeBtn.textContent = 'Fjern fra dokument';
                removeBtn.addEventListener('click', () => {
                  const next = getAttachmentFilesFor(p.key).slice();
                  next.splice(idx, 1);
                  setAttachmentFilesFor(p.key, next);
                  updateVedlaegValueForPlaceholder(p);
                  applyPlaceholderValuesIntoDraft();
                  updatePlaceholderSummaryText();
                  renderList();
                });
                item.appendChild(removeBtn);

                list.appendChild(item);
              });
            };

            fileInput.addEventListener('change', async () => {
              let chosen = Array.from(fileInput.files || []);
              try {
                const pdfs = chosen.filter(f => f && ((String(f.type || '').toLowerCase() === 'application/pdf') || /\.pdf$/i.test(String(f.name || ''))));
                if (pdfs.length > 0) {
                  const ok = confirm('PDF-bilag bliver konverteret til billede (side 1) for at kunne indgÃ¥ i eksport. FortsÃ¦t?');
                  if (ok) {
                    const out = [];
                    for (const f of chosen) {
                      if (f && ((String(f.type || '').toLowerCase() === 'application/pdf') || /\.pdf$/i.test(String(f.name || '')))) {
                        try {
                          const img = await pdfFileToPngFile(f, { pageNumber: 1, scale: 2 });
                          out.push(img);
                        } catch(err) {
                          out.push(f);
                        }
                      } else {
                        out.push(f);
                      }
                    }
                    chosen = out;
                  }
                }
              } catch(_) {}

              const current = getAttachmentFilesFor(p.key);

              // Replace selection (predictable) while attempting to keep existing captions if same filename.
              const next = chosen.map(file => {
                const prev = current.find(x => (x?.file?.name || x?.name) === file.name);
                return { file, name: file.name, type: file.type, caption: prev ? String(prev.caption || '') : '' };
              });

              setAttachmentFilesFor(p.key, next);
              updateVedlaegValueForPlaceholder(p);
              applyPlaceholderValuesIntoDraft();
              updatePlaceholderSummaryText();
              renderList();
            });

            // Initialize from any existing state
            updateVedlaegValueForPlaceholder(p);
            renderList();

            wrapper.appendChild(box);
            placeholderRoot.appendChild(wrapper);
            continue;
          }

          if (wantsYesNo) {
            const sel = document.createElement('select');
            sel.innerHTML = '<option value="" selected>VÃ¦lgâ€¦</option><option value="JA">JA</option><option value="NEJ">NEJ</option>';
            sel.value = currentVal;
            sel.addEventListener('change', () => {
              state.values[p.key] = String(sel.value || '').trim();
              applyPlaceholderValuesIntoDraft();
              updatePlaceholderSummaryText();
            });
            input = sel;
          } else if (useTextarea) {
            const ta = document.createElement('textarea');
            ta.placeholder = 'Skriv tekstâ€¦';
            ta.value = currentVal;
            ta.addEventListener('input', () => {
              state.values[p.key] = String(ta.value || '');
              // Donâ€™t replace continuously while typing large text; apply on a short debounce.
              scheduleApplyPlaceholdersIntoDraft();
            });
            input = ta;
          } else {
            const inp = document.createElement('input');
            inp.type = 'text';
            inp.placeholder = 'Skriv tekstâ€¦';
            inp.value = currentVal;
            inp.addEventListener('input', () => {
              state.values[p.key] = String(inp.value || '');
              scheduleApplyPlaceholdersIntoDraft();
            });
            input = inp;
          }

          wrapper.appendChild(input);
          placeholderRoot.appendChild(wrapper);

          // Insert trin-3 bilag summary right after the â€œNotat om brandteknisk udfÃ¸relseâ€ field.
          if (!insertedStep3Docs && p.type === 'UDFYLD') {
            const lbl = String(p.label || '').toLowerCase();
            if (lbl.includes('notat om brandteknisk udfÃ¸relse') || lbl.includes('notat om brandteknisk udfoerelse')) {
              placeholderRoot.appendChild(buildStep3DocsSummary());
              insertedStep3Docs = true;
            }
          }
        }

        // Fallback: if the notat field wasn't present, still show the summary at the end.
        if (!insertedStep3Docs) {
          placeholderRoot.appendChild(buildStep3DocsSummary());
        }

        updatePlaceholderSummaryText();
      };

      const scheduleRenderDocPlaceholderInputs = () => {
        const state = ensurePlaceholderState();
        if (state.renderTimer) clearTimeout(state.renderTimer);
        state.renderTimer = setTimeout(() => {
          state.renderTimer = null;
          renderDocPlaceholderInputs();
        }, 120);
      };

      const scheduleApplyPlaceholdersIntoDraft = () => {
        if (!overlay.__docSyncState) return;
        const state = ensurePlaceholderState();
        if (state.applyTimer) clearTimeout(state.applyTimer);
        state.applyTimer = setTimeout(() => {
          state.applyTimer = null;
          applyPlaceholderValuesIntoDraft();
          updatePlaceholderSummaryText();
        }, 250);
      };

      const syncHeaderIntoDraft = () => {
        if (!liveText) return;
        if (overlay.__docSyncState?.syncingFromDraft) return;
        const projectInfo = getProjectInfoFromInputs();
        const s0 = liveText.selectionStart;
        const s1 = liveText.selectionEnd;
        overlay.__docSyncState.syncingFromInputs = true;
        liveText.value = updateDocHeaderLines(liveText.value, projectInfo);
        overlay.__docSyncState.syncingFromInputs = false;
        try {
          if (typeof s0 === 'number' && typeof s1 === 'number') {
            liveText.setSelectionRange(Math.min(s0, liveText.value.length), Math.min(s1, liveText.value.length));
          }
        } catch(_) {}
      };

      const syncInputsFromDraftHeader = () => {
        if (!liveText) return;
        if (overlay.__docSyncState?.syncingFromInputs) return;
        const parsed = parseProjectInfoFromDraft(liveText.value || '');
        if (!parsed) return;

        const fields = [
          ['doc-projektnavn', 'projektnavn'],
          ['doc-adresse', 'adresse'],
          ['doc-bygherre', 'bygherre'],
          ['doc-raadgiver', 'raadgiver'],
        ];

        overlay.__docSyncState.syncingFromDraft = true;
        try {
          fields.forEach(([id, key]) => {
            const el = document.getElementById(id);
            if (!el) return;
            const nextVal = String(parsed[key] || '').trim();
            if (!nextVal) return;
            if (el.value !== nextVal) el.value = nextVal;
          });
        } finally {
          overlay.__docSyncState.syncingFromDraft = false;
        }
      };

      const scheduleSyncInputsFromDraftHeader = () => {
        if (!overlay.__docSyncState) return;
        if (overlay.__docSyncState.draftSyncTimer) clearTimeout(overlay.__docSyncState.draftSyncTimer);
        overlay.__docSyncState.draftSyncTimer = setTimeout(() => {
          overlay.__docSyncState.draftSyncTimer = null;
          syncInputsFromDraftHeader();
        }, 200);
      };
      
      // Collect BK1 section data (across all buildings)
      const bk1Sections = collectBk1SectionsAcrossBuildings();
      
      if (bk1Sections.length === 0) {
        alert('Ingen bygningsafsnit er klassificeret som Brandklasse 1.');
        return;
      }
      
      // Populate preview with first section's data
      const firstSection = bk1Sections[0];
      const today = new Date().toLocaleDateString('da-DK');
      document.getElementById('doc-preview-dato').textContent = today;
      
      const bygningstype = firstSection.inputs.bygningstype || 'N/A';
      document.getElementById('doc-preview-bygningstype').textContent = 
        bygningstype.charAt(0).toUpperCase() + bygningstype.slice(1);
      
      document.getElementById('doc-preview-ak').textContent = 
        firstSection.data.anvendelseskategori?.value || 'N/A';
      
      document.getElementById('doc-preview-rk').textContent = 
        firstSection.data.risikoklasse?.value || 'N/A';

      // Populate/refresh the editable draft (right side)
      if (liveText) {
        const projectInfo = getProjectInfoFromInputs();
        const isDirty = liveText.getAttribute('data-dirty') === 'true';
        if (!liveText.value.trim() || !isDirty) {
          const draft = buildDocumentTextWithProjectInfo(bk1Sections, [], {
            projektnavn: projectInfo.projektnavn || '[UDFYLD: Projektnavn]',
            adresse: projectInfo.adresse || '[UDFYLD: Adresse/Matrikel]',
            bygherre: projectInfo.bygherre || '[UDFYLD: Bygherre]',
            raadgiver: projectInfo.raadgiver || '[UDFYLD: RÃ¥dgiver]',
          });
          liveText.value = draft;
          liveText.setAttribute('data-dirty', 'false');
          // Store a stable base draft for placeholder replacement.
          try { setBaseDraftIfPossible(draft); } catch (_) {}
        } else {
          // If user has edited, prefer the draft as source of truth for the header.
          syncInputsFromDraftHeader();
          // If the current draft still contains placeholders, treat it as the new base.
          try {
            const txt = String(liveText.value || '');
            if (/\[(UDFYLD|VEDLÃ†G):/i.test(txt)) setBaseDraftIfPossible(txt);
          } catch (_) {}
        }
      }

      // Build/refresh the placeholder input list (left side)
      try { renderDocPlaceholderInputs(); } catch (_) {}

      // One-time wiring for the editor controls
      if (!overlay.__docOverlayWired) {
        overlay.__docOverlayWired = true;

        // Mark dirty on manual edits
        if (liveText) {
          liveText.addEventListener('input', () => {
            liveText.setAttribute('data-dirty', 'true');
            scheduleSyncInputsFromDraftHeader();
            // Update the placeholder list when the user edits the draft.
            scheduleRenderDocPlaceholderInputs();
          });
        }

        // Keep header lines in sync when user edits left inputs
        ['doc-projektnavn', 'doc-adresse', 'doc-bygherre', 'doc-raadgiver'].forEach((id) => {
          const el = document.getElementById(id);
          if (!el) return;
          el.addEventListener('input', syncHeaderIntoDraft);
          el.addEventListener('change', syncHeaderIntoDraft);
        });

        // Refresh draft button
        if (refreshBtn) {
          refreshBtn.addEventListener('click', () => {
            const liveText2 = document.getElementById('doc-live-text');
            if (!liveText2) return;
            // Recompute BK1 sections on refresh (across all buildings)
            const bk1 = collectBk1SectionsAcrossBuildings();
            const p = getProjectInfoFromInputs();
            liveText2.value = buildDocumentTextWithProjectInfo(bk1, [], {
              projektnavn: p.projektnavn || '[UDFYLD: Projektnavn]',
              adresse: p.adresse || '[UDFYLD: Adresse/Matrikel]',
              bygherre: p.bygherre || '[UDFYLD: Bygherre]',
              raadgiver: p.raadgiver || '[UDFYLD: RÃ¥dgiver]',
            });
            liveText2.setAttribute('data-dirty', 'false');

            // Reset base draft for placeholder replacement and refresh the list.
            try { setBaseDraftIfPossible(liveText2.value); } catch (_) {}

            // Re-render placeholders after refresh
            try { renderDocPlaceholderInputs(); } catch (_) {}
          });
        }
      }
      
      // Show overlay
      overlay.style.display = 'flex';
      overlay.setAttribute('aria-hidden', 'false');
      
      // Focus first input
      setTimeout(() => {
        document.getElementById('doc-projektnavn')?.focus();
      }, 100);
    }
    
    function closeDocGeneratorOverlay() {
      const overlay = document.getElementById('doc-generator-overlay');
      if (!overlay) return;
      
      overlay.style.display = 'none';
      overlay.setAttribute('aria-hidden', 'true');
    }

    function collectBk1SectionsAcrossBuildings() {
      const out = [];
      const buildingCount = Number.isFinite(Number(buildingsState?.count))
        ? Number(buildingsState.count)
        : (buildingsState?.buildings ? Object.keys(buildingsState.buildings).length : 1);

      for (let b = 0; b < buildingCount; b++) {
        const st = buildingsState?.buildings?.[b];
        if (!st) continue;
        const sectionCount = Number.isFinite(Number(st.count)) ? Number(st.count) : 0;

        for (let i = 0; i < sectionCount; i++) {
          const evalRes = st.evaluations?.[i];
          if (evalRes && (evalRes.brandklasse?.value === '1' || evalRes.brandklasse?.value === 1)) {
            out.push({
              buildingIndex: b,
              sectionIndex: i,
              title: st.titles?.[i] || `Bygningsafsnit ${i+1}`,
              data: evalRes,
              inputs: st.inputData?.[i] || {},
              kravCategoryDocs: st.kravCategoryDocs?.[String(i)] || {},
              kravCategoryOrder: st.kravCategoryOrder?.[String(i)] || []
            });
          }
        }
      }

      return out;
    }
    
    async function generateDocumentFromOverlay() {
      // If the user has typed header fields directly in the draft, make sure the left inputs reflect it.
      const liveTextDraft = document.getElementById('doc-live-text');
      const overlay = document.getElementById('doc-generator-overlay');
      if (liveTextDraft && overlay && overlay.__docSyncState && liveTextDraft.getAttribute('data-dirty') === 'true') {
        try {
          const parsed = parseProjectInfoFromDraft(liveTextDraft.value || '');
          if (parsed) {
            overlay.__docSyncState.syncingFromDraft = true;
            [['doc-projektnavn','projektnavn'],['doc-adresse','adresse'],['doc-bygherre','bygherre'],['doc-raadgiver','raadgiver']].forEach(([id, key]) => {
              const el = document.getElementById(id);
              if (!el) return;
              const nextVal = String(parsed[key] || '').trim();
              if (!nextVal) return;
              el.value = nextVal;
            });
          }
        } catch(_) {}
        finally {
          overlay.__docSyncState.syncingFromDraft = false;
        }
      }

      // NOTE: Exports should work even if not all fields are filled.
      const projektnavn = (document.getElementById('doc-projektnavn')?.value || '').trim();
      const adresse = (document.getElementById('doc-adresse')?.value || '').trim();
      const bygherre = (document.getElementById('doc-bygherre')?.value || '').trim();
      const raadgiver = (document.getElementById('doc-raadgiver')?.value || '').trim();
      
      // Collect BK1 sections (across all buildings)
      const bk1Sections = collectBk1SectionsAcrossBuildings();

      const liveText = document.getElementById('doc-live-text');
      const projectInfo = {
        projektnavn: projektnavn || 'â€”',
        adresse: adresse || 'â€”',
        bygherre: bygherre || 'â€”',
        raadgiver: raadgiver || 'â€”'
      };

      // If the user has edited the draft, download as-is (only sync header lines first).
      if (liveText && liveText.value.trim() && liveText.getAttribute('data-dirty') === 'true') {
        const finalText = updateDocHeaderLines(liveText.value, projectInfo);
        const today = new Date().toLocaleDateString('da-DK');
        const safeName = (projektnavn || 'projekt').replace(/[^a-zA-Z0-9]/g, '_');
        const blob = new Blob([finalText], {type: 'text/plain;charset=utf-8'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `BK1_Dokumentation_${safeName}_${today.replace(/\./g, '-')}.txt`;
        a.click();
        URL.revokeObjectURL(url);
        closeDocGeneratorOverlay();
        return;
      }
      
      // Fetch explanations for all sections
      const explanationPromises = bk1Sections.map(async section => {
        try {
          const resp = await fetch(`${API_BASE}/generate-explanation`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
              inputs: section.inputs,
              results: section.data
            })
          });
          if (resp.ok) {
            const data = await resp.json();
            return data.explanation;
          }
        } catch (e) {
          console.error('Failed to fetch explanation:', e);
        }
        return null;
      });
      
      const explanations = await Promise.all(explanationPromises);

      // Generate document text (and populate the draft textarea for visibility)
      const generated = buildDocumentTextWithProjectInfo(bk1Sections, explanations, projectInfo);
      if (liveText) {
        liveText.value = generated;
        liveText.setAttribute('data-dirty', 'false');
      }

      // Download the generated version
      const today = new Date().toLocaleDateString('da-DK');
      const safeName = (projektnavn || 'projekt').replace(/[^a-zA-Z0-9]/g, '_');
      const blob = new Blob([generated], {type: 'text/plain;charset=utf-8'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `BK1_Dokumentation_${safeName}_${today.replace(/\./g, '-')}.txt`;
      a.click();
      URL.revokeObjectURL(url);
      
      // Close overlay
      closeDocGeneratorOverlay();
    }

    // ---- Export helpers (HTML/PDF + DOCX) ----
    function getDocOverlayProjectInfoLenient(){
      const projektnavn = (document.getElementById('doc-projektnavn')?.value || '').trim();
      const adresse = (document.getElementById('doc-adresse')?.value || '').trim();
      const bygherre = (document.getElementById('doc-bygherre')?.value || '').trim();
      const raadgiver = (document.getElementById('doc-raadgiver')?.value || '').trim();
      const safeName = (projektnavn || 'projekt').replace(/[^a-zA-Z0-9]/g, '_');
      return {
        projektnavn: projektnavn || 'â€”',
        adresse: adresse || 'â€”',
        bygherre: bygherre || 'â€”',
        raadgiver: raadgiver || 'â€”',
        __safeName: safeName
      };
    }

    function collectAllStep3DocsWithFiles(){
      const out = [];
      const store = getKravDocFileStore();
      const buildingCount = Number.isFinite(Number(buildingsState?.count)) ? Number(buildingsState.count) : 0;
      for (let b = 0; b < buildingCount; b++) {
        const st = buildingsState?.buildings?.[b];
        if (!st) continue;
        const sectionCount = Number.isFinite(Number(st.count)) ? Number(st.count) : 0;
        for (let s = 0; s < sectionCount; s++) {
          const docsByCat = st.kravCategoryDocs?.[String(s)] || {};
          const catsWithDocs = Object.keys(docsByCat || {}).filter(cat => {
            const list = Array.isArray(docsByCat[cat]) ? docsByCat[cat] : [];
            return list.length > 0;
          });
          const orderedCats = sortCategoryLabelsByOrder(catsWithDocs, st.kravCategoryOrder?.[String(s)]);
          for (const cat of orderedCats) {
            const list = Array.isArray(docsByCat[cat]) ? docsByCat[cat] : [];
            for (const meta of list) {
              const id = String(meta?.id || '');
              const file = store[id] || null;
              out.push({
                buildingIndex: b,
                sectionIndex: s,
                sectionTitle: st.titles?.[s] || `Bygningsafsnit ${s + 1}`,
                category: String(cat || '').trim(),
                meta,
                file
              });
            }
          }
        }
      }
      return out;
    }

    function collectOverlayVedlaegWithFiles(){
      const overlay = document.getElementById('doc-generator-overlay');
      const state = overlay?.__docPlaceholderState;
      const attachments = state?.attachments && typeof state.attachments === 'object' ? state.attachments : {};
      const out = [];
      for (const [key, entry] of Object.entries(attachments)) {
        const files = Array.isArray(entry?.files) ? entry.files : [];
        for (const f of files) {
          const file = f?.file || f;
          out.push({
            placeholderKey: String(key || ''),
            name: String(f?.name || file?.name || ''),
            type: String(f?.type || file?.type || ''),
            caption: String(f?.caption || '').trim(),
            file
          });
        }
      }
      return out;
    }

    function buildOverlayVedlaegIndex(items){
      const normalizeKey = (s) => String(s || '')
        .toLowerCase()
        .trim()
        .replace(/\s+/g, '')
        .replace(/[^a-z0-9Ã¦Ã¸Ã¥]/g, '');

      const overlay = document.getElementById('doc-generator-overlay');
      const placeholders = Array.isArray(overlay?.__docPlaceholderState?.placeholders)
        ? overlay.__docPlaceholderState.placeholders
        : [];

      const keyToLabel = {};
      for (const p of placeholders) {
        if (p?.type !== 'VEDLÃ†G') continue;
        const k = String(p.key || '').trim();
        const lbl = String(p.label || '').trim();
        if (k && lbl) keyToLabel[k] = lbl;
      }

      const idx = {};
      const push = (k, it) => {
        if (!k) return;
        (idx[k] ||= []).push(it);
      };

      for (const it of Array.isArray(items) ? items : []) {
        const rawKey = String(it?.placeholderKey || it?.placeholder || it?.key || '').trim();
        const byInternal = normalizeKey(rawKey);
        push(byInternal, it);

        const lbl = keyToLabel[rawKey] || '';
        const byLabel = normalizeKey(lbl);
        push(byLabel, it);
      }

      return idx;
    }

    function buildVedlaegByFileName(items){
      const norm = (s) => String(s || '').trim().toLowerCase();
      const idx = {};
      for (const it of Array.isArray(items) ? items : []) {
        const name = norm(it?.name || it?.file?.name || '');
        if (!name) continue;
        (idx[name] ||= []).push(it);
      }
      return { idx, norm };
    }

    function parseVedlagtFileNameFromLine(line){
      let t = String(line || '').trim();
      t = t.replace(/^Vedlagt\s*:\s*/i, '');
      t = t.replace(/^[-â€¢]\s+/, '');
      // If caption is appended using an em dash or dash, only keep the filename.
      t = t.split(/\s+â€”\s+|\s+-\s+/)[0];
      return String(t || '').trim();
    }

    function fileToDataUrlLocal(file){
      return new Promise((resolve, reject) => {
        try {
          const r = new FileReader();
          r.onload = () => resolve(String(r.result || ''));
          r.onerror = reject;
          r.readAsDataURL(file);
        } catch (e) { reject(e); }
      });
    }

    async function ensureHtml2PdfLoaded(){
      if (window.html2pdf) return window.html2pdf;
      const existing = document.querySelector('script[data-html2pdf="true"]');
      if (!existing) {
        await new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.dataset.html2pdf = 'true';
          s.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js';
          s.onload = resolve;
          s.onerror = reject;
          document.head.appendChild(s);
        });
      } else {
        await new Promise((resolve, reject) => {
          if (window.html2pdf) return resolve();
          existing.addEventListener('load', resolve, { once: true });
          existing.addEventListener('error', reject, { once: true });
        });
      }
      if (!window.html2pdf) throw new Error('Kunne ikke indlÃ¦se PDF biblioteket');
      return window.html2pdf;
    }

    async function ensureJsPdfLoaded(){
      // Prefer an existing jsPDF (may be present via html2pdf bundle), otherwise load it on-demand.
      if (window.jspdf && window.jspdf.jsPDF) return window.jspdf;
      const existing = document.querySelector('script[data-jspdf="true"]');
      if (!existing) {
        await new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.dataset.jspdf = 'true';
          s.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
          s.onload = resolve;
          s.onerror = reject;
          document.head.appendChild(s);
        });
      } else {
        await new Promise((resolve, reject) => {
          if (window.jspdf && window.jspdf.jsPDF) return resolve();
          existing.addEventListener('load', resolve, { once: true });
          existing.addEventListener('error', reject, { once: true });
        });
      }
      if (!window.jspdf || !window.jspdf.jsPDF) throw new Error('Kunne ikke indlÃ¦se jsPDF');
      return window.jspdf;
    }

    function getDocOverlayDraftTextForExport(projectInfo){
      const liveEl = document.getElementById('doc-live-text');
      const overlayEl = document.getElementById('doc-generator-overlay');
      const state = overlayEl && overlayEl.__docPlaceholderState ? overlayEl.__docPlaceholderState : null;

      let text = (liveEl && String(liveEl.value || '').trim()) ? String(liveEl.value || '') : '';
      if (!text && state && String(state.baseDraft || '').trim()) text = String(state.baseDraft || '');

      const placeholders = Array.isArray(state?.placeholders) ? state.placeholders : [];
      const attachments = state?.attachments || {};

      // If placeholders were replaced with a friendly "Vedlagt: ..." text in the live draft,
      // restore the original [VEDLÃ†G: ...] token so exporters can insert images inline.
      if (text && placeholders.length && !/\[(?:VEDLÃ†G|VEDLAEG)\s*:/i.test(text)) {
        for (const p of placeholders) {
          if (p?.type !== 'VEDLÃ†G') continue;
          const entry = attachments?.[p.key];
          const files = Array.isArray(entry?.files) ? entry.files : [];
          if (!files.length) continue;

          let repl = '';
          if (typeof formatVedlaegReplacementText === 'function') {
            repl = String(formatVedlaegReplacementText(p, files) || '').trim();
          } else {
            const name = files?.[0]?.file?.name || files?.[0]?.name || '';
            repl = name ? ('Vedlagt: ' + name) : '';
          }

          if (!repl) continue;
          text = text.split(repl).join(String(p.token || ''));
        }
      }

      if (projectInfo && typeof updateDocHeaderLines === 'function') {
        text = updateDocHeaderLines(text, projectInfo);
      }
      if (typeof normalizeGeneratedDocumentText === 'function') {
        text = normalizeGeneratedDocumentText(text);
      }
      return text;
    }

    async function exportDocOverlayAsPdf(){
      const btn = document.getElementById('doc-gen-export-pdf');
      const prevLabel = btn ? String(btn.textContent || '') : '';
      try {
        if (btn) {
          btn.disabled = true;
          btn.textContent = 'â³ Genererer PDFâ€¦';
        }

        const today = new Date().toLocaleDateString('da-DK');
        const projectInfo = getDocOverlayProjectInfoLenient();

        const draftText = String(getDocOverlayDraftTextForExport(projectInfo) || '').trim()
          ? String(getDocOverlayDraftTextForExport(projectInfo) || '')
          : (() => {
              try {
                const bk1Sections = collectBk1SectionsAcrossBuildings();
                const explanations = (bk1Sections || []).map(() => null);
                return buildDocumentTextWithProjectInfo(bk1Sections, explanations, projectInfo);
              } catch(_) {
                return '';
              }
            })();

        const step3 = collectAllStep3DocsWithFiles();
        const vedlaeg = collectOverlayVedlaegWithFiles();
        const step3ImageItems = step3.filter(x => x?.file && String(x.file.type || '').startsWith('image/'));
        const vedlaegImageItems = vedlaeg.filter(x => x?.file && String(x.file.type || '').startsWith('image/'));

        // Build PDF directly with jsPDF (more reliable than html2canvas capture)
        const jspdfLib = await ensureJsPdfLoaded();
        const { jsPDF } = jspdfLib;
        const doc = new jsPDF({ unit: 'mm', format: 'a4', orientation: 'portrait' });

        const pageW = doc.internal.pageSize.getWidth();
        const pageH = doc.internal.pageSize.getHeight();
        const margin = 14;
        const contentW = pageW - margin * 2;
        let y = margin;

        const ensureSpace = (needMm) => {
          if (y + needMm <= pageH - margin) return;
          doc.addPage();
          y = margin;
        };

        // Header
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(16);
        doc.text('BK1 Dokumentation', margin, y);
        y += 8;
        doc.setFont('helvetica', 'normal');
        doc.setFontSize(10);
        doc.setTextColor(71, 85, 105);
        doc.text('Eksporteret: ' + String(today), margin, y);
        doc.setTextColor(15, 23, 42);
        y += 8;

        const sanitizePdfText = (s) => {
          // jsPDF default fonts don't support box drawing; replace with simple ASCII.
          return String(s || '')
            .replace(/[â•â”]+/g, '------------------------------------------------------------')
            .replace(/[â•‘â”‚]/g, '|')
            .replace(/[â•”â•—â•šâ•â• â•£â•¦â•©â•¬]/g, '+')
            .replace(/[â–¡â– ]/g, '-')
            .replace(/[â€“â€”]/g, '-')
            .replace(/[â€œâ€]/g, '"')
            .replace(/[â€™]/g, "'");
        };

        const normalizeWeirdListLine = (s) => {
          let t = String(s || '');

          // Convert old pseudo-bullets like "%i" to a simple dash bullet.
          t = t.replace(/^\s*%\s*[a-z]\s*/i, '- ');

          // If the line is letter-spaced ("S i t u a t i o n s p l a n"), de-space it.
          // Heuristic: lots of single-letter tokens.
          const trimmed = t.trim();
          const tokens = trimmed.split(/\s+/g);
          const singleCharTokens = tokens.filter(x => x.length === 1).length;
          if (tokens.length >= 10 && singleCharTokens / tokens.length > 0.7) {
            t = trimmed
              .replace(/\s*\(\s*/g, '(')
              .replace(/\s*\)\s*/g, ')')
              .replace(/\s*:\s*/g, ': ')
              .replace(/\s+/g, ' ')
              .replace(/([A-Za-zÃ†Ã˜Ã…Ã¦Ã¸Ã¥0-9])\s(?=[A-Za-zÃ†Ã˜Ã…Ã¦Ã¸Ã¥0-9])/g, '$1');
          }

          // Normalize excessive spacing (but keep indentation after bullets).
          t = t.replace(/^(\s*[-*â€¢]\s+)\s+/g, '$1');
          t = t.replace(/\t/g, '  ');
          return t;
        };

        const normalizeKey = (s) => String(s || '')
          .toLowerCase()
          .trim()
          .replace(/\s+/g, '')
          .replace(/[^a-z0-9Ã¦Ã¸Ã¥]/g, '');

        const extractVedlaegKeyFromLine = (line) => {
          const m = String(line || '').match(/\[(?:VEDLÃ†G|VEDLAEG)\s*:\s*([^\]]+)\]/i);
          return m ? String(m[1] || '').trim() : '';
        };

        const vedlaegByKey = buildOverlayVedlaegIndex(vedlaegImageItems);
        const { idx: vedlaegByFileName, norm: normFileName } = buildVedlaegByFileName(vedlaegImageItems);

        const step3BlocksByCategory = (() => {
          const groups = {};
          for (const it of step3ImageItems) {
            const cat = String(it.category || 'Kravgruppe').trim() || 'Kravgruppe';
            (groups[cat] ||= []).push(it);
          }
          // Keep insertion order from collectAllStep3DocsWithFiles() (already ordered by kravCategoryOrder)
          return groups;
        })();

        const isSeparatorLine = (s) => {
          const t = String(s || '').trim();
          if (!t) return false;
          if (/^[-]{10,}$/.test(t)) return true;
          if (/^[=]{10,}$/.test(t)) return true;
          if (/^[_]{10,}$/.test(t)) return true;
          // Convert common remnants from sanitized box drawing
          if (/^[+|\-=_ ]{10,}$/.test(t)) return true;
          return false;
        };

        const isHeadingLine = (s) => {
          const t = String(s || '').trim();
          if (!t) return false;
          // Numbered headings like "4.1 DOKUMENTATION ..." or "6. NOTAT ..."
          if (/^\d+(?:\.\d+)*\.\s+/.test(t)) return true;
          // Common top-level headings in the draft
          if (/^(PROJEKTINFORMATION|INDHOLDSFORTEGNELSE|TEKNISK INFORMATION)\b/i.test(t)) return true;
          // Uppercase heading lines (avoid short words)
          if (t.length >= 12 && t === t.toUpperCase() && /[A-ZÃ†Ã˜Ã…]/.test(t)) return true;
          // Section labels
          if (/^Bygningsafsnit\s+\d+\s*:/i.test(t)) return true;
          return false;
        };

        const drawHr = () => {
          ensureSpace(6);
          doc.setDrawColor(226, 232, 240);
          doc.setLineWidth(0.4);
          doc.line(margin, y, pageW - margin, y);
          y += 6;
        };

        const setBodyTextStyle = (kind) => {
          if (kind === 'heading') {
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(11.5);
            doc.setTextColor(15, 23, 42);
            return 5.2;
          }
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(10.2);
          doc.setTextColor(15, 23, 42);
          return 4.6;
        };

        const lines = String(draftText || '').split(/\r?\n/);

        const addWrappedText = (text, fontSize, color) => {
          if (text === null || text === undefined) return;
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(fontSize);
          if (color) doc.setTextColor(color[0], color[1], color[2]);
          const parts = String(text).split(/\r?\n/);
          for (const p of parts) {
            const w = doc.splitTextToSize(String(p), contentW);
            for (const ln of w) {
              ensureSpace(4.4);
              doc.text(String(ln), margin, y);
              y += 4.4;
            }
          }
          if (color) doc.setTextColor(15, 23, 42);
        };

        const loadImageSizeFromDataUrl = async (dataUrl) => {
          return await new Promise((resolve, reject) => {
            try {
              const img = new Image();
              img.onload = () => resolve({ width: img.naturalWidth, height: img.naturalHeight });
              img.onerror = () => reject(new Error('Billede kunne ikke indlÃ¦ses'));
              img.src = dataUrl;
            } catch (e) {
              reject(e);
            }
          });
        };

        const addImageBlock = async ({ title, subtitle, caption, file }) => {
          const dataUrl = await fileToDataUrlLocal(file);
          const isPng = /^data:image\/png/i.test(dataUrl);
          const fmt = isPng ? 'PNG' : 'JPEG';
          const dims = await loadImageSizeFromDataUrl(dataUrl);
          const iw = Number(dims?.width) || 1;
          const ih = Number(dims?.height) || 1;
          const ratio = iw / ih;

          // Title
          if (title) {
            ensureSpace(10);
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(12);
            doc.text(String(title), margin, y);
            y += 6;
          }

          // Subtitle
          if (subtitle) {
            addWrappedText(String(subtitle), 9.5, [71, 85, 105]);
            y += 1;
          }

          const maxW = contentW;
          const minBottom = 10;
          let availH = (pageH - margin) - y - minBottom;
          if (availH < 40) {
            doc.addPage();
            y = margin;
            availH = (pageH - margin) - y - minBottom;
          }

          let w = maxW;
          let h = w / ratio;
          if (h > availH) {
            h = availH;
            w = h * ratio;
          }
          w = Math.max(10, w);
          h = Math.max(10, h);

          ensureSpace(h + 8);
          doc.addImage(dataUrl, fmt, margin, y, w, h);
          y += h + 4;

          if (caption) {
            addWrappedText(String(caption), 10, null);
          }
          y += 6;
        };

        let insertedStep3 = false;
        const insertStep3Inline = async () => {
          if (insertedStep3) return;
          if (!step3ImageItems.length) { insertedStep3 = true; return; }
          insertedStep3 = true;

          // Small heading inside brandforhold section
          ensureSpace(10);
          doc.setFont('helvetica', 'bold');
          doc.setFontSize(12);
          doc.text('Bilag til brandforhold (trin 3)', margin, y);
          y += 6;
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(10);
          doc.setTextColor(71, 85, 105);
          doc.text('PDF-bilag bliver konverteret til billede (side 1) ved upload.', margin, y);
          doc.setTextColor(15, 23, 42);
          y += 8;

          let lastCat = '';
          for (const it of step3ImageItems) {
            const cat = String(it.category || 'Kravgruppe').trim() || 'Kravgruppe';
            const name = String(it.meta?.name || it.file?.name || 'bilag');
            const cap = String(it.meta?.caption || '').trim();
            const desc = String(it.meta?.description || '').trim();
            const label = cat + ' â€” Bygning ' + (it.buildingIndex + 1) + ' / Bygningsafsnit ' + (it.sectionIndex + 1) + ': ' + it.sectionTitle;

            const title = (cat !== lastCat) ? ('Kravgruppe: ' + cat) : '';
            const subtitle = desc ? (label + '\n' + desc) : label;
            const caption = cap ? (name + ' â€” ' + cap) : name;
            await addImageBlock({ title, subtitle, caption, file: it.file });
            lastCat = cat;
          }
        };

        let inVedlagteFiler = false;
        for (const rawLine of lines) {
          const line = String(rawLine ?? '');

          // Insert step-3 docs inside the brandforhold section (right before this paragraph)
          if (!insertedStep3 && /Dokumentation\s+for\s+indsatsmÃ¦ssige\s+forhold\s*:/i.test(line)) {
            await insertStep3Inline();
          }

          // Inline Step-4 attachments where placeholders appear
          const vedKey = extractVedlaegKeyFromLine(line);
          if (vedKey) {
            const nk = normalizeKey(vedKey);
            const matches = Array.isArray(vedlaegByKey[nk]) ? vedlaegByKey[nk] : [];
            if (matches.length) {
              let first = true;
              for (const it of matches) {
                const cap = String(it.caption || '').trim();
                const title = first ? ('VedlÃ¦g: ' + vedKey) : '';
                const caption = cap ? (String(it.name || it.file?.name || 'bilag') + ' â€” ' + cap) : String(it.name || it.file?.name || 'bilag');
                await addImageBlock({
                  title,
                  subtitle: it.placeholderKey ? String(it.placeholderKey) : '',
                  caption,
                  file: it.file
                });
                first = false;
              }
              continue; // don't print the placeholder line
            }
          }

          // Fallback: if the draft has replaced the placeholder with "Vedlagt: <filnavn>",
          // insert images based on filename (same robustness as step-3 bilag handling).
          let postLineVedlaegMatches = [];
          const trimmed = String(line || '').trim();
          if (/^Vedlagte\s+filer\s*:/i.test(trimmed)) {
            inVedlagteFiler = true;
          } else if (inVedlagteFiler) {
            if (!trimmed) {
              inVedlagteFiler = false;
            } else if (!/^[-â€¢]\s+/.test(trimmed)) {
              inVedlagteFiler = false;
            }
          }

          if (/^Vedlagt\s*:/i.test(trimmed)) {
            const fname = parseVedlagtFileNameFromLine(trimmed);
            const hits = Array.isArray(vedlaegByFileName[normFileName(fname)]) ? vedlaegByFileName[normFileName(fname)] : [];
            if (hits.length) postLineVedlaegMatches = hits;
          } else if (inVedlagteFiler && /^[-â€¢]\s+/.test(trimmed)) {
            const fname = parseVedlagtFileNameFromLine(trimmed.replace(/^[-â€¢]\s+/, ''));
            const hits = Array.isArray(vedlaegByFileName[normFileName(fname)]) ? vedlaegByFileName[normFileName(fname)] : [];
            if (hits.length) postLineVedlaegMatches = hits;
          }

          if (!line.trim()) {
            ensureSpace(4.6);
            y += 4.6;
            continue;
          }

          let sanitized = sanitizePdfText(line);
          sanitized = normalizeWeirdListLine(sanitized);
          if (isSeparatorLine(sanitized)) {
            drawHr();
            continue;
          }

          const kind = isHeadingLine(sanitized) ? 'heading' : 'body';
          const lh = setBodyTextStyle(kind);
          const wrapped = doc.splitTextToSize(sanitized, contentW);
          for (const wline of wrapped) {
            ensureSpace(lh);
            doc.text(String(wline), margin, y);
            y += lh;
          }

          if (postLineVedlaegMatches.length) {
            let first = true;
            for (const it of postLineVedlaegMatches) {
              const cap = String(it.caption || '').trim();
              const caption = cap ? (String(it.name || it.file?.name || 'bilag') + ' â€” ' + cap) : String(it.name || it.file?.name || 'bilag');
              await addImageBlock({ title: first ? '' : '', subtitle: it.placeholderKey ? String(it.placeholderKey) : '', caption, file: it.file });
              first = false;
            }
          }
        }

        // If user edited away the anchor, still place step-3 docs near the end (but keep them inside the flow).
        if (!insertedStep3) {
          await insertStep3Inline();
        }

        // Any Step-4 attachments not referenced by a placeholder are added at the end.
        const usedVed = new Set();
        // We consider "used" any placeholder that matched; track it via vedlaegByKey being consumed is complex,
        // so just append all remaining if there was no placeholder at all.
        const anyVedPlaceholderInText = /\[(?:VEDLÃ†G|VEDLAEG)\s*:/i.test(String(draftText || ''));
        if (!anyVedPlaceholderInText && vedlaegImageItems.length) {
          doc.addPage();
          y = margin;
          doc.setFont('helvetica', 'bold');
          doc.setFontSize(14);
          doc.text('VedlÃ¦g (trin 4) â€“ ikke placeret i tekst', margin, y);
          y += 10;
          for (const it of vedlaegImageItems) {
            const cap = String(it.caption || '').trim();
            const caption = cap ? (String(it.name || it.file?.name || 'bilag') + ' â€” ' + cap) : String(it.name || it.file?.name || 'bilag');
            await addImageBlock({ title: '', subtitle: String(it.placeholderKey || ''), caption, file: it.file });
          }
        }

        const fileName = `BK1_Dokumentation_${projectInfo.__safeName}_${today.replace(/\./g, '-')}.pdf`;
        doc.save(fileName);

      } finally {
        if (btn) {
          btn.disabled = false;
          btn.textContent = prevLabel || 'ðŸ“„ PDF';
        }
      }
    }

    async function exportDocOverlayAsHtml(){
      // Open immediately to avoid browser blocking
      const win = window.open('', '_blank');
      if (!win) {
        alert('Popup blev blokeret. Tillad popups for at kunne lave Print/PDF.');
        return;
      }

      const today = new Date().toLocaleDateString('da-DK');
      const projectInfo = getDocOverlayProjectInfoLenient();
      win.document.open();
      // Keep this HTML as a single plain string: avoids backticks/template literals and multiline concatenation pitfalls.
      const baseHtml = '<!doctype html><html lang="da"><head><meta charset="utf-8"/>' +
        '<meta name="viewport" content="width=device-width, initial-scale=1"/>' +
        '<title>BK1 Dokumentation</title>' +
        '<style>' +
          'body{ font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 24px; color:#0f172a; }' +
          'pre{ white-space: pre-wrap; word-wrap: break-word; background:#fff; border:1px solid #e2e8f0; border-radius:12px; padding:16px; }' +
          'h1,h2,h3{ margin: 0 0 12px; }' +
          '.muted{ color:#475569; }' +
          '@media print { body{ margin: 12mm; } pre{ border:none; padding:0; } figure{ break-inside: avoid; } }' +
        '</style></head><body>' +
        '<h1>BK1 Dokumentation</h1>' +
        '<div class="muted" style="margin-bottom: 14px;">Eksporteret: ' + escapeHtml(today) + '</div>' +
        '<div id="content"><div class="muted">Genererer... (vent et oejeblik og brug derefter Ctrl+P -> Gem som PDF)</div></div>';
      win.document.write(baseHtml);
      win.document.close();

      const draftText = String(getDocOverlayDraftTextForExport(projectInfo) || '').trim()
        ? String(getDocOverlayDraftTextForExport(projectInfo) || '')
        : (() => {
            try {
              const bk1Sections = collectBk1SectionsAcrossBuildings();
              const explanations = (bk1Sections || []).map(() => null);
              return buildDocumentTextWithProjectInfo(bk1Sections, explanations, projectInfo);
            } catch(_) {
              return '';
            }
          })();

      const step3 = collectAllStep3DocsWithFiles();
      const vedlaeg = collectOverlayVedlaegWithFiles();
      const step3ImageItems = step3.filter(x => x?.file && String(x.file.type || '').startsWith('image/'));
      const vedlaegImageItems = vedlaeg.filter(x => x?.file && String(x.file.type || '').startsWith('image/'));

      const contentEl = win.document.getElementById('content');
      if (contentEl) {
        const normalizeKey = (s) => String(s || '').toLowerCase().trim().replace(/\s+/g, '').replace(/[^a-z0-9Ã¦Ã¸Ã¥]/g, '');
        const extractVedKey = (line) => {
          const m = String(line || '').match(/\[(?:VEDLÃ†G|VEDLAEG)\s*:\s*([^\]]+)\]/i);
          return m ? String(m[1] || '').trim() : '';
        };
        const vedByKey = buildOverlayVedlaegIndex(vedlaegImageItems);
        const { idx: vedByFileName, norm: normFileName } = buildVedlaegByFileName(vedlaegImageItems);

        const addFigureHtml = async (title, file, caption, subcaption) => {
          const dataUrl = await fileToDataUrlLocal(file);
          return (
            '<figure style="margin: 16px 0; padding: 12px; border: 1px solid #e2e8f0; border-radius: 10px; background: #fff;">' +
            (title ? '<div style="font-weight:700; color:#0f172a; margin-bottom:6px;">' + escapeHtml(title) + '</div>' : '') +
            (subcaption ? '<div class="muted" style="font-size: 12px; margin-bottom:10px; white-space: pre-wrap;">' + escapeHtml(subcaption) + '</div>' : '') +
            '<img src="' + String(dataUrl || '') + '" alt="' + escapeHtml(caption || title) + '" style="max-width: 100%; height: auto; border-radius: 6px;"/>' +
            (caption ? '<figcaption style="margin-top:8px; color:#0f172a; font-size: 13px;">' + escapeHtml(caption) + '</figcaption>' : '') +
            '</figure>'
          );
        };

        const parts = [];
        const lines = String(draftText || '').split(/\r?\n/);
        let insertedStep3 = false;
        let inVedlagteFiler = false;
        for (const line of lines) {
          if (!insertedStep3 && /Dokumentation\s+for\s+indsatsmÃ¦ssige\s+forhold\s*:/i.test(line)) {
            insertedStep3 = true;
            if (step3ImageItems.length) {
              parts.push('<h2 style="margin-top: 26px;">Bilag til brandforhold (trin 3)</h2>');
              parts.push('<div class="muted" style="margin-bottom: 10px;">PDF-bilag bliver konverteret til billede (side 1) ved upload.</div>');
              let lastCat = '';
              for (const item of step3ImageItems) {
                const cat = String(item.category || 'Kravgruppe').trim() || 'Kravgruppe';
                const name = String(item.meta?.name || item.file?.name || 'bilag');
                const cap = String(item.meta?.caption || '').trim();
                const desc = String(item.meta?.description || '').trim();
                const label = `${cat} â€” Bygning ${item.buildingIndex + 1} / Bygningsafsnit ${item.sectionIndex + 1}: ${item.sectionTitle}`;
                const title = (cat !== lastCat) ? ('Kravgruppe: ' + cat) : '';
                parts.push(await addFigureHtml(title, item.file, cap ? `${name} â€” ${cap}` : name, desc ? `${label}\n${desc}` : label));
                lastCat = cat;
              }
            }
          }

          const vedKey = extractVedKey(line);
          if (vedKey) {
            const nk = normalizeKey(vedKey);
            const matches = Array.isArray(vedByKey[nk]) ? vedByKey[nk] : [];
            if (matches.length) {
              let first = true;
              for (const it of matches) {
                const cap = String(it.caption || '').trim();
                const title = first ? ('VedlÃ¦g: ' + vedKey) : '';
                const caption = cap ? `${String(it.name || it.file?.name || 'bilag')} â€” ${cap}` : String(it.name || it.file?.name || 'bilag');
                parts.push(await addFigureHtml(title, it.file, caption, it.placeholderKey));
                first = false;
              }
              continue;
            }
          }

          const trimmed = String(line || '').trim();
          if (/^Vedlagte\s+filer\s*:/i.test(trimmed)) {
            inVedlagteFiler = true;
          } else if (inVedlagteFiler) {
            if (!trimmed) {
              inVedlagteFiler = false;
            } else if (!/^[-â€¢]\s+/.test(trimmed)) {
              inVedlagteFiler = false;
            }
          }

          parts.push(escapeHtml(line));

          let postMatches = [];
          if (/^Vedlagt\s*:/i.test(trimmed)) {
            const fname = parseVedlagtFileNameFromLine(trimmed);
            const hits = Array.isArray(vedByFileName[normFileName(fname)]) ? vedByFileName[normFileName(fname)] : [];
            if (hits.length) postMatches = hits;
          } else if (inVedlagteFiler && /^[-â€¢]\s+/.test(trimmed)) {
            const fname = parseVedlagtFileNameFromLine(trimmed.replace(/^[-â€¢]\s+/, ''));
            const hits = Array.isArray(vedByFileName[normFileName(fname)]) ? vedByFileName[normFileName(fname)] : [];
            if (hits.length) postMatches = hits;
          }

          if (postMatches.length) {
            for (const it of postMatches) {
              const cap = String(it.caption || '').trim();
              const caption = cap ? `${String(it.name || it.file?.name || 'bilag')} â€” ${cap}` : String(it.name || it.file?.name || 'bilag');
              parts.push(await addFigureHtml('', it.file, caption, it.placeholderKey));
            }
          }
        }

        contentEl.innerHTML = '<pre>' + parts.join('\n') + '</pre>';
      }
    }

    async function ensureDocxLoaded(){
      if (window.docx) return window.docx;
      const existing = document.querySelector('script[data-docx="true"]');
      if (!existing) {
        await new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.dataset.docx = 'true';
          s.src = 'https://cdn.jsdelivr.net/npm/docx@8.5.0/build/index.umd.js';
          s.onload = resolve;
          s.onerror = reject;
          document.head.appendChild(s);
        });
      } else {
        await new Promise((resolve, reject) => {
          if (window.docx) return resolve();
          existing.addEventListener('load', resolve, { once: true });
          existing.addEventListener('error', reject, { once: true });
        });
      }
      if (!window.docx) throw new Error('Kunne ikke indlÃ¦se DOCX biblioteket');
      return window.docx;
    }

    async function exportDocOverlayAsDocx(){
      const today = new Date().toLocaleDateString('da-DK');
      const projectInfo = getDocOverlayProjectInfoLenient();

      const draftText = String(getDocOverlayDraftTextForExport(projectInfo) || '').trim()
        ? String(getDocOverlayDraftTextForExport(projectInfo) || '')
        : (() => {
            try {
              const bk1Sections = collectBk1SectionsAcrossBuildings();
              const explanations = (bk1Sections || []).map(() => null);
              return buildDocumentTextWithProjectInfo(bk1Sections, explanations, projectInfo);
            } catch(_) {
              return '';
            }
          })();

      const lib = await ensureDocxLoaded();
      const { Document, Packer, Paragraph, TextRun, HeadingLevel, ImageRun } = lib;

      const DOC_FONT = 'Arial';
      const DOC_SIZE = 24; // 12pt (docx uses half-points)

      const isSeparatorLine = (s) => {
        const t = String(s || '').trim();
        if (!t) return false;
        // Lines consisting primarily of repeated separator characters
        if (/^[-]{10,}$/.test(t)) return true;
        if (/^[=]{10,}$/.test(t)) return true;
        if (/^[_]{10,}$/.test(t)) return true;
        if (/^[â•â”â”€]{10,}$/.test(t)) return true;
        if (/^[+|\-=_ â•â”â”€]{10,}$/.test(t)) return true;
        return false;
      };

      const isHeadingLine = (s) => {
        const t = String(s || '').trim();
        if (!t) return false;
        if (/^\d+(?:\.\d+)*\.\s+/.test(t)) return true;
        if (/^(PROJEKTINFORMATION|INDHOLDSFORTEGNELSE|TEKNISK INFORMATION)\b/i.test(t)) return true;
        if (t.length >= 12 && t === t.toUpperCase() && /[A-ZÃ†Ã˜Ã…]/.test(t)) return true;
        if (/^Bygningsafsnit\s+\d+\s*:/i.test(t)) return true;
        return false;
      };

      const headingLevelFor = (s) => {
        const t = String(s || '').trim();
        const m = t.match(/^(\d+)(?:\.(\d+))?(?:\.(\d+))?\./);
        if (m) {
          const depth = m[3] ? 3 : (m[2] ? 2 : 1);
          if (depth === 1) return HeadingLevel.HEADING_1;
          if (depth === 2) return HeadingLevel.HEADING_2;
          return HeadingLevel.HEADING_3;
        }
        if (/^Bygningsafsnit\s+\d+\s*:/i.test(t)) return HeadingLevel.HEADING_2;
        return HeadingLevel.HEADING_1;
      };

      const normalizeWeirdListLine = (s) => {
        let t = String(s || '');
        t = t.replace(/^\s*%\s*[a-z]\s*/i, 'â€¢ ');
        const trimmed = t.trim();
        const tokens = trimmed.split(/\s+/g);
        const singleCharTokens = tokens.filter(x => x.length === 1).length;
        if (tokens.length >= 10 && singleCharTokens / tokens.length > 0.7) {
          t = trimmed
            .replace(/\s*\(\s*/g, '(')
            .replace(/\s*\)\s*/g, ')')
            .replace(/\s*:\s*/g, ': ')
            .replace(/\s+/g, ' ')
            .replace(/([A-Za-zÃ†Ã˜Ã…Ã¦Ã¸Ã¥0-9])\s(?=[A-Za-zÃ†Ã˜Ã…Ã¦Ã¸Ã¥0-9])/g, '$1');
        }
        t = t.replace(/\t/g, '  ');
        return t;
      };

      const normalizeKey = (s) => String(s || '').toLowerCase().trim().replace(/\s+/g, '').replace(/[^a-z0-9Ã¦Ã¸Ã¥]/g, '');
      const extractVedlaegKeyFromLine = (line) => {
        const m = String(line || '').match(/\[(?:VEDLÃ†G|VEDLAEG)\s*:\s*([^\]]+)\]/i);
        return m ? String(m[1] || '').trim() : '';
      };

      const getImageNaturalSize = async (file) => {
        return await new Promise((resolve, reject) => {
          let url = '';
          try {
            url = URL.createObjectURL(file);
            const img = new Image();
            img.onload = () => {
              try { URL.revokeObjectURL(url); } catch(_) {}
              const w = Number(img.naturalWidth);
              const h = Number(img.naturalHeight);
              resolve({ width: w, height: h });
            };
            img.onerror = () => {
              try { URL.revokeObjectURL(url); } catch(_) {}
              reject(new Error('Kunne ikke indlÃ¦se billeddimensioner'));
            };
            img.src = url;
          } catch (e) {
            try { if (url) URL.revokeObjectURL(url); } catch(_) {}
            reject(e);
          }
        });
      };

      const children = [];
      const step3 = collectAllStep3DocsWithFiles().filter(x => x?.file && String(x.file.type || '').startsWith('image/'));
      const vedlaeg = collectOverlayVedlaegWithFiles().filter(x => x?.file && String(x.file.type || '').startsWith('image/'));

      const vedlaegByKey = buildOverlayVedlaegIndex(vedlaeg);
      const { idx: vedlaegByFileName, norm: normFileName } = buildVedlaegByFileName(vedlaeg);

      const addImage = async (title, file, caption, subtitle) => {
        const ab = await file.arrayBuffer();
        let w = 560;
        let h = 420;
        try {
          const dim = await getImageNaturalSize(file);
          const nw = Number(dim?.width);
          const nh = Number(dim?.height);
          if (Number.isFinite(nw) && Number.isFinite(nh) && nw > 0 && nh > 0) {
            const maxW = 560;
            const maxH = 760;
            const scale = Math.min(maxW / nw, maxH / nh, 1);
            w = Math.max(1, Math.round(nw * scale));
            h = Math.max(1, Math.round(nh * scale));
          }
        } catch(_) {}
        if (title) {
          children.push(new Paragraph({
            children: [new TextRun({ text: String(title), bold: true, font: DOC_FONT, size: DOC_SIZE })]
          }));
        }
        if (subtitle) {
          children.push(new Paragraph({
            children: [new TextRun({ text: String(subtitle), italics: true, font: DOC_FONT, size: DOC_SIZE - 2 })]
          }));
        }
        children.push(new Paragraph({ children: [new ImageRun({ data: ab, transformation: { width: w, height: h } })] }));
        if (caption) {
          children.push(new Paragraph({
            children: [new TextRun({ text: String(caption), font: DOC_FONT, size: DOC_SIZE })]
          }));
        }
        children.push(new Paragraph({ text: '' }));
      };

      let insertedStep3 = false;
      const insertStep3Inline = async () => {
        if (insertedStep3) return;
        insertedStep3 = true;
        if (!step3.length) return;
        children.push(new Paragraph({ text: '' }));
        children.push(new Paragraph({ text: 'Bilag til brandforhold (trin 3)', heading: HeadingLevel.HEADING_2 }));
        children.push(new Paragraph({ children: [new TextRun({ text: 'PDF-bilag bliver konverteret til billede (side 1) ved upload.', italics: true })] }));
        children.push(new Paragraph({ text: '' }));

        let lastCat = '';
        for (const item of step3) {
          const cat = String(item.category || 'Kravgruppe').trim() || 'Kravgruppe';
          const name = String(item.meta?.name || item.file?.name || 'bilag');
          const cap = String(item.meta?.caption || '').trim();
          const desc = String(item.meta?.description || '').trim();
          const label = `${cat} â€” Bygning ${item.buildingIndex + 1} / Bygningsafsnit ${item.sectionIndex + 1}: ${item.sectionTitle}`;

          const title = (cat !== lastCat) ? ('Kravgruppe: ' + cat) : '';
          const subtitle = desc ? (label + ' | ' + desc) : label;
          const caption = cap ? `${name} â€” ${cap}` : name;
          await addImage(title, item.file, caption, subtitle);
          lastCat = cat;
        }
      };

      let inVedlagteFiler = false;
      for (const lineRaw of String(draftText || '').split(/\r?\n/)) {
        let line = String(lineRaw ?? '');
        line = normalizeWeirdListLine(line);

        // Insert step-3 docs in the brandforhold section
        if (!insertedStep3 && /Dokumentation\s+for\s+indsatsmÃ¦ssige\s+forhold\s*:/i.test(line)) {
          await insertStep3Inline();
        }

        // Inline Step-4 attachments where placeholders appear
        const vedKey = extractVedlaegKeyFromLine(line);
        if (vedKey) {
          const nk = normalizeKey(vedKey);
          const matches = Array.isArray(vedlaegByKey[nk]) ? vedlaegByKey[nk] : [];
          if (matches.length) {
            let first = true;
            for (const it of matches) {
              const cap = String(it.caption || '').trim();
              const title = first ? ('VedlÃ¦g: ' + vedKey) : '';
              const caption = cap ? `${String(it.name || it.file?.name || 'bilag')} â€” ${cap}` : String(it.name || it.file?.name || 'bilag');
              await addImage(title, it.file, caption, it.placeholderKey);
              first = false;
            }
            continue; // don't add placeholder line as plain text
          }
        }

        const trimmed = String(line || '').trim();
        if (/^Vedlagte\s+filer\s*:/i.test(trimmed)) {
          inVedlagteFiler = true;
        } else if (inVedlagteFiler) {
          if (!trimmed) {
            inVedlagteFiler = false;
          } else if (!/^[-â€¢]\s+/.test(trimmed)) {
            inVedlagteFiler = false;
          }
        }

        let postMatches = [];
        if (/^Vedlagt\s*:/i.test(trimmed)) {
          const fname = parseVedlagtFileNameFromLine(trimmed);
          const hits = Array.isArray(vedlaegByFileName[normFileName(fname)]) ? vedlaegByFileName[normFileName(fname)] : [];
          if (hits.length) postMatches = hits;
        } else if (inVedlagteFiler && /^[-â€¢]\s+/.test(trimmed)) {
          const fname = parseVedlagtFileNameFromLine(trimmed.replace(/^[-â€¢]\s+/, ''));
          const hits = Array.isArray(vedlaegByFileName[normFileName(fname)]) ? vedlaegByFileName[normFileName(fname)] : [];
          if (hits.length) postMatches = hits;
        }

        if (isSeparatorLine(line)) continue;

        if (!line.trim()) {
          children.push(new Paragraph({ text: '' }));
          continue;
        }

        if (isHeadingLine(line)) {
          const lvl = headingLevelFor(line);
          const size = (lvl === HeadingLevel.HEADING_1) ? 28 : (lvl === HeadingLevel.HEADING_2 ? 26 : 24);
          children.push(new Paragraph({
            heading: lvl,
            children: [
              new TextRun({ text: String(line).trim(), bold: true, font: DOC_FONT, size })
            ]
          }));
          continue;
        }

        children.push(new Paragraph({
          children: [new TextRun({ text: line, font: DOC_FONT, size: DOC_SIZE })]
        }));

        if (postMatches.length) {
          for (const it of postMatches) {
            const cap = String(it.caption || '').trim();
            const caption = cap ? `${String(it.name || it.file?.name || 'bilag')} â€” ${cap}` : String(it.name || it.file?.name || 'bilag');
            await addImage('', it.file, caption, it.placeholderKey);
          }
        }
      }

      // If anchor missing (user edited), still place step-3 docs at end
      if (!insertedStep3) {
        await insertStep3Inline();
      }

      // If there were no [VEDLÃ†G: ...] placeholders at all, append vedlÃ¦g at end
      const anyVedPlaceholderInText = /\[(?:VEDLÃ†G|VEDLAEG)\s*:/i.test(String(draftText || ''));
      if (!anyVedPlaceholderInText && vedlaeg.length) {
        children.push(new Paragraph({ text: '' }));
        children.push(new Paragraph({ text: 'VedlÃ¦g (trin 4) â€“ ikke placeret i tekst', heading: HeadingLevel.HEADING_2 }));
        for (const it of vedlaeg) {
          const cap = String(it.caption || '').trim();
          const caption = cap ? `${String(it.name || it.file?.name || 'bilag')} â€” ${cap}` : String(it.name || it.file?.name || 'bilag');
          await addImage('', it.file, caption, it.placeholderKey);
        }
      }

      const doc = new Document({
        styles: {
          default: {
            document: {
              run: { font: DOC_FONT, size: DOC_SIZE },
            },
          },
        },
        sections: [{ children }]
      });
      const blob = await Packer.toBlob(doc);
      const url = URL.createObjectURL(blob);

      // Try auto-download; if blocked, provide a clickable fallback link in the overlay
      try {
        const a = document.createElement('a');
        a.href = url;
        a.download = `BK1_Dokumentation_${projectInfo.__safeName}_${today.replace(/\./g, '-')}.docx`;
        document.body.appendChild(a);
        a.click();
        a.remove();
      } catch(_) {}

      try {
        const overlay = document.getElementById('doc-generator-overlay');
        const actions = overlay ? overlay.querySelector('.bilag-actions .right') : null;
        if (actions) {
          let link = document.getElementById('docx-download-link');
          if (!link) {
            link = document.createElement('a');
            link.id = 'docx-download-link';
            link.className = 'btn-secondary';
            link.style.textDecoration = 'none';
            link.textContent = 'â¬‡ Download DOCX';
            actions.prepend(link);
          }
          link.href = url;
          link.download = `BK1_Dokumentation_${projectInfo.__safeName}_${today.replace(/\./g, '-')}.docx`;
        }
      } catch(_) {}

      setTimeout(() => { try { URL.revokeObjectURL(url); } catch(_) {} }, 60_000);
    }
    
    function generateDocumentWithProjectInfo(bk1Sections, explanations, projectInfo) {
      // Legacy helper (kept for backwards compatibility). The overlay export path
      // uses buildDocumentTextWithProjectInfo directly.
      const today = new Date().toLocaleDateString('da-DK');
      const p = projectInfo || { projektnavn: 'â€”', adresse: 'â€”', bygherre: 'â€”', raadgiver: 'â€”' };
      const safeName = String(p.projektnavn || 'projekt').replace(/[^a-zA-Z0-9]/g, '_');
      const text = buildDocumentTextWithProjectInfo(bk1Sections || [], explanations || [], p);

      const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      try {
        const a = document.createElement('a');
        a.href = url;
        a.download = 'BK1_Dokumentation_' + safeName + '_' + today.replace(/\./g, '-') + '.txt';
        document.body.appendChild(a);
        a.click();
        a.remove();
      } finally {
        try { URL.revokeObjectURL(url); } catch (_) {}
      }
    }

    function filterActiveInputsForRule(node, rule, inputs, computedValues) {
      if (!node || !rule || !node.content || !Array.isArray(node.content.inputs)) return [];
      const out = [];
      node.content.inputs.forEach(inp => {
        if (!inp || !inp.id) return;
        const conditionValue = rule[inp.id];
        const isArray = Array.isArray(conditionValue);
        const isActive = conditionValue !== '' && conditionValue !== undefined && conditionValue !== null && !(isArray && conditionValue.length === 0);
        if (!isActive) return;

        const fieldName = inp.field;
        const displayName = inp.name || inp.field || inp.id;

        let value = undefined;
        if (computedValues && fieldName in computedValues) value = computedValues[fieldName];
        if (value === undefined) value = inputs ? inputs[fieldName] : undefined;

        out.push({
          field: fieldName,
          name: displayName,
          condition: conditionValue,
          value
        });
      });
      return out;
    }

    function buildAutoClassificationExplanationTextForSection(section, idx) {
      if (!section || !section.data) return '';
      const evaluation = section.data;
      const inputs = section.inputs || {};

      const akValue = evaluation?.anvendelseskategori?.value;
      const rkValue = evaluation?.risikoklasse?.value;
      const bkValue = evaluation?.brandklasse?.value;
      const bilagValue = evaluation?.relevant_bilag?.value || evaluation?.relevant_bilag;
      const bilagTitle = getBilagTitleFromEvaluation(evaluation);

      const computed = {
        anvendelseskategori: akValue,
        risikoklasse: rkValue,
        brandklasse: bkValue,
        relevant_bilag: bilagValue
      };

      const lines = [];
      lines.push('FÃ¸lgende afsnit dokumenterer fastlÃ¦ggelsen af byggeriets anvendelseskategori, risikoklasse og brandklasse pÃ¥ baggrund af de indtastede projektoplysninger. Klassificeringen danner grundlag for den videre brandtekniske dokumentation.');
      lines.push('');

      const uniq = (arr) => {
        const out = [];
        const seen = new Set();
        for (const s of (arr || [])) {
          const key = String(s || '').trim();
          if (!key) continue;
          if (seen.has(key)) continue;
          seen.add(key);
          out.push(key);
        }
        return out;
      };

      const formatConditionSentence = (ac) => {
        if (!ac) return '';
        const field = ac.field;
        const name = ac.name;
        const value = ac.value;
        const condition = ac.condition;

        if (field === 'anvendelseskategori') {
          return `Bygningsafsnittet er vurderet til anvendelseskategori ${value}`;
        }
        if (field === 'risikoklasse') {
          return `Bygningsafsnittet er vurderet til risikoklasse ${value}`;
        }
        if (field === 'relevant_bilag') {
          return `Der anvendes relevant bilag ${value}`;
        }

        // Explicit area fields (as requested)
        if (field === 'area_BA') {
          const v = (value === null || value === undefined) ? '' : String(value).trim();
          return `Arealet af bygningsafsnittet er ${v} mÂ²`;
        }
        if (field === 'area_total') {
          const v = (value === null || value === undefined) ? '' : String(value).trim();
          return `Det totale areal af bygningen er ${v} mÂ²`;
        }

        try {
          return formatChecklistItem(field, name, value, condition);
        } catch (_) {
          return `${name}: ${value}`;
        }
      };

      const getActiveBullets = (nodeNameCandidates, outputField, matchedRuleId, opts) => {
        const options = opts || {};
        const excludeFields = new Set(options.excludeFields || []);
        let bullets = [];
        try {
          const node = findDecisionNodeByNameOrOutput(nodeNameCandidates, outputField);
          const rule = findRuleByIdOrIndex(node, matchedRuleId);
          const active = extractActiveConditions(node, rule, inputs, computed);
          bullets = active
            .filter(ac => ac && !excludeFields.has(ac.field))
            .map(ac => formatConditionSentence(ac))
            .map(s => `- ${s}`)
            .filter(Boolean);
        } catch (_) {}
        return uniq(bullets);
      };

      const normalizeAkConclusion = (akVal, descRaw) => {
        const desc = (descRaw === null || descRaw === undefined) ? '' : String(descRaw).trim();
        if (!desc) return `Bygningsafsnittet henfÃ¸res derfor til anvendelseskategori ${akVal}.`;
        const m = desc.match(/Dette\s+er\s+typisk\s+([^\.]+)\.?/i);
        if (m && m[1]) {
          return `Bygningsafsnittet henfÃ¸res derfor til anvendelseskategori ${akVal}, som omfatter typisk ${m[1].trim()}.`;
        }
        return `Bygningsafsnittet henfÃ¸res derfor til anvendelseskategori ${akVal}.`;
      };

      const normalizeRkConclusion = (rkVal, descRaw) => {
        const raw = (descRaw === null || descRaw === undefined) ? '' : String(descRaw).trim();
        if (!raw) return `Byggeriet klassificeres derfor i risikoklasse ${rkVal}.`;
        let d = raw.replace(/\s+/g, ' ');
        // Typical patterns: "Risikoklasse 1 indikerer at byggeriet er ..."
        d = d.replace(/^Risikoklasse\s*\d+\s*(indikerer|angiver|betyder)\s+at\s+/i, '');
        d = d.replace(/^Risikoklasse\s*\d+\s*(indikerer|angiver|betyder)\s+/i, '');
        d = d.replace(/^Risikoklasse\s*\d+\s*/i, '');
        d = d.replace(/^byggeriet\s+er\s+/i, '');
        d = d.trim();
        if (!d) return `Byggeriet klassificeres derfor i risikoklasse ${rkVal}.`;
        if (!/[.!?]$/.test(d)) d += '.';
        return `PÃ¥ denne baggrund vurderes byggeriet at vÃ¦re ${d} Byggeriet klassificeres derfor i risikoklasse ${rkVal}.`;
      };

      const normalizeBkConclusion = (bkVal) => {
        const v = (bkVal === null || bkVal === undefined) ? '' : String(bkVal).trim();
        if (!v) return '';
        if (v === '1') {
          return 'Byggeriet henfÃ¸res derfor til brandklasse 1, hvor den brandtekniske dokumentation kan ske pÃ¥ grundlag af prÃ¦-accepterede lÃ¸sninger uden brandteknisk dimensionering.';
        }
        if (v === '2') {
          return 'Byggeriet henfÃ¸res derfor til brandklasse 2, hvor den brandtekniske dokumentation typisk forudsÃ¦tter certificeret brandrÃ¥dgivning og kan omfatte fravigelser og/eller brandteknisk dimensionering.';
        }
        return `Byggeriet henfÃ¸res derfor til brandklasse ${v}.`;
      };

      // ===== Anvendelseskategori =====
      if (akValue !== null && akValue !== undefined && String(akValue).trim() !== '') {
        lines.push(`Anvendelseskategori: ${akValue}`);
        const akBullets = getActiveBullets(
          ['Anvendelseskategori 2.0'],
          'anvendelseskategori',
          evaluation?.anvendelseskategori?.matched_rule_id,
          { excludeFields: [] }
        );
        if (akBullets.length > 0) {
          lines.push('Det er angivet at:');
          lines.push(...akBullets);
        }
        lines.push(normalizeAkConclusion(akValue, evaluation?.anvendelseskategori?.description));
        lines.push('');
      }

      // ===== Risikoklasse =====
      if (rkValue !== null && rkValue !== undefined && String(rkValue).trim() !== '') {
        lines.push(`Risikoklasse: ${rkValue}`);
        const rkBullets = getActiveBullets(
          ['Risikoklasse'],
          'risikoklasse',
          evaluation?.risikoklasse?.matched_rule_id,
          { excludeFields: [] }
        );
        if (rkBullets.length > 0) {
          lines.push('Det er angivet at:');
          lines.push(...rkBullets);
        }
        lines.push(normalizeRkConclusion(rkValue, evaluation?.risikoklasse?.description));
        lines.push('');
      }

      // ===== Brandklasse =====
      if (bkValue !== null && bkValue !== undefined && String(bkValue).trim() !== '') {
        lines.push(`Brandklasse: ${bkValue}`);

        const bygningstypeArticle = (typeof describeBygningstypeArticle === 'function')
          ? describeBygningstypeArticle(inputs?.bygningstype)
          : 'et byggeri';
        const bilagRefTitle = bilagTitle ? String(bilagTitle).trim() : '';
        const bilagIntro = bilagRefTitle ? `i ${bilagRefTitle}` : 'i relevant bilag';
        lines.push(`Byggeriet er ${bygningstypeArticle} i anvendelseskategori ${akValue ?? 'N/A'} og risikoklasse ${rkValue ?? 'N/A'}, hvilket medfÃ¸rer at byggeriet vurderes op imod de prÃ¦-accepterede lÃ¸sninger ${bilagIntro}.`);

        const bkBullets = getActiveBullets(
          ['Brandklasse', 'PrÃ¦-accepterede lÃ¸sninger'],
          'brandklasse',
          evaluation?.brandklasse?.matched_rule_id,
          {
            excludeFields: [
              'anvendelseskategori',
              'risikoklasse',
              'relevant_bilag',
              'brandklasse'
            ]
          }
        );

        if (bkBullets.length > 0) {
          lines.push('Ydermere er det angivet at:');
          lines.push(...bkBullets);
        }

        lines.push(normalizeBkConclusion(bkValue));
        lines.push('');
      }

      return lines.join('\n').replace(/\n{3,}/g, '\n\n').trim();
    }

    // Same content as generateDocumentWithProjectInfo, but returns the text instead of downloading.
    function buildDocumentTextWithProjectInfo(bk1Sections, explanations, projectInfo) {
      const today = new Date().toLocaleDateString('da-DK');

      const buildBrandforholdDocsText = () => {
        const lines = [];
        let any = false;

        (bk1Sections || []).forEach((section) => {
          const docsByCategory = section?.kravCategoryDocs && typeof section.kravCategoryDocs === 'object'
            ? section.kravCategoryDocs
            : {};
          const categories = sortCategoryLabelsByOrder(
            Object.keys(docsByCategory)
              .filter(k => Array.isArray(docsByCategory[k]) && docsByCategory[k].length > 0),
            section?.kravCategoryOrder
          );

          if (categories.length === 0) return;
          any = true;
          const sIdx = Number.isFinite(Number(section?.sectionIndex)) ? Number(section.sectionIndex) : null;
          const bIdx = Number.isFinite(Number(section?.buildingIndex)) ? Number(section.buildingIndex) : null;
          const prefix = (bIdx !== null) ? `Bygning ${bIdx + 1} / ` : '';
          const sectionLabel = (sIdx !== null)
            ? `${prefix}Bygningsafsnit ${sIdx + 1}: ${section.title}`
            : `${prefix}${section.title}`;
          lines.push(sectionLabel);

          for (const cat of categories) {
            lines.push(`- ${cat}`);
            for (const d of (docsByCategory[cat] || [])) {
              const name = String(d?.name || 'fil');
              const caption = String(d?.caption || '').trim();
              const desc = String(d?.description || '').trim();
              lines.push(`  - ${caption ? `${name} â€” ${caption}` : name}`);
              if (desc) lines.push(`    ${desc}`);
            }
          }
          lines.push('');
        });

        if (!any) return 'Ingen dokumentation tilfÃ¸jet i trin 3 endnu.';
        return lines.join('\n').trim();
      };

      let docContent = `DOKUMENTATION TIL KOMMUNALBESTYRELSEN
Brandteknisk Dokumentation for Brandklasse 1 Byggeri

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PROJEKTINFORMATION

Projektnavn:        ${projectInfo.projektnavn}
Adresse/Matrikel:   ${projectInfo.adresse}
Bygherre:           ${projectInfo.bygherre}
RÃ¥dgiver:           ${projectInfo.raadgiver}

Dato:               ${today}
Version:            1.0

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 
INDHOLDSFORTEGNELSE

1. Teknisk information
2. Overordnede beskrivelser og forudsÃ¦tninger
3. RedegÃ¸relse for valg af brandklasse
4. Dokumentation for byggeriets indsatsmÃ¦ssige forhold
  4.1 Dokumentation af brandforhold
5. Tegningsmateriale
  5.1 Situationsplan
  5.2 Brandplan
6. Notat om brandteknisk udfÃ¸relse

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. TEKNISK INFORMATION

`;

      bk1Sections.forEach((section, idx) => {
        const data = section.data;
        const explanation = explanations?.[idx];
        const bygningstype = section.inputs.bygningstype || 'N/A';

        docContent += `Bygningsafsnit ${idx + 1}: ${section.title}

Bygningstype:           ${bygningstype.charAt(0).toUpperCase() + bygningstype.slice(1)}
Anvendelseskategori:    ${data.anvendelseskategori?.value || 'N/A'}
Risikoklasse:           ${data.risikoklasse?.value || 'N/A'}
Relevant bilag:         ${data.relevant_bilag?.value || data.relevant_bilag || 'N/A'}
Forudsat brandklasse:   1

`;
        const autoExpl = buildAutoClassificationExplanationTextForSection(section, idx);
        const backendSummary = (explanation && explanation.summary) ? String(explanation.summary).trim() : '';
        const backendFull = (explanation && typeof explanation === 'object') ? explanation : null;

        if (autoExpl) {
          docContent += `BEGRUNDELSE FOR KLASSIFICERING:
${autoExpl}

`;
        } else if (backendSummary) {
          docContent += `BEGRUNDELSE FOR KLASSIFICERING:
${backendSummary}

`;
        } else if (backendFull && (backendFull.anvendelseskategori || backendFull.risikoklasse || backendFull.brandklasse)) {
          // Fallback if backend returned structured explanations but no summary
          const parts = [];
          try {
            if (backendFull.anvendelseskategori?.text) parts.push(String(backendFull.anvendelseskategori.text).trim());
            if (backendFull.risikoklasse?.text) parts.push(String(backendFull.risikoklasse.text).trim());
            if (backendFull.brandklasse?.text) parts.push(String(backendFull.brandklasse.text).trim());
          } catch (_) {}
          if (parts.length > 0) {
            docContent += `BEGRUNDELSE FOR KLASSIFICERING:
${parts.join('\n\n')}

`;
          }
        }
        docContent += `---

`;
      });

      docContent += `
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    2. OVERORDNEDE BESKRIVELSER OG FORUDSÃ†TNINGER

Projektbeskrivelse:
[UDFYLD: Beskriv projektets overordnede karakter, formÃ¥l og anvendelse]

ForudsÃ¦tninger:
Se teknisk information ovenfor for automatisk genererede oplysninger.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

3. REDEGÃ˜RELSE FOR VALG AF BRANDKLASSE

Byggeriet er klassificeret som Brandklasse 1 baseret pÃ¥ de prÃ¦-accepterede 
lÃ¸sninger i BR18. Se teknisk information ovenfor for detaljeret begrundelse
genereret af BR18 Komplet System.

[UDFYLD: SupplÃ©r med yderligere projektspecifik information om 
brandklassificeringen hvis relevant]

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

4. DOKUMENTATION FOR BYGGERIETS INDSATSMÃ†SSIGE FORHOLD

4.1 DOKUMENTATION AF BRANDFORHOLD

${buildBrandforholdDocsText()}


Dokumentation for indsatsmÃ¦ssige forhold:
SÃ¥fremt byggeriet er indsatstaktisk traditionelt jf. beskrivelserne i afsnit 5 i relevant bilag,
skal dette dokumenteres i form af en situationsplan og brandplaner evt. suppleret med beskrivelser.
Er byggeriet ikke indsatstaktisk traditionelt, skal fravigelserne accepteres af kommunalbestyrelsen,
inden der kan meddeles byggetilladelse. Kommunalbestyrelsens accept af dette skal indgÃ¥ i den
brandtekniske dokumentation.


(Se afsnittet ovenfor for krav til dokumentation for byggeriets indsatsmÃ¦ssige forhold.)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

5. TEGNINGSMATERIALE

5.1 SITUATIONSPLAN
[VEDLÃ†G: Situationsplan]
- Bygningernes placering pÃ¥ ejendommen
- Forhold til anden bebyggelse
- Forhold til naboskel
- Vej- og stimidte

5.2 BRANDPLAN
[VEDLÃ†G: Brandplaner]
- Bygningens eventuelle opdeling i brandmÃ¦ssige enheder
- Placering af rÃ¸galarmer
- Eventuelle redningsÃ¥bninger
[Se Bilag 13 i BR18 vejledningen for krav til udfÃ¦rdigelse af brandplaner]

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

6. NOTAT OM BRANDTEKNISK UDFÃ˜RELSE

[UDFYLD: Notat om brandteknisk udfÃ¸relse]

 
`;

  return normalizeGeneratedDocumentText(docContent);
    }

    function normalizeGeneratedDocumentText(text) {
      if (text === null || text === undefined) return '';
      return String(text)
        // Remove legacy footer lines (document should be submission-ready)
        .replace(/\n\s*Dette dokument er genereret af BR18 Komplet System\.\s*\n?/m, '\n')
        .replace(/\n\s*Alle felter markeret med \[UDFYLD\] og \[VEDLÃ†G\] skal udfyldes\/vedlÃ¦gges\s*\n?/m, '\n')
        .replace(/\n\s*f\u00f8r indsendelse til kommunalbestyrelsen\.\s*\n?/mi, '\n')
        .replace(/\n\s*Genereret:\s*[^\n]*\n?/mi, '\n')
        // Remove legacy appendix blocks (kept as a user-editable section 6 instead)
        .replace(
          /\n(?:â•{10,}|-{10,}|_{10,}|={10,})\n\s*\nBILAG\s*\n[\s\S]*?NOTER TIL FÃ†RDIGMELDING\s*\n[\s\S]*?(?:â•{10,}|-{10,}|_{10,}|={10,})\n\s*\n(?=Dette dokument er genereret af BR18 Komplet System\.)/m,
          '\n\n'
        )
        .replace(
          /\nBILAG\s*\n[\s\S]*?NOTER TIL FÃ†RDIGMELDING\s*\n[\s\S]*?(?=\n\s*Dette dokument er genereret af BR18 Komplet System\.)/m,
          '\n\n'
        )
        // Avoid leaking code indentation into the generated document
        .replace(/^[ \t]+(?=â•)/gm, '')
        // Only strip indentation for numbered ALL-CAPS section headings (not TOC subitems like "5.1 Situationsplan")
        .replace(/^[ \t]+(?=\d+\.\s+[A-ZÃ†Ã˜Ã…0-9][A-ZÃ†Ã˜Ã…0-9 .\-]*$)/gm, '')
        // Keep output tidy
        .replace(/\n{3,}/g, '\n\n');
    }

    function updateDocHeaderLines(existingText, projectInfo) {
      if (!existingText) return existingText;
      const replaceLine = (text, label, value) => {
        const re = new RegExp(`^(${label}\\s*)(.*)$`, 'm');
        if (re.test(text)) return text.replace(re, `$1${value}`);
        return text;
      };
      let t = existingText;
      t = replaceLine(t, 'Projektnavn:\\s*', String(projectInfo.projektnavn || ''));
      t = replaceLine(t, 'Adresse/Matrikel:\\s*', String(projectInfo.adresse || ''));
      t = replaceLine(t, 'Bygherre:\\s*', String(projectInfo.bygherre || ''));
      t = replaceLine(t, 'RÃ¥dgiver:\\s*', String(projectInfo.raadgiver || ''));
      return t;
    }

    function parseProjectInfoFromDraft(text) {
      if (!text) return null;
      const read = (label) => {
        const re = new RegExp(`^${label}\\s*(.*)$`, 'm');
        const m = String(text).match(re);
        return (m && m[1] ? String(m[1]).trim() : '');
      };
      const projektnavn = read('Projektnavn:');
      const adresse = read('Adresse/Matrikel:');
      const bygherre = read('Bygherre:');
      const raadgiver = read('RÃ¥dgiver:');
      if (!projektnavn && !adresse && !bygherre && !raadgiver) return null;
      return { projektnavn, adresse, bygherre, raadgiver };
    }

    function generateDocumentationTemplate() {
      // Collect all Brandklasse 1 sections
      const bk1Sections = [];
      for (let i = 0; i < sectionsState.count; i++) {
        const evalRes = sectionsState.evaluations[i];
        if (evalRes && (evalRes.brandklasse?.value === '1' || evalRes.brandklasse?.value === 1)) {
          bk1Sections.push({
            sectionIndex: i,
            title: sectionsState.titles[i] || `Bygningsafsnit ${i+1}`,
            data: evalRes,
            inputs: sectionsState.inputData[i] || {},
            kravCategoryDocs: sectionsState.kravCategoryDocs?.[String(i)] || {}
          });
        }
      }
      
      if (bk1Sections.length === 0) {
        alert('Ingen bygningsafsnit er klassificeret som Brandklasse 1.');
        return;
      }
      
      // Fetch explanations for all sections
      const explanationPromises = bk1Sections.map(async section => {
        try {
          const resp = await fetch(`${API_BASE}/generate-explanation`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
              inputs: section.inputs,
              results: section.data
            })
          });
          if (resp.ok) {
            const data = await resp.json();
            return data.explanation;
          }
        } catch (e) {
          console.error('Failed to fetch explanation:', e);
        }
        return null;
      });
      
      // Wait for all explanations and generate document
      Promise.all(explanationPromises).then(explanations => {
        generateDocumentWithExplanations(bk1Sections, explanations);
      });
    }
    
    function generateDocumentWithExplanations(bk1Sections, explanations) {
      // Generate documentation template
      const today = new Date().toLocaleDateString('da-DK');
      let docContent = `DOKUMENTATION TIL KOMMUNALBESTYRELSEN
Brandteknisk Dokumentation for Brandklasse 1 Byggeri

Dato: ${today}
Genereret af: BR18 Komplet System

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

INDHOLDSFORTEGNELSE

1. Teknisk information
2. Overordnede beskrivelser og forudsÃ¦tninger
3. RedegÃ¸relse for valg af brandklasse
4. Dokumentation for byggeriets indsatsmÃ¦ssige forhold
5. Tegningsmateriale
  5.1 Situationsplan
  5.2 Brandplan
6. Notat om brandteknisk udfÃ¸relse

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. TEKNISK INFORMATION
`;

      // Add section data with explanations
      bk1Sections.forEach((section, idx) => {
        const data = section.data;
        const explanation = explanations[idx];
        
        docContent += `\nBygningsafsnit ${idx + 1}: ${section.title}
- Anvendelseskategori: ${data.anvendelseskategori?.value || 'N/A'}
- Risikoklasse: ${data.risikoklasse?.value || 'N/A'}
- Relevant bilag: ${data.relevant_bilag?.value || data.relevant_bilag || 'N/A'}
- Brandklasse: ${data.brandklasse?.value || 'N/A'}

`;
        // Add automatic explanation if available
        if (explanation && explanation.anvendelseskategori) {
          docContent += `Anvendelseskategori forklaring:
${explanation.anvendelseskategori.description}

`;
        }
        if (explanation && explanation.risikoklasse) {
          docContent += `Risikoklasse forklaring:
${explanation.risikoklasse.description}

`;
        }
      });

      docContent += `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

2. OVERORDNEDE BESKRIVELSER OG FORUDSÃ†TNINGER

Projektbeskrivelse:
[UDFYLD: Beskriv projektets overordnede karakter, formÃ¥l og anvendelse]

ForudsÃ¦tninger:
Se teknisk information ovenfor for automatisk genererede oplysninger.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

3. REDEGÃ˜RELSE FOR VALG AF BRANDKLASSE

Byggeriet er klassificeret som Brandklasse 1 baseret pÃ¥ fÃ¸lgende:

`;

      bk1Sections.forEach((section, idx) => {
        const explanation = explanations[idx];
        docContent += `\nBygningsafsnit ${idx + 1}: ${section.title}

`;
        // Add automatic explanation for brandklasse
        if (explanation && explanation.summary) {
          docContent += `Automatisk genereret forklaring:
${explanation.summary}

`;
        }
        
        docContent += `[UDFYLD: SupplÃ©r med yderligere projektspecifik information om brandklassificeringen]

`;
      });

      docContent += `
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    4. DOKUMENTATION FOR BYGGERIETS INDSATSMÃ†SSIGE FORHOLD

Dokumentation for indsatsmÃ¦ssige forhold:
SÃ¥fremt byggeriet er indsatstaktisk traditionelt jf. beskrivelserne i afsnit 5 i relevant bilag,
skal dette dokumenteres i form af en situationsplan og brandplaner evt. suppleret med beskrivelser.
Er byggeriet ikke indsatstaktisk traditionelt, skal fravigelserne accepteres af kommunalbestyrelsen,
inden der kan meddeles byggetilladelse. Kommunalbestyrelsens accept af dette skal indgÃ¥ i den
brandtekniske dokumentation.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

5. TEGNINGSMATERIALE

5.1 SITUATIONSPLAN
[VEDLÃ†G: Situationsplan]
- Bygningernes placering pÃ¥ ejendommen
- Forhold til anden bebyggelse
- Forhold til naboskel
- Vej- og stimidte

5.2 BRANDPLAN
[VEDLÃ†G: Brandplaner]
- Bygningens eventuelle opdeling i brandmÃ¦ssige enheder
- Placering af rÃ¸galarmer
- Eventuelle redningsÃ¥bninger
[Se Bilag 13 i BR18 vejledningen for krav til udfÃ¦rdigelse af brandplaner]

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

6. NOTAT OM BRANDTEKNISK UDFÃ˜RELSE

[UDFYLD: Notat om brandteknisk udfÃ¸relse]

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

BILAG

FÃ¸lgende bilag skal vedlÃ¦gges:
â–¡ Situationsplan (tegning)
â–¡ Brandplan (tegning)
â–¡ Eventuel godkendelse fra kommunalbestyrelsen (ved fravigelser)
â–¡ Dokumentation for materialevalg
â–¡ Beregninger (hvis relevant)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

NOTER TIL FÃ†RDIGMELDING

Ved fÃ¦rdigmelding skal fÃ¸lgende opdateres/vedlÃ¦gges:
â–¡ Opdateret dokumentation med eventuelle Ã¦ndringer i det fÃ¦rdige byggeri
â–¡ DKV-plan (Drift-, Kontrol- og Vedligeholdelsesplan)
â–¡ BekrÃ¦ftelse pÃ¥ at byggeriet er udfÃ¸rt i overensstemmelse med godkendt dokumentation

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Dette dokument er en skabelon genereret af BR18 Komplet System.
Alle felter markeret med [UDFYLD] og [VEDLÃ†G] skal udfyldes/vedlÃ¦gges fÃ¸r indsendelse til kommunalbestyrelsen.
`;

      // Create and download the document
      docContent = normalizeGeneratedDocumentText(docContent);
      const blob = new Blob([docContent], {type: 'text/plain;charset=utf-8'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `Brandklasse_1_Dokumentation_${today.replace(/\./g, '-')}.txt`;
      a.click();
      URL.revokeObjectURL(url);
      
      // Show confirmation
      alert('Dokumentationsskabelon er genereret og downloadet!\n\nHusk at udfylde alle [UDFYLD] felter og vedlÃ¦gge alle [VEDLÃ†G] dokumenter fÃ¸r indsendelse til kommunalbestyrelsen.');
    }

    // Custom Dropdown Implementation
    function initCustomSelects() {
      document.querySelectorAll('select:not(.custom-select-native)').forEach(select => {
        // Skip if already converted
        if (select.parentElement?.classList.contains('custom-select-wrapper')) return;
        
        // Create wrapper
        const wrapper = document.createElement('div');
        wrapper.className = 'custom-select-wrapper';
        select.parentNode.insertBefore(wrapper, select);
        wrapper.appendChild(select);
        select.classList.add('custom-select-native');
        
        // Create custom select
        const customSelect = document.createElement('div');
        customSelect.className = 'custom-select';
        customSelect.setAttribute('tabindex', '0');
        
        const trigger = document.createElement('div');
        trigger.className = 'custom-select-trigger';
        
        const valueEl = document.createElement('span');
        valueEl.className = 'custom-select-value';
        
        const arrow = document.createElement('span');
        arrow.className = 'custom-select-arrow';
        
        trigger.appendChild(valueEl);
        trigger.appendChild(arrow);
        customSelect.appendChild(trigger);
        
        // Create dropdown
        const dropdown = document.createElement('div');
        dropdown.className = 'custom-select-dropdown';
        
        // Build options
        function buildOptions() {
          dropdown.innerHTML = '';
          let currentGroup = null;
          
          Array.from(select.options).forEach(option => {
            // Skip disabled placeholder options in the dropdown list
            if (option.disabled && option.value === '') {
              return;
            }
            
            // Check for optgroup
            const parentGroup = option.parentElement;
            if (parentGroup.tagName === 'OPTGROUP' && parentGroup !== currentGroup) {
              currentGroup = parentGroup;
              const groupLabel = document.createElement('div');
              groupLabel.className = 'custom-option-group-label';
              groupLabel.textContent = parentGroup.label;
              dropdown.appendChild(groupLabel);
            }
            
            const optionEl = document.createElement('div');
            optionEl.className = 'custom-option';
            if (parentGroup.tagName === 'OPTGROUP') {
              optionEl.classList.add('custom-option-group-item');
            }
            optionEl.textContent = option.textContent;
            optionEl.dataset.value = option.value;
            
            if (option.disabled) {
              optionEl.classList.add('disabled');
            }
            if (option.selected) {
              optionEl.classList.add('selected');
            }
            
            if (!option.disabled) {
              optionEl.addEventListener('click', (e) => {
                e.stopPropagation();
                select.value = option.value;
                select.dispatchEvent(new Event('change', { bubbles: true }));
                updateValue();
                // Close dropdown immediately after selection
                customSelect.classList.remove('open');
                try {
                  const host = customSelect.closest('.acc-item');
                  if (host) host.classList.remove('dropdown-host');
                } catch(_) {}
              });
            }
            
            dropdown.appendChild(optionEl);
          });
        }
        
        function updateValue() {
          const selectedOption = select.options[select.selectedIndex];
          if (selectedOption) {
            // If it's a disabled placeholder or no value selected, show empty/blank
            if ((selectedOption.disabled && selectedOption.value === '') || selectedOption.value === '') {
              valueEl.textContent = '';
              valueEl.classList.add('placeholder');
            } else {
              valueEl.textContent = selectedOption.textContent;
              valueEl.classList.remove('placeholder');
            }
          }
          
          // Update selected state
          dropdown.querySelectorAll('.custom-option').forEach(opt => {
            opt.classList.toggle('selected', opt.dataset.value === select.value);
          });
        }
        
        buildOptions();
        updateValue();
        customSelect.appendChild(dropdown);
        wrapper.appendChild(customSelect);

        // Toggle dropdown (click anywhere on the select box)
        customSelect.addEventListener('click', (e) => {
          // If click originated from inside the dropdown, ignore (dropdown stops propagation too).
          if (dropdown.contains(e.target)) return;
          e.stopPropagation();
          // Close all other dropdowns
          document.querySelectorAll('.custom-select.open').forEach(other => {
            if (other !== customSelect) other.classList.remove('open');
          });
          const willOpen = !customSelect.classList.contains('open');
          customSelect.classList.toggle('open');
          try {
            // Ensure the accordion item containing the open dropdown is above others.
            document.querySelectorAll('.acc-item.dropdown-host').forEach(it => it.classList.remove('dropdown-host'));
            const host = customSelect.closest('.acc-item');
            if (host && willOpen) host.classList.add('dropdown-host');
            if (host && !willOpen) host.classList.remove('dropdown-host');
          } catch(_) {}
        });

        // Prevent interactions inside the dropdown (scrollbar, group labels, whitespace)
        // from bubbling and accidentally toggling/closing the select.
        dropdown.addEventListener('mousedown', (e) => { e.stopPropagation(); });
        dropdown.addEventListener('click', (e) => { e.stopPropagation(); });
        
        // Keyboard navigation
        customSelect.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            customSelect.classList.toggle('open');
          } else if (e.key === 'Escape') {
            customSelect.classList.remove('open');
          } else if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
            e.preventDefault();
            const options = Array.from(select.options).filter(opt => !opt.disabled);
            const currentIndex = options.findIndex(opt => opt.selected);
            let newIndex = currentIndex;
            
            if (e.key === 'ArrowDown') {
              newIndex = Math.min(options.length - 1, currentIndex + 1);
            } else {
              newIndex = Math.max(0, currentIndex - 1);
            }
            
            if (options[newIndex]) {
              select.value = options[newIndex].value;
              select.dispatchEvent(new Event('change', { bubbles: true }));
              updateValue();
            }
          }
        });
        
        // Close on outside click
        document.addEventListener('click', () => {
          customSelect.classList.remove('open');
          try {
            const host = customSelect.closest('.acc-item');
            if (host) host.classList.remove('dropdown-host');
          } catch(_) {}
        });
        
        // Watch for programmatic changes
        const observer = new MutationObserver(() => {
          buildOptions();
          updateValue();
        });
        observer.observe(select, { childList: true, subtree: true, attributes: true, attributeFilter: ['selected'] });
        
        // Watch for value changes
        select.addEventListener('change', updateValue);
        
        // Create a property setter override to catch direct value assignments
        const nativeValueSetter = Object.getOwnPropertyDescriptor(HTMLSelectElement.prototype, 'value').set;
        const customValueSetter = function(val) {
          nativeValueSetter.call(this, val);
          setTimeout(() => updateValue(), 0);
        };
        if (!select.__customValueSet) {
          Object.defineProperty(select, 'value', {
            set: customValueSetter,
            get: function() {
              return this.options[this.selectedIndex]?.value || '';
            },
            configurable: true
          });
          select.__customValueSet = true;
        }
      });
    }

    // Initialize on load
    document.addEventListener('DOMContentLoaded', ()=>{
      console.log('DOM loaded, initializing event listeners...');

      function initStep1FieldListLayout() {
        const accordion = document.getElementById('data-accordion');
        const list = document.getElementById('step1-field-list');
        if (!accordion || !list) return;

        const allFields = Array.from(accordion.querySelectorAll('.form-field'));
        if (allFields.length === 0) return;

        const fieldByControlId = new Map();
        for (const field of allFields) {
          const control = field.querySelector('[id^="fld_"]');
          if (control && control.id) fieldByControlId.set(control.id, field);
        }

        // Requested order (note: â€œfritstaaendeâ€ maps to fld_fritliggende_BA in the current UI)
        const orderedControlIds = [
          'fld_bygningstype',
          'fld_overnatning',
          'fld_kendskab_flugtveje',
          'fld_selvhjulpen',
          'fld_antal_personer_BA',
          'fld_area_BA',
          'fld_area_total',
          'fld_antal_etager_over_terraen_BA',
          'fld_antal_etager_under_terraen_BA',
          'fld_antal_etager_BA',
          'fld_brandbelastning_BA',
          'fld_etage_hoejde_BA',
          'fld_etage_dybde_BA',
          'fld_etage_hoejde',
          'fld_antal_overnattende',
          'fld_fritliggende_BA',
          'fld_med_erhvervssammenbygning',
          'fld_med_tilbygning',
          'fld_direkte_udgange',
          'fld_direkte_udgange_soverum',
          'fld_bygningsafsnit_i_RK4'
        ];

        const used = new Set();
        for (const controlId of orderedControlIds) {
          const field = fieldByControlId.get(controlId);
          if (!field || used.has(field)) continue;
          list.appendChild(field);
          used.add(field);
        }

        // Append any remaining fields (keeps functionality even if not listed in the requested order)
        const remaining = allFields.filter(f => !used.has(f));
        for (const field of remaining) list.appendChild(field);

        // Hide the old accordion shell now that fields are flattened
        accordion.style.display = 'none';
      }

      // Build the long-list layout before initializing custom selects and listeners.
      try { initStep1FieldListLayout(); } catch (_) {}
      
      // Initialize custom selects
      initCustomSelects();
      
      // Re-initialize after dynamic content loads
      const reinitSelects = () => {
        setTimeout(() => initCustomSelects(), 100);
      };
      
      // Ensure the first page starts without pre-filled data.
      function initializeEmptyForm(){
        // Clear numeric/text inputs in the left panel
        document.querySelectorAll('.left-panel .form-field input[type="number"], .left-panel .form-field input[type="text"]').forEach(el => {
          try { el.value = ''; } catch(_) {}
        });
        // Add a placeholder option for selects and reset them to "unselected"
        document.querySelectorAll('.left-panel .form-field select').forEach(sel => {
          try {
            const first = sel.options && sel.options[0];
            const hasPlaceholder = first && first.value === '' && first.disabled;
            if (!hasPlaceholder) {
              const opt = document.createElement('option');
              opt.value = '';
              opt.textContent = 'VÃ¦lgâ€¦';
              opt.disabled = true;
              opt.selected = true;
              sel.insertBefore(opt, sel.firstChild);
            }
            sel.value = '';
          } catch(_) {}
        });
        reinitSelects();
      }
      // Reset gate state on full reload so user can choose anew
      try { sessionStorage.removeItem('reqGateState'); } catch(_) {}
      // Convert native title tooltips to custom tooltips
      document.querySelectorAll('.info-icon[title]').forEach(el => {
        el.setAttribute('data-tip', el.getAttribute('title'));
        el.removeAttribute('title');
        if(!el.textContent.trim()) el.textContent = 'i';
      });

      // JS tooltip that clamps within viewport (prevents left/right overflow)
      const tooltip = document.createElement('div');
      tooltip.id = 'info-tooltip';
      tooltip.setAttribute('role', 'tooltip');
      document.body.appendChild(tooltip);

      const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
      let activeIcon = null;

      function hideTooltip(){
        tooltip.classList.remove('visible', 'above', 'below');
        tooltip.style.left = '-9999px';
        tooltip.style.top = '-9999px';
        activeIcon = null;
      }

      function positionTooltip(iconEl){
        if (!iconEl) return;
        const tip = iconEl.getAttribute('data-tip') || '';
        if (!tip.trim()) return;

        // Set content and show offscreen to measure
        tooltip.textContent = tip;
        tooltip.classList.add('visible');
        tooltip.style.maxWidth = `${Math.min(560, window.innerWidth - 16)}px`;
        tooltip.style.left = '-9999px';
        tooltip.style.top = '-9999px';
        tooltip.classList.remove('above', 'below');
        tooltip.classList.add('above');

        const rect = iconEl.getBoundingClientRect();
        const tRect = tooltip.getBoundingClientRect();
        const margin = 8;
        const gap = 10;

        // Prefer above; flip below if not enough room
        let top = rect.top - tRect.height - gap;
        let placement = 'above';
        if (top < margin) {
          top = rect.bottom + gap;
          placement = 'below';
        }
        tooltip.classList.remove('above', 'below');
        tooltip.classList.add(placement);

        // Default left aligned with icon, but clamp to viewport
        let left = rect.left;
        left = clamp(left, margin, window.innerWidth - margin - tRect.width);

        // Arrow points to icon center, clamped within tooltip bounds
        const iconCenterX = rect.left + rect.width / 2;
        const arrowLeft = clamp(iconCenterX - left, 12, tRect.width - 12);
        tooltip.style.setProperty('--arrow-left', `${arrowLeft}px`);

        tooltip.style.left = `${left}px`;
        tooltip.style.top = `${top}px`;
      }

      function showTooltipFor(iconEl){
        activeIcon = iconEl;
        positionTooltip(iconEl);
      }

      function ensureInfoIconIsCustomTooled(el){
        if (!el) return;
        // Convert on-demand (supports dynamically inserted icons like bilag overlay)
        if (!el.getAttribute('data-tip')){
          const title = el.getAttribute('title');
          if (title && title.trim()){
            el.setAttribute('data-tip', title);
            el.removeAttribute('title');
          }
        }
        if(!el.textContent.trim()) el.textContent = 'i';
      }

      // Delegated hover/focus handlers so dynamically created icons also use custom tooltip
      document.addEventListener('mouseover', (e)=>{
        const iconEl = e.target && e.target.closest ? e.target.closest('.info-icon, .validation-badge') : null;
        if (!iconEl) return;
        const from = e.relatedTarget;
        if (from && iconEl.contains(from)) return; // still inside same icon
        ensureInfoIconIsCustomTooled(iconEl);
        showTooltipFor(iconEl);
      }, true);
      document.addEventListener('mouseout', (e)=>{
        const iconEl = e.target && e.target.closest ? e.target.closest('.info-icon, .validation-badge') : null;
        if (!iconEl) return;
        const to = e.relatedTarget;
        if (to && iconEl.contains(to)) return;
        hideTooltip();
      }, true);
      document.addEventListener('focusin', (e)=>{
        const iconEl = e.target && e.target.closest ? e.target.closest('.info-icon, .validation-badge') : null;
        if (!iconEl) return;
        ensureInfoIconIsCustomTooled(iconEl);
        showTooltipFor(iconEl);
      }, true);
      document.addEventListener('focusout', (e)=>{
        const iconEl = e.target && e.target.closest ? e.target.closest('.info-icon, .validation-badge') : null;
        if (!iconEl) return;
        hideTooltip();
      }, true);

      window.addEventListener('scroll', ()=>{ if (activeIcon) positionTooltip(activeIcon); }, true);
      window.addEventListener('resize', ()=>{ if (activeIcon) positionTooltip(activeIcon); });

      // Step 3: lockable, draggable panel for Krav_Korrekt_Dimensionering
      const dimPanel = document.getElementById('krav-dim-panel');
      const dimHeader = document.getElementById('krav-dim-header');
      const dimBody = document.getElementById('krav-dim-body');
      const dimPinBtn = document.getElementById('krav-dim-pin');
      const dimCloseBtn = document.getElementById('krav-dim-close');
      const dimTitleEl = document.getElementById('krav-dim-title');
      let dimPinned = false;
      let dimActiveSource = null;
      let dimHideTimer = null;
      let dragging = false;
      let dragOffsetX = 0;
      let dragOffsetY = 0;

      function hideDim(force = false){
        if (!dimPanel) return;
        if (dimPinned && !force) return;
        dimPanel.style.display = 'none';
        dimPanel.setAttribute('aria-hidden', 'true');
        dimActiveSource = null;
      }

      function scheduleHide(){
        if (dimHideTimer) clearTimeout(dimHideTimer);
        dimHideTimer = setTimeout(()=> hideDim(false), 180);
      }

      function showDim(text, anchorEl, title){
        if (!dimPanel || !dimBody) return;
        const t = (text || '').trim();
        if (!t) return;

        const parts = t.replace(/\r\n/g, '\n').split(/\n\s*\n/g).map(p => p.trim()).filter(Boolean);
        
        // Check validation status for dimensionering
        const kravId = (title || '').trim();
        const kravValidation = validationData.krav?.[kravId] || {};
        const isValidated = kravValidation.dimensionering || false;
        
        const validationBadgeHtml = `
          <div style="
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 14px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 12px;
            ${isValidated 
              ? 'background: #d1fae5; color: #065f46;' 
              : 'background: #fee2e2; color: #991b1b;'}
          ">
            ${isValidated ? 'âœ“ Valideret' : 'âœ— Ikke valideret'}
          </div>
        `;
        
        dimBody.innerHTML = parts.map(p => `<p>${escapeHtml(p)}</p>`).join('');
        if (dimTitleEl) {
          const extra = (title || '').trim();
          dimTitleEl.innerHTML = (extra ? `Uddybning (${extra})` : 'Uddybning (korrekt dimensionering)') + validationBadgeHtml;
        }

        // Position near anchor
        if (anchorEl) {
          const rect = anchorEl.getBoundingClientRect();
          const margin = 10;
          // Measure after making visible offscreen
          dimPanel.style.display = 'block';
          dimPanel.style.left = '-9999px';
          dimPanel.style.top = '-9999px';
          dimPanel.setAttribute('aria-hidden', 'false');
          const pRect = dimPanel.getBoundingClientRect();

          const preferredLeft = rect.right + 12;
          const preferredTop = rect.top - 12;
          const left = clamp(preferredLeft, margin, window.innerWidth - margin - pRect.width);
          const top = clamp(preferredTop, margin, window.innerHeight - margin - pRect.height);
          dimPanel.style.left = `${left}px`;
          dimPanel.style.top = `${top}px`;
        } else {
          dimPanel.style.display = 'block';
          dimPanel.setAttribute('aria-hidden', 'false');
        }

        if (dimPinBtn) dimPinBtn.textContent = dimPinned ? 'LÃ¥s op' : 'LÃ¥s';
      }

      if (dimCloseBtn) dimCloseBtn.addEventListener('click', ()=>{ dimPinned = false; hideDim(true); if (dimPinBtn) dimPinBtn.textContent = 'LÃ¥s'; });
      if (dimPinBtn) dimPinBtn.addEventListener('click', ()=>{ dimPinned = !dimPinned; if (dimPinBtn) dimPinBtn.textContent = dimPinned ? 'LÃ¥s op' : 'LÃ¥s'; if (!dimPinned) scheduleHide(); });

      // Delegated hover/click behavior on question icons
      document.addEventListener('mouseover', (e)=>{
        const icon = e.target && e.target.closest ? e.target.closest('.q-icon') : null;
        if (!icon) return;
        if (dimHideTimer) { clearTimeout(dimHideTimer); dimHideTimer = null; }
        const text = icon.getAttribute('data-dim') || '';
        const title = icon.getAttribute('data-dim-title') || '';
        const source = `${title}::${text.slice(0, 64)}`;
        if (dimPinned && dimActiveSource && dimActiveSource !== source) return;
        dimActiveSource = source;
        showDim(text, icon, title);
      }, true);
      document.addEventListener('mouseout', (e)=>{
        const icon = e.target && e.target.closest ? e.target.closest('.q-icon') : null;
        if (!icon) return;
        if (!dimPinned) scheduleHide();
      }, true);
      document.addEventListener('click', (e)=>{
        const icon = e.target && e.target.closest ? e.target.closest('.q-icon') : null;
        if (!icon) return;
        const text = icon.getAttribute('data-dim') || '';
        const title = icon.getAttribute('data-dim-title') || '';
        const source = `${title}::${text.slice(0, 64)}`;
        if (!dimPinned) {
          dimPinned = true;
          dimActiveSource = source;
          showDim(text, icon, title);
        } else if (dimActiveSource === source) {
          dimPinned = false;
          if (dimPinBtn) dimPinBtn.textContent = 'LÃ¥s';
          scheduleHide();
        }
        if (dimPinBtn) dimPinBtn.textContent = dimPinned ? 'LÃ¥s op' : 'LÃ¥s';
      }, true);

      // Dragging panel
      if (dimHeader && dimPanel) {
        dimHeader.addEventListener('mousedown', (e)=>{
          const btn = e.target && e.target.closest ? e.target.closest('button') : null;
          if (btn) return;
          dragging = true;
          const rect = dimPanel.getBoundingClientRect();
          dragOffsetX = e.clientX - rect.left;
          dragOffsetY = e.clientY - rect.top;
          e.preventDefault();
        });
        window.addEventListener('mousemove', (e)=>{
          if (!dragging) return;
          const margin = 8;
          const rect = dimPanel.getBoundingClientRect();
          const left = clamp(e.clientX - dragOffsetX, margin, window.innerWidth - margin - rect.width);
          const top = clamp(e.clientY - dragOffsetY, margin, window.innerHeight - margin - rect.height);
          dimPanel.style.left = `${left}px`;
          dimPanel.style.top = `${top}px`;
        });
        window.addEventListener('mouseup', ()=>{ dragging = false; });
      }

      // Load example button
      const loadBtn = document.getElementById('load-example');
      if (loadBtn) loadBtn.addEventListener('click', async ()=>{
        try {
          // Fetch input1.json from backend API host
          const resp = await fetch(`${API_BASE}/input1.json`);
          if(!resp.ok) throw new Error('Kan ikke hente input1.json');
          const exampleJson = await resp.json();
          // Normalize example payload so the advanced JSON view is stable and complete.
          const canonical = canonicalizeInputData(exampleJson);
          const merged = { ...canonical, ...getActiveBilagExtras() };
          if (merged.med_tilbygning === undefined) merged.med_tilbygning = null;
          if (merged.med_erhvervssammenbygning === undefined) merged.med_erhvervssammenbygning = null;
          jsonTextarea.value = JSON.stringify(merged, null, 2);

          // Loading an example is not a "manual JSON edit"; keep form as source of truth.
          jsonManualEdit = false;
          try { 
            syncingFromJson = true; 
            updateFormFromJson(merged);
            // Capture the loaded data to the current section so it doesn't leak to other sections
            captureInputsToSection(getActiveSectionIndex());
            // Force refresh of all custom dropdowns after a short delay
            setTimeout(() => {
              // Re-create all custom dropdowns to reflect new values
              if (typeof initCustomSelects === 'function') {
                initCustomSelects();
              }
              // Also manually trigger updateValue for each custom select
              document.querySelectorAll('.custom-select-wrapper').forEach(wrapper => {
                const customSelect = wrapper.querySelector('.custom-select-value');
                const select = wrapper.querySelector('select');
                if (select && customSelect) {
                  const selectedOpt = select.options[select.selectedIndex];
                  if (selectedOpt && selectedOpt.value !== '') {
                    customSelect.textContent = selectedOpt.textContent;
                    customSelect.classList.remove('placeholder');
                  } else {
                    customSelect.textContent = '';
                    customSelect.classList.add('placeholder');
                  }
                }
              });
            }, 150);
          } catch(_) {} finally { syncingFromJson = false; }
          updateStatus();
          scheduleEvaluate();
        } catch(err){
          console.error('Failed to fetch input1.json from server:', err);
          alert('Kan ikke hente input1.json fra serveren. Tjek at backend kÃ¸rer pÃ¥ http://127.0.0.1:8000 og at /input1.json kan tilgÃ¥s.');
        }
      });

      // Wire up wizard navigation buttons
      ['btn-continue-step1', 'btn-continue-step1-top'].forEach(id => {
        const btn = document.getElementById(id);
        if (!btn) return;
        btn.addEventListener('click', () => {
          openPrestepOverlay();
        });
      });

      // Pre-step overlay navigation
      const prestepOverlay = document.getElementById('prestep-overlay');
      const prestepClose = document.getElementById('prestep-close');
      const prestepBack = document.getElementById('prestep-back');
      const prestepNext = document.getElementById('prestep-next');
      const prestepSkip = document.getElementById('prestep-skip');

      if (prestepOverlay){
        prestepOverlay.addEventListener('click', (e)=>{ if (e.target === prestepOverlay) closePrestepOverlay(); });
      }
      if (prestepClose) prestepClose.addEventListener('click', ()=> closePrestepOverlay());
      if (prestepBack) prestepBack.addEventListener('click', ()=>{ prestepState.index = Math.max(0, prestepState.index - 1); renderPrestepOverlay(); });
      if (prestepNext) prestepNext.addEventListener('click', async ()=>{
        const last = prestepState.index >= (prestepState.pages.length - 1);
        if (last){
          closePrestepOverlay();
          goToStep(2);
          // Show the design-check popup on top of Step 2 (so Step 2 is visible behind it)
          try { await showProceedToKravPopup(); } catch(_) {}
          return;
        }
        prestepState.index = Math.min(prestepState.pages.length - 1, prestepState.index + 1);
        renderPrestepOverlay();
      });
      if (prestepSkip) prestepSkip.addEventListener('click', async ()=>{
        closePrestepOverlay();
        goToStep(2);
        try { await showProceedToKravPopup(); } catch(_) {}
      });

      const btnNext2 = document.getElementById('btn-continue-step2');
      if (btnNext2) btnNext2.addEventListener('click', async ()=>{
        try {
          await openBilagOverlay();
        } catch (_) {
          // Fallback: proceed without bilag inputs
          goToStep(3);
        }
      });

      const back2 = document.getElementById('btn-back-step2');
      if (back2) back2.addEventListener('click', ()=>{ goToStep(1); });

      const back3 = document.getElementById('btn-back-step3');
      if (back3) back3.addEventListener('click', ()=>{ goToStep(2); });

      const continue3 = document.getElementById('btn-continue-step3');
      if (continue3) continue3.addEventListener('click', ()=>{ goToStep(4); });
      
      const continue3Top = document.getElementById('btn-continue-step3-top');
      if (continue3Top) continue3Top.addEventListener('click', ()=>{ goToStep(4); });

      const back4 = document.getElementById('btn-back-step4');
      if (back4) back4.addEventListener('click', ()=>{ goToStep(3); });

      const exportPdf = document.getElementById('btn-export-pdf');
      if (exportPdf) exportPdf.addEventListener('click', ()=>{ 
        alert('PDF eksport kommer snart!'); 
      });

      const exportJson = document.getElementById('btn-export-json');
      if (exportJson) exportJson.addEventListener('click', ()=>{ 
        const data = {
          version: '1.0',
          exportedAt: new Date().toISOString(),
          buildings: {
            count: buildingsState.count,
            titles: buildingsState.titles,
            buildings: buildingsState.buildings,
            lastActiveSection: buildingsState.lastActiveSection
          }
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'brandklassificering_export.json';
        a.click();
        URL.revokeObjectURL(url);
      });

      const newProject = document.getElementById('btn-new-project');
      if (newProject) newProject.addEventListener('click', ()=>{ 
        if (confirm('Er du sikker pÃ¥ at du vil starte et nyt projekt? Al data gÃ¥r tabt.')) {
          location.reload();
        }
      });

      // Documentation generator overlay wiring
      document.addEventListener('click', (e) => {
        if (e.target && e.target.id === 'btn-open-doc-generator') {
          openDocGeneratorOverlay();
        }
      });
      
      const docGenOverlay = document.getElementById('doc-generator-overlay');
      const docGenClose = document.getElementById('doc-gen-close');
      const docGenCancel = document.getElementById('doc-gen-cancel');
      const docGenExportPdf = document.getElementById('doc-gen-export-pdf');
      const docGenExportHtml = document.getElementById('doc-gen-export-html');
      const docGenExportDocx = document.getElementById('doc-gen-export-docx');
      const docGenGenerate = document.getElementById('doc-gen-generate');
      
      if (docGenOverlay) {
        docGenOverlay.addEventListener('click', (e) => {
          if (e.target === docGenOverlay) closeDocGeneratorOverlay();
        });
      }
      if (docGenClose) docGenClose.addEventListener('click', closeDocGeneratorOverlay);
      if (docGenCancel) docGenCancel.addEventListener('click', closeDocGeneratorOverlay);
      if (docGenExportPdf) docGenExportPdf.addEventListener('click', async () => {
        try { await exportDocOverlayAsPdf(); }
        catch (e) { console.error(e); alert('Kunne ikke lave PDF. Tjek Console (F12) for fejl.'); }
      });
      if (docGenExportHtml) docGenExportHtml.addEventListener('click', async () => {
        try { await exportDocOverlayAsHtml(); }
        catch (e) { console.error(e); alert('Kunne ikke lave Print. Tjek Console (F12) for fejl.'); }
      });
      if (docGenExportDocx) docGenExportDocx.addEventListener('click', async () => {
        try { await exportDocOverlayAsDocx(); }
        catch (e) { console.error(e); alert('Kunne ikke lave Word (DOCX). Tjek Console (F12) for fejl.'); }
      });
      if (docGenGenerate) docGenGenerate.addEventListener('click', generateDocumentFromOverlay);

      populateBygningstypeOptions();
      initializeEmptyForm();
      updateStatus();

      // Bilag overlay wiring
      const bilagOverlay = document.getElementById('bilag-overlay');
      const bilagClose = document.getElementById('bilag-close');
      const bilagSave = document.getElementById('bilag-save');
      const bilagSkip = document.getElementById('bilag-skip');
      const bilagReset = document.getElementById('bilag-reset');
      if (bilagOverlay){
        bilagOverlay.addEventListener('click', (e)=>{ if (e.target === bilagOverlay) closeBilagOverlay(); });
      }
      if (bilagClose) bilagClose.addEventListener('click', ()=> closeBilagOverlay());
      if (bilagReset) bilagReset.addEventListener('click', ()=> resetBilagAnswers());
      if (bilagSkip) bilagSkip.addEventListener('click', ()=>{ closeBilagOverlay(); goToStep(3); });
      if (bilagSave) bilagSave.addEventListener('click', ()=>{
        try { saveBilagAnswers(); } catch(_) {}
        closeBilagOverlay();
        goToStep(3);
      });

      // Brandklasse inputs now live on Step 1; keep extras in sync
      const areaTotalEl = document.getElementById('fld_area_total');
      const tilbygEl = document.getElementById('fld_med_tilbygning');
      const erhvEl = document.getElementById('fld_med_erhvervssammenbygning');

      const syncBrandklasseExtras = () => {
        if (tilbygEl && (tilbygEl.value === 'true' || tilbygEl.value === 'false')) {
          setActiveBilagExtra('med_tilbygning', tilbygEl.value === 'true');
        }
        if (erhvEl && (erhvEl.value === 'true' || erhvEl.value === 'false')) {
          setActiveBilagExtra('med_erhvervssammenbygning', erhvEl.value === 'true');
        }
        // Keep JSON pane in sync when user isn't editing JSON manually
        try {
          if (!syncingFromJson && !jsonManualEdit) {
            const merged = { ...canonicalizeInputData(buildJsonFromForm()), ...getActiveBilagExtras() };
            if (merged.med_tilbygning === undefined) merged.med_tilbygning = null;
            if (merged.med_erhvervssammenbygning === undefined) merged.med_erhvervssammenbygning = null;
            jsonTextarea.value = JSON.stringify(merged, null, 2);
          }
        } catch(_) {}
      };

      const onBrandklasseInput = ()=>{
        syncBrandklasseExtras();
        scheduleBrandklasseEvaluate();
      };
      if (areaTotalEl) areaTotalEl.addEventListener('input', onBrandklasseInput);
      if (tilbygEl) tilbygEl.addEventListener('change', onBrandklasseInput);
      if (erhvEl) erhvEl.addEventListener('change', onBrandklasseInput);
      // Attach auto-evaluate triggers
      document.querySelectorAll('.left-panel .form-field input, .left-panel .form-field select').forEach(el => {
        const onFormEdit = ()=>{
          // NÃ¥r brugeren retter i formularen, er formularen "source of truth"
          jsonManualEdit = false;
          // Auto-calculate brandklasse from Step 1 when total area is present.
          try {
            if (currentStep === 1 && asNum('fld_area_total') !== null) {
              scheduleBrandklasseEvaluate();
            }
          } catch(_) {}
          scheduleEvaluate();
        };
        el.addEventListener('input', onFormEdit);
        el.addEventListener('change', onFormEdit);
      });
      let jsonSyncTimer = null;
      jsonTextarea.addEventListener('input', ()=>{ 
        // NÃ¥r brugeren retter i JSON, er JSON "source of truth"
        jsonManualEdit = true;
        if (jsonSyncTimer) clearTimeout(jsonSyncTimer);
        jsonSyncTimer = setTimeout(()=>{
          try {
            const obj = JSON.parse(jsonTextarea.value);
            syncingFromJson = true;
            updateFormFromJson(obj);
          } catch(_) {
            // keep form as-is if JSON invalid
          } finally {
            syncingFromJson = false;
          }
          updateStatus();
          scheduleEvaluate();
        }, 250);
      });
      
      // Initialize buildings + sections (start with 1 building containing 1 section)
      try { setActiveBuildingIndex(0); } catch(_) {
        // Fallback to legacy init
        renderSectionTabs();
        setActiveSectionIndex(0);
      }

      // Load validation data on page load
      loadValidation();

      // No initial evaluation on page load; evaluate when user edits or loads an example.
    });
  </script>

  <!-- Validation Modal -->
  <div id="validation-modal" class="validation-modal">
    <div class="validation-content">
      <div class="validation-header">
        <h2>ðŸ” BrandrÃ¥dgiver Validering</h2>
        <button id="close-validation" style="background: none; border: none; font-size: 28px; cursor: pointer; color: #64748b;">Ã—</button>
      </div>
      <div class="validation-tabs">
        <button class="validation-tab active" data-tab="anvendelseskategori">Anvendelseskategori</button>
        <button class="validation-tab" data-tab="risikoklasse">Risikoklasse</button>
        <button class="validation-tab" data-tab="relevant-bilag">Relevant Bilag</button>
        <button class="validation-tab" data-tab="brandklasse">Brandklasse</button>
        <button class="validation-tab" data-tab="krav">Krav</button>
      </div>
      <div class="validation-body">
        <div id="validation-anvendelseskategori" class="validation-section active">
          <!-- Anvendelseskategori tables -->
        </div>
        <div id="validation-risikoklasse" class="validation-section">
          <!-- Risikoklasse tables -->
        </div>
        <div id="validation-relevant-bilag" class="validation-section">
          <!-- Relevant bilag tables -->
        </div>
        <div id="validation-brandklasse" class="validation-section">
          <!-- Brandklasse tables -->
        </div>
        <div id="validation-krav" class="validation-section">
          <!-- Krav content will be inserted here -->
        </div>
      </div>
      <div class="validation-footer">
        <button id="import-validation" class="btn-secondary">ImportÃ©r Validering</button>
        <button id="export-validation" class="btn-primary">EksportÃ©r Validering</button>
      </div>
    </div>
  </div>

  <script>
    // Validation system
    let validationData = {
      version: "1.0",
      lastUpdated: "",
      validatedBy: "",
      decisionTables: {},
      krav: {}
    };

    // Load existing validation if available
    async function loadValidation() {
      try {
        console.log('[Validation] Loading validation.json...');
        const resp = await fetch('validation/validation.json?v=' + Date.now(), { cache: 'no-store' });
        if (resp.ok) {
          const data = await resp.json();
          validationData = data;
          console.log('[Validation] Successfully loaded validation data:', validationData);
          updateValidationStatus();
          return true;
        } else {
          console.log('[Validation] Failed to load validation.json, status:', resp.status);
        }
      } catch(e) {
        console.log('[Validation] Error loading validation data:', e.message);
      }
      return false;
    }

    // Update validation status display
    function updateValidationStatus() {
      // Count validated items
      const validatedDT = Object.values(validationData.decisionTables || {}).filter(v => v.validated).length;
      const totalDT = Object.keys(validationData.decisionTables || {}).length;
      
      // Count krav with granular validation
      let fullyValidatedKrav = 0;
      let partiallyValidatedKrav = 0;
      const totalKrav = Object.keys(validationData.krav || {}).length;
      
      Object.values(validationData.krav || {}).forEach(krav => {
        let validatedCount = 0;
        let totalCount = 0;
        
        if (krav.beskrivelse !== undefined) {
          totalCount++;
          if (krav.beskrivelse) validatedCount++;
        }
        if (krav.tjekliste && typeof krav.tjekliste === 'object') {
          const tlist = Object.keys(krav.tjekliste);
          totalCount += tlist.length;
          validatedCount += tlist.filter(k => krav.tjekliste[k]).length;
        }
        if (krav.dimensionering !== undefined) {
          totalCount++;
          if (krav.dimensionering) validatedCount++;
        }
        
        if (totalCount > 0 && validatedCount === totalCount) {
          fullyValidatedKrav++;
        } else if (validatedCount > 0) {
          partiallyValidatedKrav++;
        }
      });
      
      console.log(`Validation status: DT ${validatedDT}/${totalDT}, Krav ${fullyValidatedKrav} fuldt, ${partiallyValidatedKrav} delvist af ${totalKrav} total`);
      
      // NEVER show the topbar badge - it should always be hidden
      const badge = document.getElementById('validation-status-badge');
      if (badge) {
        badge.style.display = 'none';
      }
    }

    // Open validation modal
    document.getElementById('validation-btn').addEventListener('click', async () => {
      await loadValidation();
      await renderValidationContent();
      document.getElementById('validation-modal').classList.add('show');
    });

    // Close validation modal
    document.getElementById('close-validation').addEventListener('click', () => {
      document.getElementById('validation-modal').classList.remove('show');
    });

    // Tab switching
    document.querySelectorAll('.validation-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        const targetTab = tab.dataset.tab;
        document.querySelectorAll('.validation-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.validation-section').forEach(s => s.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(`validation-${targetTab}`).classList.add('active');
      });
    });

    // Render validation content
    async function renderValidationContent() {
      await renderDecisionTables();
      await renderKravValidation();
    }

    // Render decision tables from Brandklasse_Bestemmelse.json
    async function renderDecisionTables() {
      try {
        const resp = await fetch(`${API_BASE}/Brandklasse_Bestemmelse.json?v=${Date.now()}`, { cache: 'no-store' });
        const data = await resp.json();
        
        const tables = data.nodes.filter(n => n.type === 'decisionTableNode');
        
        // Categorize tables by type
        const tablesByType = {
          anvendelseskategori: tables.filter(t => t.name?.toLowerCase().includes('anvendelseskategori')),
          risikoklasse: tables.filter(t => t.name?.toLowerCase().includes('risikoklasse')),
          'relevant-bilag': tables.filter(t => t.name?.toLowerCase().includes('bilag') && !t.name?.toLowerCase().includes('brand')),
          brandklasse: tables.filter(t => t.name?.toLowerCase().includes('prÃ¦-accepterede') || t.name?.toLowerCase().includes('brandklasse'))
        };
        
        // Render each category
        for (const [type, typeTables] of Object.entries(tablesByType)) {
          const container = document.getElementById(`validation-${type}`);
          if (!container) continue;
          
          if (typeTables.length === 0) {
            container.innerHTML = '<p class="muted" style="padding:20px;">Ingen decision tables fundet for denne kategori.</p>';
            continue;
          }
          
          let html = '';
          
          for (const table of typeTables) {
            const tableName = escapeHtml(table.name || 'Unavngivet tabel');
            html += `<div class="validation-item">`;
            html += `<div style="font-size: 18px; font-weight: 700; margin-bottom: 16px; color: #0f172a;">${tableName}</div>`;
            
            if (table.content && table.content.rules) {
              table.content.rules.forEach((rule, idx) => {
                const ruleId = `${table.id}_rule_${idx}`;
                const isValidated = validationData.decisionTables[ruleId]?.validated || false;
                const comment = validationData.decisionTables[ruleId]?.comment || '';
                
                html += `<div class="decision-rule">`;
                html += `<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">`;
                html += `<div style="font-weight:600;">Regel ${idx + 1}</div>`;
                html += `<div class="validation-checkbox">`;
                html += `<input type="checkbox" id="dt_${ruleId}" ${isValidated ? 'checked' : ''}>`;
                html += `<label for="dt_${ruleId}">Valideret</label>`;
                html += `</div>`;
                html += `</div>`;
                
                if (rule._description) {
                  html += `<div style="margin-bottom:8px; color:#64748b; font-size:13px;">${escapeHtml(rule._description)}</div>`;
                }
                
                // Show conditions (only input columns, not outputs)
                const conditions = [];
                const outputIds = table.content.outputs?.map(o => o.id) || [];
                for (const [key, value] of Object.entries(rule)) {
                  if (!key.startsWith('_') && value && value !== '' && !outputIds.includes(key)) {
                    const col = table.content.inputs?.find(i => i.id === key);
                    const colName = col?.name || key.substring(0, 8);
                    conditions.push(`<div class="rule-condition"><strong>${escapeHtml(colName)}:</strong> ${escapeHtml(value)}</div>`);
                  }
                }
                
                if (conditions.length > 0) {
                  html += `<div class="rule-conditions">${conditions.join('')}</div>`;
                }
                
                // Show result
                const outputKeys = Object.keys(rule).filter(k => !k.startsWith('_') && table.content.outputs?.some(o => o.id === k));
                if (outputKeys.length > 0) {
                  const output = table.content.outputs.find(o => o.id === outputKeys[0]);
                  const outputName = output?.name || 'Resultat';
                  html += `<div class="rule-result"><strong>${escapeHtml(outputName)}:</strong> ${escapeHtml(rule[outputKeys[0]])}</div>`;
                }
                
                html += `<textarea class="validation-comment" placeholder="TilfÃ¸j kommentarer..." data-id="dt_${ruleId}">${escapeHtml(comment)}</textarea>`;
                html += `</div>`;
              });
            }
            
            html += `</div>`;
          }
          
          container.innerHTML = html;
          
          // Add event listeners
          container.querySelectorAll('input[type="checkbox"]').forEach(cb => {
            cb.addEventListener('change', (e) => {
              const id = e.target.id.replace('dt_', '');
              if (!validationData.decisionTables[id]) validationData.decisionTables[id] = {};
              validationData.decisionTables[id].validated = e.target.checked;
            });
          });
          
          container.querySelectorAll('textarea').forEach(ta => {
            ta.addEventListener('change', (e) => {
              const id = e.target.dataset.id.replace('dt_', '');
              if (!validationData.decisionTables[id]) validationData.decisionTables[id] = {};
              validationData.decisionTables[id].comment = e.target.value;
            });
          });
        }
        
      } catch(e) {
        console.error('[Validation] Error rendering decision tables:', e);
      }
    }

    // Render krav validation
    async function renderKravValidation(selectedBilag = null) {
      const container = document.getElementById('validation-krav');
      container.innerHTML = '<div style="text-align:center; padding:20px;">IndlÃ¦ser krav...</div>';
      
      try {
        const resp = await fetch(`${API_BASE}/Krav.json?v=${Date.now()}`, { cache: 'no-store' });
        if (!resp.ok) throw new Error('Kunne ikke indlÃ¦se Krav.json');
        const kravData = await resp.json();

        let html = '<h3 style="margin-top:0;">Krav</h3>';
        html += '<p class="muted">Viser alle krav-regler fra Krav.json. VÃ¦lg et bilag nedenfor for at filtrere krav efter relevant bilag.</p>';

        const esc = (s) => {
          const str = String(s ?? '');
          return str
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
        };
        const escWithNewlines = (s) => {
          const escaped = esc(s);
          return escaped.replace(/\\n/g, '\n');
        };
        const fmtVal = (v) => {
          if (v === null || v === undefined) return '';
          if (Array.isArray(v)) return v.map(x => String(x)).join('\n');
          if (typeof v === 'object') {
            try { return JSON.stringify(v, null, 2); } catch(_) { return String(v); }
          }
          return String(v);
        };
        const cleanModelString = (value) => {
          if (value === null || value === undefined) return value;
          if (typeof value !== 'string') return value;
          let s = value.trim();
          if (s.length >= 2 && s.startsWith('"') && s.endsWith('"')) s = s.slice(1, -1);
          return s;
        };
        const pick = (obj, keys) => {
          for (const k of keys) {
            const v = obj?.[k];
            if (v !== null && v !== undefined && String(v).trim() !== '') return v;
          }
          return '';
        };
        const makeDomSafe = (s) => String(s ?? '').replace(/[^a-zA-Z0-9_-]/g, '_');

        const nodes = Array.isArray(kravData?.nodes) ? kravData.nodes : [];
        const decisionNode = nodes.find(n => n?.type === 'decisionTableNode' && /designkrav/i.test(String(n?.name || '')))
          || nodes.find(n => n?.type === 'decisionTableNode');
        if (!decisionNode?.content?.rules || !Array.isArray(decisionNode.content.rules)) {
          container.innerHTML = html + '<div style="color:#ef4444; padding:20px;">Kunne ikke finde decision table regler i Krav.json</div>';
          return;
        }

        const inputs = Array.isArray(decisionNode.content.inputs) ? decisionNode.content.inputs : [];
        const outputs = Array.isArray(decisionNode.content.outputs) ? decisionNode.content.outputs : [];
        
        const inputsMap = {};
        inputs.forEach(i => {
          if (i && typeof i === 'object' && i.field && i.id) inputsMap[i.field] = i.id;
        });
        
        const outputsMap = {};
        outputs.forEach(o => {
          if (o && typeof o === 'object' && o.field && o.id) outputsMap[o.field] = o.id;
        });

        // Collect all unique bilag values from INPUT field
        const bilagInputId = inputsMap['Relevant_bilag'];
        console.log('[Krav Validation] Relevant_bilag INPUT ID:', bilagInputId);
        
        const bilagSet = new Set();
        decisionNode.content.rules.forEach((rule, idx) => {
          const bilagVal = rule?.[bilagInputId];
          if (idx < 3) console.log(`[Krav Validation] Rule ${idx} bilagVal:`, bilagVal, typeof bilagVal);
          if (bilagVal !== null && bilagVal !== undefined && bilagVal !== '') {
            const strVal = String(bilagVal).trim();
            if (strVal) bilagSet.add(strVal);
          }
        });
        
        const allBilag = Array.from(bilagSet).sort((a, b) => {
          const numA = parseFloat(a) || 0;
          const numB = parseFloat(b) || 0;
          return numA - numB;
        });
        
        console.log('[Krav Validation] Found bilag values:', allBilag);

        // Add bilag filter dropdown
        html += `<div style="margin:10px 0 16px;">`;
        html += `<label for="bilag-filter" style="font-weight:600; margin-right:8px;">FiltrÃ©r efter bilag:</label>`;
        html += `<select id="bilag-filter" style="padding:6px 12px; border:1px solid #d1d5db; border-radius:6px; font-size:14px;">`;
        html += `<option value="">Alle bilag</option>`;
        allBilag.forEach(b => {
          const sel = selectedBilag === b ? ' selected' : '';
          html += `<option value="${esc(b)}"${sel}>Bilag ${esc(b)}</option>`;
        });
        html += `</select>`;
        html += `</div>`;

        // Filter rules based on selected bilag
        const filteredRules = selectedBilag
          ? decisionNode.content.rules.filter(rule => {
              const bilagVal = rule?.[bilagInputId];
              return bilagVal !== null && bilagVal !== undefined && String(bilagVal).trim() === selectedBilag;
            })
          : decisionNode.content.rules;

        const totalRules = decisionNode.content.rules.length;
        const filteredCount = filteredRules.length;
        
        if (selectedBilag) {
          html += `<div class="muted" style="margin:10px 0 16px;">Viser <strong>${esc(String(filteredCount))}</strong> regler for bilag ${esc(selectedBilag)} &nbsp;â€¢&nbsp; <strong>${esc(String(totalRules))}</strong> regler i alt</div>`;
        } else {
          html += `<div class="muted" style="margin:10px 0 16px;"><strong>${esc(String(totalRules))}</strong> regler i Krav.json</div>`;
        }

        filteredRules.forEach((rule, origIdx) => {
          const idx = decisionNode.content.rules.indexOf(rule);
          const ruleId = `${decisionNode.id}_rule_${idx}`;
          const ruleNo = idx + 1;

          const out = {};
          Object.keys(outputsMap).forEach(field => {
            const oid = outputsMap[field];
            out[field] = cleanModelString(rule?.[oid]);
          });
          out._matched_rule_id = ruleId;
          out._matched_rule_number = ruleNo;
          out._matched_node_name = decisionNode?.name || 'Designkrav';

          const kravId = pick(out, ['Krav_id']) || `krav_${ruleNo}`;
          const title = pick(out, ['Krav_Titel']) || 'Krav';
          const type = pick(out, ['Krav_Undertitel']);
          const beskrivelse = pick(out, ['Krav_Beskrivelse']);
          const tjekliste = pick(out, ['Krav_Tjekliste']);
          const dim = pick(out, ['Krav_Korrekt_Dimensionering']);

          const key = String(kravId);
          
          // Initialize validation structure if needed
          if (!validationData.krav[key]) {
            validationData.krav[key] = {
              beskrivelse: false,
              tjekliste: {},
              dimensionering: false,
              comment: ''
            };
          }
          
          const kravValidation = validationData.krav[key];
          const comment = kravValidation.comment || '';

          const domId = `krav_${makeDomSafe(kravId)}_${ruleNo}`;

          html += `<div class="validation-item">`;
          html += `<div class="validation-item-header">`;
          html += `<div class="validation-item-title">`;
          html += `Krav ${esc(kravId)}: ${esc(title)}`;
          html += `</div>`;
          html += `</div>`;

          if (type) html += `<div style="margin-bottom:8px;"><strong>Undertitel:</strong> ${escWithNewlines(type)}</div>`;
          
          // Beskrivelse with individual validation
          if (beskrivelse) {
            const beskrivelseValidated = kravValidation.beskrivelse || false;
            html += `<div style="margin-bottom:10px; padding:16px; background:white; border-radius:8px; border:1px solid #e5e7eb;">`;
            html += `<div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">`;
            html += `<div style="font-weight:600; color:#0f172a;">Beskrivelse</div>`;
            html += `<label style="display:flex; align-items:center; justify-content:flex-end; cursor:pointer; width:24px; flex-shrink:0;">`;
            html += `<input type="checkbox" class="validation-item-checkbox" data-key="${esc(key)}" data-type="beskrivelse" ${beskrivelseValidated ? 'checked' : ''} style="width:20px; height:20px; cursor:pointer; accent-color:#10b981; margin:0;">`;
            html += `</label>`;
            html += `</div>`;
            html += `<div style="white-space:pre-wrap; color:#475569; line-height:1.6;">${escWithNewlines(beskrivelse)}</div>`;
            html += `</div>`;
          }
          
          // Tjekliste with individual validation per item
          if (tjekliste) {
            const tlist = String(tjekliste).split(/\\n|\n/).map(l => l.trim()).filter(l => l);
            if (tlist.length > 0) {
              html += `<details open style="margin-bottom:10px;">`;
              html += `<summary style="cursor:pointer; font-weight:600; margin-bottom:12px; color:#0f172a;">Tjekliste (${tlist.length} punkter)</summary>`;
              html += `<div style="background:white; border-radius:8px; border:1px solid #e5e7eb; padding:12px;">`;
              tlist.forEach((item, idx) => {
                const itemValidated = kravValidation.tjekliste?.[idx] || false;
                html += `<div style="display:flex; align-items:center; justify-content:space-between; gap:12px; padding:8px 0; ${idx < tlist.length - 1 ? 'border-bottom:1px solid #f1f5f9;' : ''}">`;
                html += `<span style="flex:1; color:#475569; line-height:1.6;">${esc(item)}</span>`;
                html += `<label style="display:flex; align-items:center; justify-content:flex-end; cursor:pointer; width:24px; flex-shrink:0;">`;
                html += `<input type="checkbox" class="validation-item-checkbox" data-key="${esc(key)}" data-type="tjekliste" data-index="${idx}" ${itemValidated ? 'checked' : ''} style="width:20px; height:20px; cursor:pointer; accent-color:#10b981; margin:0;">`;
                html += `</label>`;
                html += `</div>`;
              });
              html += `</div>`;
              html += `</details>`;
            }
          }
          
          // Dimensionering with individual validation
          if (dim) {
            const dimValidated = kravValidation.dimensionering || false;
            html += `<details open style="margin-bottom:10px;">`;
            html += `<summary style="cursor:pointer; font-weight:600; margin-bottom:12px; color:#0f172a; display:flex; align-items:center; justify-content:space-between;">`;
            html += `<span>Korrekt dimensionering</span>`;
            html += `<label style="display:flex; align-items:center; justify-content:flex-end; cursor:pointer; width:24px; flex-shrink:0;" onclick="event.stopPropagation();">`;
            html += `<input type="checkbox" class="validation-item-checkbox" data-key="${esc(key)}" data-type="dimensionering" ${dimValidated ? 'checked' : ''} style="width:20px; height:20px; cursor:pointer; accent-color:#10b981; margin:0;">`;
            html += `</label>`;
            html += `</summary>`;
            html += `<div style="padding:16px; background:white; border-radius:8px; border:1px solid #e5e7eb;">`;
            html += `<div style="white-space:pre-wrap; color:#475569; line-height:1.6;">${escWithNewlines(dim)}</div>`;
            html += `</div>`;
            html += `</details>`;
          }

          html += `<textarea class="validation-comment" placeholder="TilfÃ¸j kommentarer..." data-key="${esc(key)}">${esc(comment)}</textarea>`;
          html += `</div>`;
        });
        
        container.innerHTML = html;
        
        // Add event listener for bilag filter
        const bilagFilterSelect = container.querySelector('#bilag-filter');
        if (bilagFilterSelect) {
          bilagFilterSelect.addEventListener('change', (e) => {
            const selected = e.target.value || null;
            renderKravValidation(selected);
          });
        }
        
        // Add event listeners for individual validation checkboxes
        container.querySelectorAll('.validation-item-checkbox').forEach(checkbox => {
          checkbox.addEventListener('change', (e) => {
            const key = e.target.dataset.key;
            const type = e.target.dataset.type;
            const index = e.target.dataset.index;
            
            if (!validationData.krav[key]) {
              validationData.krav[key] = {
                beskrivelse: false,
                tjekliste: {},
                dimensionering: false,
                comment: ''
              };
            }
            
            if (type === 'beskrivelse') {
              validationData.krav[key].beskrivelse = e.target.checked;
            } else if (type === 'tjekliste') {
              if (!validationData.krav[key].tjekliste) {
                validationData.krav[key].tjekliste = {};
              }
              validationData.krav[key].tjekliste[index] = e.target.checked;
            } else if (type === 'dimensionering') {
              validationData.krav[key].dimensionering = e.target.checked;
            }
          });
        });
        
        container.querySelectorAll('textarea').forEach(ta => {
          ta.addEventListener('change', (e) => {
            const key = e.target.dataset.key;
            if (!validationData.krav[key]) {
              validationData.krav[key] = {
                beskrivelse: false,
                tjekliste: {},
                dimensionering: false,
                comment: ''
              };
            }
            validationData.krav[key].comment = e.target.value;
          });
        });
        
      } catch(e) {
        container.innerHTML = '<div style="color:#ef4444; padding:20px;">Fejl ved indlÃ¦sning af krav: ' + e.message + '</div>';
      }
    }

    // Export validation
    document.getElementById('export-validation').addEventListener('click', () => {
      // Update metadata before export
      const today = new Date().toISOString().split('T')[0];
      validationData.version = "1.0";
      validationData.lastUpdated = today;
      if (!validationData.validatedBy) {
        validationData.validatedBy = prompt("Indtast navn pÃ¥ brandrÃ¥dgiver (valgfrit):") || "";
      }
      
      const dataStr = JSON.stringify(validationData, null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `validation.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      alert('Validering eksporteret! ðŸ“¦\n\nGem denne fil som "validation.json" i mappen "frontend/validation/" for at aktivere den pÃ¥ hjemmesiden.');
    });

    // Import validation
    document.getElementById('import-validation').addEventListener('click', () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (file) {
          try {
            const text = await file.text();
            validationData = JSON.parse(text);
            await renderValidationContent();
            alert('Validering importeret! âœ…');
          } catch(err) {
            alert('Fejl ved import: ' + err.message);
          }
        }
      };
      input.click();
    });

    // ============================================
    // PROJECT SAVE/LOAD FUNCTIONALITY
    // ============================================

    function normalizeLoadedSectionsState(rawSections){
      const raw = rawSections && typeof rawSections === 'object' ? rawSections : {};
      const count = Math.max(1, Number(raw.count ?? 1) || 1);
      const normalized = {
        count,
        titles: Array.isArray(raw.titles) ? raw.titles : [],
        inputs: (raw.inputs && typeof raw.inputs === 'object') ? raw.inputs : {},
        inputData: (raw.inputData && typeof raw.inputData === 'object') ? raw.inputData : {},
        bilagExtras: (raw.bilagExtras && typeof raw.bilagExtras === 'object') ? raw.bilagExtras : {},
        evaluations: (raw.evaluations && typeof raw.evaluations === 'object') ? raw.evaluations : {},
        progress: (raw.progress && typeof raw.progress === 'object') ? raw.progress : {},
        lastStep: (raw.lastStep && typeof raw.lastStep === 'object') ? raw.lastStep : {},
        kravChecks: (raw.kravChecks && typeof raw.kravChecks === 'object') ? raw.kravChecks : (raw.kravChecks ? raw.kravChecks : undefined),
        kravResults: (raw.kravResults && typeof raw.kravResults === 'object') ? raw.kravResults : (raw.kravResults ? raw.kravResults : undefined),
        kravCategoryOrder: (raw.kravCategoryOrder && typeof raw.kravCategoryOrder === 'object') ? raw.kravCategoryOrder : {},
        kravCategoryDocs: (raw.kravCategoryDocs && typeof raw.kravCategoryDocs === 'object') ? raw.kravCategoryDocs : {}
      };

      // Ensure progress defaults exist (used by tabs and summary).
      for (let i = 0; i < count; i++) {
        if (!normalized.progress[i]) normalized.progress[i] = { evaluated: false, requirementsViewed: false };
      }

      return normalized;
    }

    function normalizeLoadedBuildingsState(rawBuildings){
      const raw = rawBuildings && typeof rawBuildings === 'object' ? rawBuildings : {};
      const count = Math.max(1, Number(raw.count ?? 1) || 1);
      const titles = Array.isArray(raw.titles) ? raw.titles : [];
      const buildingsRaw = (raw.buildings && typeof raw.buildings === 'object') ? raw.buildings : {};
      const lastActiveSection = (raw.lastActiveSection && typeof raw.lastActiveSection === 'object') ? raw.lastActiveSection : {};

      const buildings = {};
      for (let i = 0; i < count; i++) {
        buildings[i] = normalizeLoadedSectionsState(buildingsRaw[i] || buildingsRaw[String(i)] || {});
      }

      return { count, titles, buildings, lastActiveSection };
    }

    // Save entire project (buildings, sections, inputs, validations, evaluations)
    document.getElementById('save-project-btn').addEventListener('click', () => {
      try {
        // Capture current active section's form data before saving
        try { captureInputsToSection(getActiveSectionIndex()); } catch(_) {}
        try { buildingsState.lastActiveSection[getActiveBuildingIndex()] = getActiveSectionIndex(); } catch(_) {}

        const allSectionCount = (() => {
          try {
            let total = 0;
            for (let i = 0; i < buildingsState.count; i++) {
              total += Math.max(1, Number(buildingsState.buildings?.[i]?.count ?? 1) || 1);
            }
            return total;
          } catch(_) {
            return sectionsState.count;
          }
        })();
        
        const projectData = {
          version: "1.0",
          savedAt: new Date().toISOString(),
          buildings: {
            count: buildingsState.count,
            titles: buildingsState.titles,
            buildings: buildingsState.buildings,
            lastActiveSection: buildingsState.lastActiveSection
          },
          currentActiveBuilding: getActiveBuildingIndex(),
          sections: {
            count: sectionsState.count,
            titles: sectionsState.titles,
            inputs: sectionsState.inputs,
            inputData: sectionsState.inputData,
            bilagExtras: sectionsState.bilagExtras,
            evaluations: sectionsState.evaluations,
            progress: sectionsState.progress,
            lastStep: sectionsState.lastStep,
            kravChecks: sectionsState.kravChecks,
            kravResults: sectionsState.kravResults,
            kravCategoryOrder: sectionsState.kravCategoryOrder,
            kravCategoryDocs: sectionsState.kravCategoryDocs
          },
          validation: validationData,
          currentActiveSection: getActiveSectionIndex(),
          currentStep: getCurrentStep()
        };
        
        const blob = new Blob([JSON.stringify(projectData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
        a.download = `BR18_Projekt_${timestamp}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        alert('âœ… Projekt gemt!\n\nDit projekt er gemt med:\n' +
              `â€¢ ${buildingsState.count} bygning(er)\n` +
              `â€¢ ${allSectionCount} bygningsafsnit\n` +
              `â€¢ Alle inputs og valideringer\n` +
              `â€¢ NuvÃ¦rende progress\n\n` +
              'Gem denne fil et sikkert sted og upload den igen for at fortsÃ¦tte dit arbejde.');
      } catch(err) {
        alert('âŒ Fejl ved gemning af projekt: ' + err.message);
        console.error('Save project error:', err);
      }
    });

    // Load project from file
    document.getElementById('load-project-input').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        const text = await file.text();
        const projectData = JSON.parse(text);
        
        // Validate project data structure
        if (!projectData.version || (!projectData.sections && !projectData.buildings)) {
          throw new Error('Ugyldig projekt fil - mangler nÃ¸dvendig struktur');
        }

        // Restore buildings + sections state (supports both new and legacy save files)
        if (projectData.buildings) {
          const normalizedBuildings = normalizeLoadedBuildingsState(projectData.buildings);
          buildingsState.count = normalizedBuildings.count;
          buildingsState.titles = normalizedBuildings.titles;
          buildingsState.buildings = normalizedBuildings.buildings;
          buildingsState.lastActiveSection = normalizedBuildings.lastActiveSection;
        } else {
          // Legacy: single building stored under projectData.sections
          buildingsState.count = 1;
          buildingsState.titles = [];
          buildingsState.buildings = {};
          buildingsState.lastActiveSection = {};
          buildingsState.buildings[0] = normalizeLoadedSectionsState(projectData.sections);
        }
        
        // Restore validation data
        if (projectData.validation) {
          validationData = projectData.validation;
          updateValidationStatus();
        }
        
        // Restore active building/section and step
        const targetBuilding = projectData.currentActiveBuilding || 0;
        const targetSection = projectData.currentActiveSection || 0;
        const targetStep = projectData.currentStep || 1;

        // Activate target building (this also renders tabs and restores last active section)
        setActiveBuildingIndex(Math.max(0, Math.min(targetBuilding, buildingsState.count - 1)));

        // Ensure the requested section is active
        setActiveSectionIndex(targetSection);
        
        // Navigate to saved step
        goToStep(targetStep);
        
        // If on step 2 and we have an evaluation, render it
        if (targetStep === 2 && sectionsState.evaluations[targetSection]) {
          latestEvaluation = sectionsState.evaluations[targetSection];
          displayBrandklasseResults(latestEvaluation);
        }
        
        // If on step 3, render requirements
        if (targetStep === 3) {
          const eval3 = sectionsState.evaluations[targetSection];
          if (eval3) {
            latestEvaluation = eval3;
            await updateStep3Display();
          }
        }
        
        // Update status
        updateStatus();
        
        // Compute total sections across buildings
        const allSectionCount = (() => {
          try {
            let total = 0;
            for (let i = 0; i < buildingsState.count; i++) {
              total += Math.max(1, Number(buildingsState.buildings?.[i]?.count ?? 1) || 1);
            }
            return total;
          } catch(_) {
            return sectionsState.count;
          }
        })();

        alert(`âœ… Projekt indlÃ¦st!\n\n` +
              `â€¢ ${buildingsState.count} bygning(er) gendannet\n` +
              `â€¢ ${allSectionCount} bygningsafsnit gendannet\n` +
              `â€¢ Alle inputs og valideringer gendannet\n` +
              `â€¢ FortsÃ¦tter fra trin ${targetStep}\n\n` +
              `Du kan nu fortsÃ¦tte dit arbejde hvor du slap.`);
              
        // Clear file input so the same file can be loaded again
        e.target.value = '';
        
      } catch(err) {
        alert('âŒ Fejl ved indlÃ¦sning af projekt: ' + err.message);
        console.error('Load project error:', err);
        e.target.value = '';
      }
    });

    // Helper function to get current step
    function getCurrentStep() {
      if (document.getElementById('wizard-step-1').style.display !== 'none') return 1;
      if (document.getElementById('wizard-step-2').style.display !== 'none') return 2;
      if (document.getElementById('wizard-step-3').style.display !== 'none') return 3;
      if (document.getElementById('wizard-step-4').style.display !== 'none') return 4;
      return 1;
    }

  </script>
</body>
</html>
