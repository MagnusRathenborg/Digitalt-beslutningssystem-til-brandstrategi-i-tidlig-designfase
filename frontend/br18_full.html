<!DOCTYPE html>
<!-- BR18_FULL_BUILD: 2026-01-28T00:00Z -->
<html lang="da">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>BR18 Komplet System – Full Layout</title>
  <link rel="icon" href="data:,">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="theme.css"/>
  <link rel="stylesheet" href="style.css"/>
  <style>
    :root {
      --topbar-h: 64px;
      --bottombar-h: 64px;
    }
    body, html { height: 100%; }
    body { margin: 0; font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    .topbar {
      position: fixed; top: 0; left: 0; right: 0; height: var(--topbar-h);
      display: flex; align-items: center; justify-content: space-between;
      padding: 0 24px; background: var(--c-surface); border-bottom: 1px solid var(--c-border); z-index: 9500;
    }
    .brand { display: flex; align-items: center; gap: 12px; }
    .brand .logo { width: 32px; height: 32px; border-radius: 8px; background: var(--c-primary); display: inline-block; }
    .brand .titles { line-height: 1.2; }
    .brand .titles .title { font-weight: 700; }
    .brand .titles .subtitle { font-size: 12px; color: var(--c-text-muted); }
    .top-actions { display: flex; align-items: center; gap: 12px; }
    .layout {
      position: relative; padding-top: var(--topbar-h);
      height: 100vh; display: flex; flex-direction: column;
    }
    .main {
      flex: 1; display: flex; gap: 16px; padding: 16px 24px; box-sizing: border-box;
    }
    /* Layout balance: make results panel narrower (~25%) */
    .left-panel { flex: 3 1 0; display: flex; flex-direction: column; gap: 12px; }
    .right-panel { flex: 1 1 340px; display: flex; flex-direction: column; gap: 12px; }
    .card { background: var(--c-surface); border: 1px solid var(--c-border); border-radius: 12px; padding: 16px; }
    .accordion { display: flex; flex-direction: column; gap: 8px; }
    .acc-item { border: 1px solid var(--c-border); border-radius: 8px; overflow: hidden; position: relative; }
    /* Prevent bottom-of-card selects from being clipped/covered by the next accordion item */
    .acc-item.open { overflow: visible; z-index: 5000; }
    /* When a custom select is open, raise its accordion item above any other open items */
    .acc-item.dropdown-host { overflow: visible; z-index: 9000; }
    .acc-header { background: var(--c-surface-muted); padding: 12px 16px; cursor: pointer; font-weight: 600; }
    .acc-content { padding: 12px 16px; display: none; }
    .acc-item.open .acc-content { display: block; }
    .form-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .form-field { display: flex; flex-direction: column; gap: 6px; }
    .form-field label { font-size: 13px; color: var(--c-body); }
    .form-field input[type="number"], .form-field input[type="text"], .form-field select { border: 1px solid var(--c-border-strong); border-radius: 8px; padding: 10px; font-size: 14px; accent-color: var(--c-primary); }

    /* Step 1: single-column long list layout (scoped) */
    .step1-field-list { display: flex; flex-direction: column; gap: 10px; margin-top: 12px; }
    .step1-field-list .form-field {
      display: grid;
      /* Make the answer/control column noticeably narrower */
      grid-template-columns: 1fr minmax(220px, 360px);
      align-items: center;
      gap: 12px;
      padding: 8px 12px;
      border: 1px solid var(--c-border-strong);
      border-radius: 12px;
      background: var(--c-surface);
    }
    .step1-field-list .form-field label { margin: 0; line-height: 1.15; font-size: 15px; font-weight: 700; color: var(--c-heading); }
    .step1-field-list .form-field input[type="number"],
    .step1-field-list .form-field input[type="text"],
    .step1-field-list .form-field select {
      width: 100%;
      padding: 8px 10px;
    }

    /* Highlight fields mentioned by optimization hints */
    .step1-field-list .form-field.opt-highlight {
      border-color: var(--status-bad-border);
      background: var(--status-bad-bg);
      box-shadow: var(--status-bad-ring);
    }
    .step1-field-list .form-field.opt-highlight label {
      color: var(--status-bad-text);
    }
    .step1-field-list .form-field.opt-highlight input,
    .step1-field-list .form-field.opt-highlight select {
      border-color: var(--status-bad-border);
    }

    /* Green highlight for "optimization": field has a value but should be adjusted */
    .step1-field-list .form-field.opt-highlight.opt-highlight-opt {
      border-color: var(--status-ok-border);
      background: var(--status-ok-bg);
      box-shadow: var(--status-ok-ring);
    }
    .step1-field-list .form-field.opt-highlight.opt-highlight-opt label {
      color: var(--status-ok-text);
    }
    .step1-field-list .form-field.opt-highlight.opt-highlight-opt input,
    .step1-field-list .form-field.opt-highlight.opt-highlight-opt select {
      border-color: var(--status-ok-border);
    }
    @keyframes optPulse {
      0% { box-shadow: 0 0 0 0 rgba(var(--brand-slate-rgb), 0.0); }
      40% { box-shadow: 0 0 0 6px rgba(var(--brand-slate-rgb), 0.22); }
      100% { box-shadow: 0 0 0 3px rgba(var(--brand-slate-rgb), 0.18); }
    }
    .step1-field-list .form-field.opt-highlight.opt-pulse {
      animation: optPulse 0.65s ease-out;
    }
    @media (max-width: 900px) {
      .step1-field-list .form-field { grid-template-columns: 1fr; align-items: stretch; }
    }

    .form-field select:focus { outline: none; border-color: var(--c-primary); box-shadow: var(--focus-ring); }
    .form-field select option { background: var(--c-surface) !important; background-color: var(--c-surface) !important; color: var(--c-heading); padding: 8px; }
    .form-field select option:hover, .form-field select option:focus, .form-field select option:checked { background: var(--c-surface-muted) !important; background-color: var(--c-surface-muted) !important; color: var(--c-primary) !important; }
    .form-field select option:active { background: var(--c-surface-muted) !important; background-color: var(--c-surface-muted) !important; color: var(--c-primary) !important; }
    .form-field select:focus option:checked { background: linear-gradient(0deg, var(--c-surface-muted) 0%, var(--c-surface-muted) 100%) !important; }
    .tabs { display: flex; gap: 8px; margin-bottom: 8px; }
    .tab-btn { padding: 8px 12px; border: 1px solid var(--c-border-strong); border-radius: 8px; background: var(--c-surface); cursor: pointer; }
    .tab-btn.active { background: var(--c-primary); color: var(--c-on-primary); border-color: var(--c-primary); }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    .upload-area { border: 2px dashed var(--c-border-strong); border-radius: 12px; padding: 16px; text-align: center; background: var(--c-surface-subtle); }
    .json-textarea { width: 100%; height: 50vh; font-family: 'Monaco','Menlo', monospace; font-size: 13px; padding: 12px; border: 1px solid var(--c-border-strong); border-radius: 8px; }
    .results-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; }
    .result-card { background: var(--c-surface); border: 1px solid var(--c-border-strong); border-radius: 12px; padding: 16px; text-align: center; }
    .result-value { font-size: 2.4rem; font-weight: 700; margin: 8px 0; }
    .result-description { font-size: 13px; color: var(--c-muted); }

    /* Compact results list (Step 1 right panel) */
    .results-list { display: flex; flex-direction: column; gap: 10px; margin-top: 10px; }
    .result-row { display: flex; align-items: flex-start; justify-content: space-between; gap: 12px; padding: 12px 14px; border: 1px solid var(--c-border-strong); border-radius: 12px; background: var(--c-surface); }
    .result-row .left { flex: 1; min-width: 0; }
    .result-label { font-weight: 800; font-size: 13px; color: var(--c-heading); }
    .result-help { font-size: 13px; color: var(--c-muted); margin-top: 6px; line-height: 1.5; overflow-wrap: anywhere; white-space: pre-wrap; }

    /* Ranked optimization styling (RK/BK) */
    .opt-help { margin-top: 6px; white-space: normal; }
    .opt-help-title { font-size: 13px; font-weight: 800; color: var(--c-subheading); margin-bottom: 6px; }
    .opt-help-list { display: flex; flex-direction: column; gap: 8px; }
    .opt-help-item {
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--c-border-strong);
      background: var(--c-surface);
    }
    .opt-help-item.rank-1 { background: var(--status-ok-bg); border-color: var(--status-ok-border); }
    .opt-help-item.rank-2 { background: var(--status-warn-bg); border-color: var(--status-warn-border); }
    .opt-help-item.rank-3 { background: var(--c-bg-2); border-color: var(--brand-brown); }
    .opt-help-item.rank-4 { background: var(--status-bad-bg); border-color: var(--status-bad-border); }
    .opt-help-text { color: var(--c-muted); line-height: 1.5; white-space: normal; }
    .opt-rank-name { font-weight: 900; }
    .opt-help-item.rank-1 .opt-rank-name { color: var(--status-ok-text); }
    .opt-help-item.rank-2 .opt-rank-name { color: var(--status-warn-text); }
    .opt-help-item.rank-3 .opt-rank-name { color: var(--brand-brown); }
    .opt-help-item.rank-4 .opt-rank-name { color: var(--status-bad-text); }
    .result-right { display: flex; align-items: center; gap: 10px; }
    .result-value-inline { font-weight: 900; font-size: 16px; color: var(--c-heading); text-align: right; min-width: 48px; }
    .result-status { width: 22px; height: 22px; border-radius: 999px; display: inline-flex; align-items: center; justify-content: center; font-size: 13px; font-weight: 900; border: 1px solid; user-select: none; }
    .result-status.ok { background: var(--status-ok-bg); border-color: var(--status-ok-border); color: var(--status-ok-text); }
    .result-status.missing { background: var(--status-bad-bg); border-color: var(--status-bad-border); color: var(--status-bad-text); }
    .result-status.pending { background: var(--neutral-100); border-color: var(--neutral-250); color: var(--c-muted); }

    /* Make navigation glyphs and close icons perfectly centered */
    .figure-nav-btn { display: inline-flex; align-items: center; justify-content: center; line-height: 1; }

    /* Pre-step explainer overlay */
    .prestep-overlay {
      position: fixed;
      inset: 0;
      z-index: 20000;
      display: none;
      background: var(--overlay-bg);
      padding: 24px;
      box-sizing: border-box;
      overflow: auto;
    }
    .prestep-modal {
      max-width: 920px;
      margin: 0 auto;
      background: var(--c-surface);
      border: 1px solid var(--c-border-strong);
      border-radius: 16px;
      padding: 18px;
      box-shadow: var(--overlay-shadow);
    }
    .prestep-header { display: flex; align-items: flex-start; justify-content: space-between; gap: 12px; }
    .prestep-steps { display: flex; flex-wrap: wrap; gap: 10px; margin: 14px 0 12px; }
    .prestep-step { display: inline-flex; align-items: center; gap: 8px; padding: 8px 10px; border-radius: 999px; border: 1px solid var(--c-border-strong); background: var(--neutral-75); font-size: 13px; color: var(--c-subheading); }
    .prestep-step.active { border-color: var(--c-primary); background: var(--c-bg-2); color: var(--c-primary); font-weight: 700; }
    .prestep-step.done { border-color: var(--status-ok-border); background: var(--status-ok-bg); color: var(--status-ok-text); }
    .prestep-content { border-top: 1px solid var(--c-border-strong); padding-top: 14px; }
    .prestep-card { border: 1px solid var(--c-border-strong); border-radius: 14px; padding: 14px; background: var(--c-surface); }
    .prestep-kicker { font-size: 12px; color: var(--neutral-400); }
    .prestep-value {
      font-size: 2.2rem;
      font-weight: 900;
      margin: 8px 0;
      color: var(--c-heading);
      letter-spacing: -0.02em;
    }
    .prestep-badge { display: inline-flex; align-items: center; gap: 8px; font-size: 12px; padding: 6px 10px; border-radius: 999px; border: 1px solid; }
    .prestep-badge.ok { background: var(--status-ok-bg); border-color: var(--status-ok-border); color: var(--status-ok-text); }
    .prestep-badge.missing { background: var(--status-warn-bg); border-color: var(--status-warn-border); color: var(--status-warn-text); }
    .prestep-text { margin-top: 10px; color: var(--c-subheading); line-height: 1.55; }

    /* Bilag input overlay (shown before Step 3 / Krav) */
    .bilag-overlay {
      position: fixed;
      inset: 0;
      z-index: 21000;
      display: none;
      background: var(--overlay-bg);
      padding: 24px;
      box-sizing: border-box;
      overflow: auto;
    }
    .bilag-modal {
      max-width: 920px;
      margin: 0 auto;
      background: var(--c-surface);
      border: 1px solid var(--c-border-strong);
      border-radius: 16px;
      padding: 18px;
      box-shadow: var(--overlay-shadow);
    }
    .bilag-header { display: flex; align-items: flex-start; justify-content: space-between; gap: 12px; }
    .bilag-kicker { font-size: 12px; color: var(--neutral-400); }
    .bilag-body { border-top: 1px solid var(--c-border-strong); padding-top: 14px; margin-top: 12px; }
    .bilag-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .bilag-note { background: var(--neutral-50); border: 1px solid var(--c-border-strong); border-radius: 12px; padding: 12px; color: var(--c-subheading); }
    .bilag-note strong { color: var(--c-heading); }
    .bilag-field { display: flex; flex-direction: column; gap: 6px; }
    .bilag-field label { font-size: 13px; color: var(--c-heading); font-weight: 700; display:flex; align-items:center; gap:6px; min-height: 18px; }
    .bilag-field .help { font-size: 12px; color: var(--neutral-400); line-height: 1.35; min-height: 16px; }
    .bilag-field input[type="number"],
    .bilag-field input[type="text"],
    .bilag-field select {
      border: 1px solid var(--c-border-strong);
      border-radius: 10px;
      padding: 10px;
      font-size: 14px;
      background: var(--c-surface);
      accent-color: var(--c-primary);
    }
    .bilag-field select:focus {
      outline: none;
      border-color: var(--c-primary);
      box-shadow: var(--focus-ring);
    }
    .bilag-field select option {
      background: var(--c-surface) !important;
      background-color: var(--c-surface) !important;
      color: var(--c-heading);
      padding: 8px;
    }
    .bilag-field select option:hover,
    .bilag-field select option:focus,
    .bilag-field select option:checked {
      background: var(--c-surface-muted) !important;
      background-color: var(--c-surface-muted) !important;
      color: var(--c-primary) !important;
    }
    .bilag-field select option:active {
      background: var(--c-surface-muted) !important;
      background-color: var(--c-surface-muted) !important;
      color: var(--c-primary) !important;
    }
    .bilag-field select:focus option:checked {
      background: linear-gradient(0deg, var(--c-surface-muted) 0%, var(--c-surface-muted) 100%) !important;
    }
    .bilag-field input[readonly] {
      background: var(--neutral-50);
      color: var(--c-subheading);
    }
    .bilag-actions { display: flex; justify-content: space-between; align-items: center; gap: 10px; margin-top: 14px; }
    .bilag-actions .right { display:flex; gap:8px; }

    /* (Note popup removed) */
    .bottombar { height: var(--bottombar-h); display: flex; align-items: center; justify-content: space-between; padding: 0 24px; border-top: 1px solid var(--c-border-strong); background: var(--c-surface); }
    .muted { color: var(--c-muted); font-size: 13px; }
    .btn-primary { padding: 10px 16px; border-radius: 8px; border: 1px solid var(--c-primary); background: var(--c-primary); color: var(--c-on-primary); cursor: pointer; }
    .btn-secondary { padding: 10px 16px; border-radius: 8px; border: 1px solid var(--neutral-300); background: var(--neutral-100); color: var(--neutral-900); cursor: pointer; }
    .btn-secondary:hover { background: var(--neutral-150); border-color: var(--neutral-250); }
    .btn-secondary:active { background: var(--neutral-200); }

    /* Prestep bilag slide: make download row more harmonious */
    .download-row { margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--c-border-strong); display:flex; align-items:center; justify-content:space-between; gap: 12px; flex-wrap: wrap; }
    .download-row .download-label { margin: 0; color: var(--neutral-400); font-size: 13px; display:flex; align-items:center; min-height: 34px; }
    .download-row .btn-secondary.download-link { padding: 8px 12px; font-size: 13px; line-height: 1; display:inline-flex; align-items:center; justify-content:center; gap: 6px; }
    .download-row .download-icon { font-size: 14px; line-height: 1; transform: translateY(0.5px); }

    /* Step 2 (Brandklasse) compact layout to make room for figures */
    .step2-compact { padding: 14px; background: var(--c-surface); }
    .step2-status { text-align: center; margin: 2px 0 10px; }
    .step2-status.step2-status--instruction {
      font-size: 26px; /* ~2x the default muted size */
      font-weight: 700;
      color: var(--c-primary);
      margin: 10px 0 14px;
    }
    .step2-important { max-width: none; margin: 0 0 10px; }
    .step2-important .body { max-height: 120px; overflow: auto; line-height: 1.45; }
    .step2-legend { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; align-items: stretch; max-width: 1200px; margin: 0 auto; }
    .step2-legend--main { flex-wrap: nowrap; justify-content: center; }
    .step2-legend--main .legend-item { min-width: 0; flex: 1 1 0; max-width: 340px; }
    @media (max-width: 900px) {
      .step2-legend--main { flex-wrap: wrap; }
      .step2-legend--main .legend-item { min-width: 220px; flex: 1 1 220px; }
    }
    .legend-item { border: 1px solid var(--c-border-strong); border-radius: 10px; padding: 8px 10px; background: var(--c-surface); min-width: 220px; }
    .legend-label { font-size: 11px; color: var(--neutral-400); margin-bottom: 2px; }
    .legend-value { font-weight: 800; color: var(--c-heading); font-size: 14px; }
    .legend-value.brand { color: var(--c-primary); font-size: 18px; }
    .legend-desc { display: none; }
    .step2-figures { margin-top: 12px; }
    .step2-figures .muted { font-size: 12px; }

    /* Step 2 figures carousel */
    /* Header text should align with the figure width and be easy to scan */
    .step2-figures .fig-header {
      max-width: 900px;
      margin: 0 auto 10px;
      padding: 10px 12px;
      border: 1px solid #e6e8ef;
      border-radius: 12px;
      background: #ffffff;
    }
    .step2-figures .fig-title {
      font-weight: 600;
      font-size: 13px;
      color: #0f172a;
      line-height: 1.35;
      text-align: justify;
      text-justify: inter-word;
      overflow-wrap: anywhere;
      hyphens: auto;
    }
    .step2-figures .fig-subtitle {
      font-size: 13px;
      color: #475569;
      margin-top: 6px;
      text-align: center;
    }
    .figure-carousel { display: flex; align-items: center; justify-content: center; gap: 12px; }
    .figure-nav-btn {
      width: 44px; height: 44px;
      border-radius: 12px;
      border: 1px solid #dbe3ef;
      background: #ffffff;
      color: #0f172a;
      font-size: 22px;
      font-weight: 900;
      cursor: pointer;
      user-select: none;
    }
    .figure-nav-btn:hover { background: var(--c-surface-subtle); }
    .figure-nav-btn:active { background: var(--status-bad-bg); }
    .figure-nav-btn:disabled { opacity: 0.35; cursor: default; }
    .figure-stage { flex: 1; max-width: 900px; }
    .figure-frame {
      width: 100%;
      height: min(52vh, 520px);
      max-height: 520px;
      border: 1px solid var(--c-border-strong);
      border-radius: 14px;
      background: var(--c-surface-subtle);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    .figure-frame img { max-width: 100%; max-height: 100%; object-fit: contain; display: block; }
    .figure-meta { text-align: center; margin-top: 10px; }
    .figure-meta .ref { font-weight: 900; font-size: 14px; color: var(--c-heading); }
    .figure-meta .count { font-size: 12px; color: var(--neutral-400); margin-left: 8px; }
    .figure-caption { margin-top: 6px; font-size: 13px; color: var(--c-muted); white-space: pre-wrap; text-align: center; hyphens: auto; }
    .info-icon {
      display:inline-block; width:14px; height:14px; line-height:14px; text-align:center;
      border-radius:50%; border:1px solid var(--c-primary); color:var(--c-on-primary); font-size:10px; font-weight:600;
      margin-left:6px; cursor: pointer; background:var(--c-primary); vertical-align:middle; position:relative; top:1px; opacity:0.95;
    }
    /* Paragraf icons are slightly larger and use the theme blue */
    .info-icon.para-icon {
      width: 21px;
      height: 21px;
      line-height: 21px;
      font-size: 15px;
      border-color: var(--c-primary);
      background: var(--c-primary);
      margin-left: 10px;
      top: 0;
    }
    /* Disable pseudo-element tooltips; we use a JS-positioned tooltip so it never overflows the viewport. */
    .info-icon::after, .info-icon::before { content: none !important; }

    /* JS tooltip */
    #info-tooltip {
      position: fixed;
      z-index: 30000;
      display: none;
      background: rgba(var(--brand-brown-rgb), 0.86);
      color: var(--c-on-primary);
      border: 1px solid rgba(var(--brand-sand-rgb), 0.60);
      padding: 8px 14px;
      border-radius: 10px;
      box-shadow: 0 10px 28px rgba(var(--brand-brown-rgb), 0.18);
      font-size: 12px;
      line-height: 1.35;
      max-width: 560px;
      box-sizing: border-box;
      pointer-events: none;
      white-space: pre-wrap;
    }
    #info-tooltip.visible { display: block; }
    #info-tooltip::after {
      content: '';
      position: absolute;
      left: var(--arrow-left, 16px);
      transform: translateX(-50%);
      width: 0; height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
    }
    #info-tooltip.above::after {
      bottom: -6px;
      border-top: 6px solid rgba(var(--brand-brown-rgb), 0.86);
    }
    #info-tooltip.below::after {
      top: -6px;
      border-bottom: 6px solid rgba(var(--brand-brown-rgb), 0.86);
    }
    
    /* Step-based wizard styling */
    .wizard-steps { display: flex; justify-content: center; gap: 24px; margin-bottom: 24px; }
    .wizard-step { display: flex; align-items: center; gap: 8px; }
    .step-number { width: 32px; height: 32px; border-radius: 50%; background: var(--c-border-strong); display: flex; align-items: center; justify-content: center; font-weight: 600; color: var(--c-muted); }
    .wizard-step.active .step-number { background: var(--c-primary); color: var(--c-on-primary); }
    .wizard-step.completed .step-number { background: var(--c-text-muted); color: var(--c-on-primary); }
    .step-label { font-size: 14px; color: var(--c-muted); }
    .wizard-step.active .step-label { color: var(--c-body); font-weight: 600; }

    /* Make the top step indicators clickable */
    .wizard-step { cursor: pointer; user-select: none; }
    .wizard-step[role="button"]:focus-visible { outline: 3px solid rgba(var(--brand-slate-rgb), 0.55); outline-offset: 4px; border-radius: 12px; }
    
    .wizard-content { display: none; }
    .wizard-content.active { display: block; }
    
    .continue-btn-wrapper { display: flex; justify-content: flex-end; margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--c-border-strong); }
    
    /* =========================
       STEP 3 (Krav) presentation
       ========================= */
    .requirements-section { display: flex; flex-direction: column; gap: 12px; margin-top: 24px; }
     .krav-title-block { border: 1px solid var(--c-border-strong); border-radius: 14px; background: var(--c-surface); overflow: hidden; }
     .krav-title-header { padding: 14px 16px; background: var(--c-surface-subtle); border-bottom: 1px solid var(--c-border-strong); display:flex; align-items:flex-start; justify-content:space-between; gap: 12px; }
    .krav-title-left { min-width: 0; }
     .krav-title { font-size: 18px; font-weight: 900; color:var(--c-heading); letter-spacing: -0.01em; display:inline-flex; align-items:center; gap: 8px; }
    .krav-subtitle { font-size: 15px; font-weight: 800; color:var(--c-text); margin-top: 6px; display:flex; align-items:center; gap:8px; }
     .krav-subsubtitle { font-size: 15px; font-weight: 800; color:var(--c-text); margin-top: 4px; display:flex; align-items:center; gap:8px; }
     .krav-mini { font-size: 12px; font-weight: 800; color:var(--c-text); margin-top: 4px; text-transform: none; display:flex; align-items:center; gap:8px; }
    .krav-heading-actions { margin-left: auto; display: inline-flex; align-items: center; gap: 8px; }
    .krav-block-body { padding: 12px 16px 14px; }
    .krav-desc { margin: 4px 0 6px; color: var(--c-heading); }
    .krav-desc .label { font-size: 12px; font-weight: 800; color: var(--c-muted); margin-bottom: 4px; }
    .krav-desc .text { font-style: italic; color: var(--c-heading); white-space: pre-wrap; line-height: 1.45; }

    .krav-group { padding: 10px 0; border-top: 1px dashed var(--c-border); }
    .krav-group:first-child { border-top: none; }
    .krav-group-header { display:flex; align-items:center; justify-content:space-between; gap: 10px; }
    .krav-group-meta { display:flex; align-items:center; gap: 10px; flex-wrap: wrap; }
    .krav-id-badge {
      font-size: 11px;
      font-weight: 700;
      color: rgba(var(--brand-brown-rgb), 0.75);
      background: var(--c-surface-subtle);
      border: 1px solid var(--c-border);
      padding: 3px 8px;
      border-radius: 999px;
      letter-spacing: 0.01em;
    }
    .krav-actions { display:flex; align-items:center; gap: 8px; }
    .krav-check-all-btn {
      font-size: 11px;
      font-weight: 700;
      padding: 5px 10px;
      border-radius: 6px;
      border: 1px solid var(--action-ok-bg);
      background: var(--action-ok-bg);
      color: var(--neutral-0);
      cursor: pointer;
      user-select: none;
      transition: all 0.2s ease;
    }
    .krav-check-all-btn:hover { background: var(--action-ok-bg-hover); border-color: var(--action-ok-bg-hover); }
    .krav-check-all-btn:active { background: var(--action-ok-bg-active); border-color: var(--action-ok-bg-active); }
    .krav-pill {
      font-size: 12px;
      font-weight: 800;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--action-danger-bg);
      background: var(--action-danger-bg);
      color: var(--neutral-0);
      cursor: pointer;
      user-select: none;
    }
    .krav-pill:hover { background: var(--action-danger-bg-hover); border-color: var(--action-danger-bg-hover); }
    .krav-pill:active { background: var(--action-danger-bg-active); border-color: var(--action-danger-bg-active); }
    .krav-pill:focus-visible { outline: 2px solid rgba(var(--neutral-900-rgb), 0.20); outline-offset: 2px; box-shadow: var(--focus-ring-strong); }

    .krav-checklist { list-style: none; padding: 0; margin: 0; display:flex; flex-direction: column; gap: 8px; }
    .krav-check { position: relative; display:flex; flex-direction: column; gap: 8px; padding: 10px 12px; border: 1px solid var(--c-border); border-radius: 12px; background: var(--c-surface); }
    .krav-check-top { display:flex; align-items:flex-start; justify-content:space-between; gap: 12px; padding-right: 18px; }
    .krav-check-left { display:flex; align-items:flex-start; gap: 10px; flex: 1; min-width: 0; }
    .krav-check-right { display:inline-flex; align-items:center; gap: 8px; flex-shrink: 0; }
    .krav-check-text { font-size: 14px; color: var(--c-text); line-height: 1.35; overflow-wrap: anywhere; transition: all 0.2s ease; }
    .krav-check.excluded { border-color: var(--neutral-250); background: var(--c-surface-subtle); opacity: 0.55; }
    .krav-check.excluded .krav-check-text { color: var(--neutral-400); text-decoration: line-through; text-decoration-color: var(--neutral-400); text-decoration-thickness: 2px; }

    .krav-check.ok .krav-check-text { color: var(--action-ok-bg-active); text-decoration: line-through; text-decoration-color: var(--action-ok-bg); text-decoration-thickness: 2px; }

    .krav-ok-cb {
      width: 18px;
      height: 18px;
      accent-color: var(--action-ok-bg);
      cursor: pointer;
      margin-top: 1px;
      flex-shrink: 0;
    }
    .krav-ok-cb:disabled { cursor: not-allowed; }

    .krav-ok {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid var(--c-border);
      background: var(--c-surface);
      color: var(--c-text);
      font-size: 12px;
      font-weight: 900;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
    }
    .krav-ok input[type="checkbox"] {
      width: 16px;
      height: 16px;
      accent-color: var(--action-ok-bg);
      cursor: pointer;
      margin-top: 0;
    }
    .krav-ok input[type="checkbox"]:disabled { cursor: not-allowed; }

    .krav-exclude-btn {
      position: absolute;
      top: 6px;
      right: 6px;
      display: inline-block;
      padding: 0;
      border: none;
      background: transparent;
      color: var(--neutral-250);
      font-weight: 900;
      font-size: 16px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      opacity: 0.8;
    }
    .krav-exclude-btn:hover { color: var(--c-muted); opacity: 1; }
    .krav-exclude-btn:active { color: var(--c-subheading); }
    .krav-exclude-btn:focus-visible { outline: none; box-shadow: var(--focus-ring); border-radius: 6px; }

    .krav-item-id {
      display: block;
      margin-top: 4px;
      font-size: 11px;
      font-weight: 700;
      color: var(--c-muted);
    }

    .krav-doc-btn {
      font-size: 12px;
      font-weight: 900;
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid var(--c-border);
      background: var(--c-surface);
      color: var(--c-text);
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
    }
    .krav-doc-btn:hover { background: var(--c-surface-subtle); }
    .krav-doc-btn.has-text { border-color: rgba(var(--brand-slate-rgb), 0.35); background: rgba(var(--brand-slate-rgb), 0.08); }
    .krav-doc-btn:disabled { opacity: 0.55; cursor: not-allowed; }

    .krav-irrel {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid var(--danger-200);
      background: var(--danger-100);
      color: var(--danger-text);
      font-size: 12px;
      font-weight: 900;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
    }
    .krav-irrel input[type="checkbox"] {
      width: 16px;
      height: 16px;
      accent-color: var(--danger-500);
      cursor: pointer;
      margin-top: 0;
    }

    .krav-doc-panel { display: none; padding-left: 0; }
    .krav-doc-panel.open { display: block; }
    .krav-doc-panel label { display: block; font-size: 11px; font-weight: 800; color: var(--c-muted); margin-bottom: 4px; }
    .krav-doc-bilag { margin-top: 8px; font-size: 12px; color: var(--c-subheading); }
    .krav-doc-panel textarea {
      width: 100%;
      border: 1px solid var(--c-border);
      border-radius: 10px;
      padding: 10px 10px;
      font-size: 13px;
      font-family: inherit;
      resize: vertical;
      min-height: 56px;
    }

    /* Step 3: Documentation uploads per requirement category */
    .cat-docs { margin: 10px 0 12px; padding: 12px; border: 1px solid var(--c-border); border-radius: 12px; background: var(--c-surface-subtle); }
    .cat-docs-header { display:flex; align-items:flex-start; justify-content:space-between; gap: 12px; }
    .cat-docs-title { font-size: 13px; font-weight: 900; color: var(--c-text); letter-spacing: 0.02em; }
    .cat-docs-sub { margin-top: 4px; font-size: 12px; color: var(--c-muted); line-height: 1.4; max-width: 720px; }
    .cat-docs-actions { display:flex; align-items:center; gap: 8px; flex-shrink: 0; }
    .cat-docs-list { margin-top: 10px; display:flex; flex-direction: column; background: var(--c-surface); border: 1px solid var(--c-border); border-radius: 12px; overflow: hidden; }
    .cat-doc-empty { font-size: 12px; color: var(--c-muted); }
    .cat-doc-item { background: var(--c-surface); padding: 8px 10px; border-top: 1px solid rgba(var(--neutral-900-rgb), 0.06); }
    .cat-doc-item:first-child { border-top: none; }
    .cat-doc-item-top { display:flex; align-items:center; justify-content:space-between; gap: 10px; }
    .cat-doc-name-btn {
      appearance: none;
      border: none;
      background: transparent;
      padding: 0;
      margin: 0;
      width: 100%;
      text-align: left;
      cursor: pointer;
      font-size: 13px;
      font-weight: 800;
      color: var(--c-text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      outline: none;
      box-shadow: none;
      border-radius: 0;
      -webkit-tap-highlight-color: transparent;
    }
    .cat-doc-name-btn:hover { text-decoration: underline; background: transparent; box-shadow: none; }
    .cat-doc-name-btn:focus { outline: none; box-shadow: none; background: transparent; }
    .cat-doc-name-btn:focus-visible { outline: none; box-shadow: none; background: transparent; }
    .cat-doc-remove {
      border: none;
      background: transparent;
      padding: 0;
      width: 28px;
      height: 28px;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: var(--neutral-400);
      cursor: pointer;
      flex-shrink: 0;
      user-select: none;
    }
    .cat-doc-remove:hover { color: var(--c-muted); }
    .cat-doc-remove:active { color: var(--c-subheading); }
    .cat-doc-remove:focus-visible { outline: none; box-shadow: var(--focus-ring); border-radius: 6px; }
    .cat-doc-item.is-collapsed .cat-doc-fields { display:none; }
    .cat-doc-item.is-collapsed details { display:none; }
    .cat-doc-fields { margin-top: 8px; display:grid; grid-template-columns: 1fr; gap: 8px; }
    .cat-doc-field-label { font-size: 11px; font-weight: 800; color: var(--c-muted); margin-bottom: 4px; }
    .cat-doc-input, .cat-doc-textarea { width: 100%; border: 1px solid var(--c-border); border-radius: 10px; padding: 10px 10px; font-size: 13px; font-family: inherit; }
    .cat-doc-textarea { resize: vertical; min-height: 52px; }
    .krav-check-right { display:flex; align-items:center; gap: 8px; }
    .krav-dim-row { display:flex; justify-content:flex-end; margin-top: 6px; }
    .q-icon {
      width: 22px; height: 22px; border-radius: 999px;
      border: 1px solid var(--c-border-strong); background: var(--c-surface); color: var(--c-text);
      display:inline-flex; align-items:center; justify-content:center;
      font-weight: 900; font-size: 13px; cursor: pointer; user-select: none;
    }
    .q-icon:hover { background: var(--c-surface-subtle); }
    /* Question icon should visually match the paragraph (§) icon when shown on headings */
    .q-icon.q-icon-big {
      width: 21px;
      height: 21px;
      line-height: 21px;
      font-size: 15px;
      border-color: var(--action-danger-bg);
      background: var(--action-danger-bg);
      color: var(--neutral-0);
      margin-left: 10px;
    }
    .q-icon.q-icon-big:hover { background: var(--action-danger-bg-hover); border-color: var(--action-danger-bg-hover); }

    /* Use the existing tooltip system for paragraph icons */
    .para-icon { background: var(--c-text); border-color: var(--c-text); }

    /* Right panel viewer for figures/tables (Step 3) */
    .krav-viewer-card { min-height: 120px; }
    .krav-viewer-header { display:flex; align-items:center; justify-content:space-between; gap: 10px; margin-bottom: 10px; }
    .krav-viewer-title { font-weight: 900; font-size: 13px; color: var(--c-text); letter-spacing: 0.02em; }
    .krav-viewer-body { display:none; }
    .krav-viewer-body.open { display:block; }
    .krav-viewer-slots { position: relative; min-height: 140px; }
    .krav-slot { position: absolute; left: 0; right: 0; }
    .krav-slot-actions {
      position: absolute;
      top: 8px;
      right: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 2;
    }
    .krav-slot-close {
      width: 30px;
      height: 30px;
      border-radius: 999px;
      border: 1px solid var(--c-border-strong);
      background: rgba(var(--neutral-0-rgb), 0.92);
      color: var(--c-text);
      font-weight: 900;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }
    .krav-slot-close:hover { background: var(--neutral-0); }
    .krav-slot-expand {
      width: 30px;
      height: 30px;
      border-radius: 999px;
      border: 1px solid var(--c-border-strong);
      background: rgba(var(--neutral-0-rgb), 0.92);
      color: var(--c-text);
      font-weight: 900;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }
    .krav-slot-expand:hover { background: var(--neutral-0); }
    .krav-viewer-placeholder { padding: 22px 12px; color: var(--c-muted); font-size: 13px; text-align:center; }
    .krav-carousel { display:flex; align-items:center; justify-content:center; gap: 12px; }
    .krav-stage { flex: 1; }
    .krav-frame {
      width: 100%;
      border: 1px solid var(--c-border);
      border-radius: 14px;
      background: var(--c-surface-subtle);
      display:flex;
      align-items:center;
      justify-content:center;
      overflow: visible;
    }
    .krav-frame img { width: 100%; height: auto; object-fit: contain; display:block; }
    .krav-viewer-meta { text-align:center; margin-top: 10px; }
    .krav-viewer-meta .ref { font-weight: 900; font-size: 14px; color: var(--c-text); }
    .krav-viewer-meta .count { font-size: 12px; color: var(--c-muted); margin-left: 8px; }
    .krav-viewer-caption { margin-top: 6px; font-size: 13px; color: var(--c-subheading); white-space: pre-wrap; }
    .krav-viewer-missing { margin-top: 8px; font-size: 12px; color: var(--status-warn-text); white-space: pre-wrap; }

    /* Fullscreen / expanded image viewer */
    .lightbox-overlay {
      position: fixed;
      inset: 0;
      z-index: 40000;
      display: none;
      padding: 20px;
      box-sizing: border-box;
      background: rgba(var(--neutral-900-rgb), 0.78);
      align-items: center;
      justify-content: center;
    }
    .lightbox-overlay.open { display: flex; }
    .lightbox-modal {
      width: min(1280px, calc(100vw - 40px));
      height: min(92vh, 980px);
      background: var(--c-surface);
      border: 1px solid var(--c-border);
      border-radius: 16px;
      overflow: hidden;
      box-shadow: var(--shadow-neutral-xl);
      display: flex;
      flex-direction: column;
    }
    .lightbox-toolbar {
      padding: 10px;
      border-bottom: 1px solid var(--c-border);
      background: var(--c-surface-subtle);
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }
    .lightbox-btn {
      width: 36px;
      height: 36px;
      border-radius: 999px;
      border: 1px solid var(--c-border-strong);
      background: var(--c-surface);
      color: var(--c-heading);
      font-weight: 900;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      user-select: none;
    }
    .lightbox-btn:hover { background: var(--c-surface-subtle); }
    .lightbox-stage {
      position: relative;
      flex: 1;
      background: var(--c-surface-subtle);
      overflow: auto;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding: 14px;
      box-sizing: border-box;
    }
    .lightbox-stage img { width: 100%; height: auto; display: block; object-fit: contain; }
    .lightbox-nav {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 46px;
      height: 46px;
      border-radius: 14px;
      border: 1px solid var(--c-border-strong);
      background: rgba(var(--neutral-0-rgb), 0.92);
      color: var(--c-heading);
      font-size: 24px;
      font-weight: 900;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      user-select: none;
    }
    .lightbox-nav:hover { background: var(--neutral-0); }
    .lightbox-nav:disabled { opacity: 0.35; cursor: default; }
    .lightbox-nav.prev { left: 12px; }
    .lightbox-nav.next { right: 12px; }
    .lightbox-meta {
      padding: 10px 12px;
      border-top: 1px solid var(--c-border);
      background: var(--c-surface);
      text-align: center;
    }
    .lightbox-count { font-size: 12px; color: var(--c-muted); font-weight: 700; }
    .lightbox-caption { margin-top: 6px; font-size: 13px; color: var(--c-subheading); white-space: pre-wrap; }

    /* Lockable, draggable detail panel (Krav_Korrekt_Dimensionering) */
    #krav-dim-panel {
      position: fixed;
      z-index: 31000;
      display: none;
      width: min(720px, calc(100vw - 24px));
      max-height: min(70vh, 560px);
      overflow: hidden;
      border: 1px solid var(--c-border);
      border-radius: 14px;
      background: var(--c-surface);
      box-shadow: var(--shadow-neutral-lg);
    }
    .dim-header {
      background: var(--c-heading);
      color: var(--neutral-0);
      padding: 10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      cursor: move;
      user-select: none;
    }
    .dim-title { font-weight: 900; font-size: 13px; }
    .dim-actions { display:flex; gap: 8px; align-items:center; }
    .dim-btn {
      font-size: 12px;
      font-weight: 800;
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid rgba(var(--neutral-0-rgb), 0.22);
      background: rgba(var(--neutral-0-rgb), 0.12);
      color: var(--neutral-0);
      cursor: pointer;
    }
    .dim-btn:hover { background: rgba(var(--neutral-0-rgb), 0.18); }
    .dim-body { padding: 12px; overflow: auto; max-height: calc(min(70vh, 560px) - 44px); }
    .dim-body p { margin: 0 0 10px; white-space: pre-wrap; line-height: 1.45; color: var(--c-heading); }
    .dim-body p:last-child { margin-bottom: 0; }
    /* Small popup for tab rename */
    .mini-popup { position: fixed; z-index: 1000; background: var(--c-surface); border:1px solid var(--c-border); box-shadow: var(--shadow-neutral-md); border-radius:8px; padding:8px; display:flex; align-items:center; gap:8px; }
    .mini-popup input { padding:6px 8px; border:1px solid var(--c-border); border-radius:6px; min-width:200px; }
    .mini-popup .actions { display:flex; gap:6px; }
    
    /* Validation Modal */
    .validation-modal { 
      position: fixed; 
      top: 0; left: 0; right: 0; bottom: 0; 
      background: rgba(var(--neutral-900-rgb), 0.5); 
      /* Must stay above other overlays (lightbox, bilag overlay, dim panel, etc.) */
      z-index: 60000; 
      display: none; 
      align-items: center; 
      justify-content: center;
      padding: 20px;
    }
    .validation-modal.show { display: flex; }
    .validation-content { 
      background: var(--c-surface); 
      border-radius: 16px; 
      width: 90%; 
      max-width: 1400px; 
      max-height: 90vh; 
      display: flex; 
      flex-direction: column;
      box-shadow: 0 20px 60px rgba(var(--neutral-900-rgb), 0.30);
    }
    .validation-header { 
      padding: 24px; 
      border-bottom: 1px solid var(--c-border); 
      display: flex; 
      align-items: center; 
      justify-content: space-between;
    }
    .validation-header h2 { margin: 0; color: var(--danger-500); }
    .validation-body { 
      flex: 1; 
      overflow-y: auto; 
      padding: 24px;
    }
    .validation-footer {
      padding: 16px 24px;
      border-top: 1px solid var(--c-border);
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }
    .validation-tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 24px;
      border-bottom: 2px solid var(--c-border);
    }
    .validation-tab {
      padding: 12px 20px;
      background: none;
      border: none;
      border-bottom: 3px solid transparent;
      cursor: pointer;
      font-weight: 600;
      color: var(--c-muted);
      transition: all 0.2s;
    }
    .validation-tab.active {
      color: var(--danger-500);
      border-bottom-color: var(--danger-500);
    }
    .validation-tab:hover {
      color: var(--danger-600);
    }
    .validation-section {
      display: none;
    }
    .validation-section.active {
      display: block;
    }
    .validation-item {
      border: 1px solid var(--c-border);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 12px;
      background: var(--c-surface-subtle);
    }
    .validation-item-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
    }
    .validation-item-title {
      font-weight: 600;
      color: var(--c-heading);
      flex: 1;
    }
    .validation-checkbox {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .validation-checkbox input[type="checkbox"] {
      width: 20px;
      height: 20px;
      accent-color: var(--action-ok-bg);
      cursor: pointer;
    }
    .validation-checkbox label {
      font-weight: 600;
      color: #10b981;
      cursor: pointer;
    }
    .validation-comment {
      width: 100%;
      min-height: 60px;
      padding: 8px 12px;
      border: 1px solid var(--c-border-strong);
      border-radius: 8px;
      font-family: inherit;
      font-size: 14px;
      margin-top: 8px;
      color: var(--c-text);
      background: var(--c-surface);
    }
    .validation-comment:focus {
      outline: none;
      border-color: var(--c-primary);
      box-shadow: var(--focus-ring);
    }
    
    /* Custom Dropdown Styles */
    .custom-select-wrapper {
      position: relative;
      width: 100%;
    }
    .custom-select-wrapper select {
      display: none;
    }
    .custom-select {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px;
      border: 1px solid var(--c-border-strong);
      border-radius: 8px;
      background: var(--c-surface);
      cursor: pointer;
      user-select: none;
      font-size: 14px;
      min-height: 42px;
      color: var(--c-text);
    }
    .custom-select:hover {
      border-color: var(--c-border);
    }
    .custom-select.open {
      border-color: var(--status-warn-border);
      box-shadow: var(--focus-ring);
      z-index: 6000;
    }
    .custom-select-trigger {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      gap: 8px;
    }
    .custom-select-value {
      flex: 1;
      color: var(--c-text);
    }
    .custom-select-value.placeholder {
      color: var(--c-text-muted);
    }
    .custom-select-arrow {
      width: 0;
      height: 0;
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
      border-top: 5px solid var(--c-muted);
      transition: transform 0.2s ease;
    }
    .custom-select.open .custom-select-arrow {
      transform: rotate(180deg);
    }
    .custom-select-dropdown {
      position: absolute;
      top: calc(100% + 4px);
      left: 0;
      right: 0;
      background: var(--c-surface);
      border: 1px solid var(--c-border-strong);
      border-radius: 8px;
      box-shadow: var(--shadow-neutral-md);
      max-height: 300px;
      overflow-y: auto;
      z-index: 6001;
      display: none;
    }
    .custom-select.open .custom-select-dropdown {
      display: block;
    }
    .custom-option {
      padding: 10px 12px;
      cursor: pointer;
      transition: background-color 0.15s ease;
      font-size: 14px;
      color: var(--c-text);
    }
    .custom-option:hover {
      background-color: var(--c-surface-muted);
      color: var(--c-text);
    }
    .custom-option.selected {
      background-color: var(--status-warn-bg);
      color: var(--status-warn-text);
      font-weight: 600;
    }
    .custom-option.disabled {
      color: var(--c-text-muted);
      cursor: default;
      font-style: italic;
    }
    .custom-option.disabled:hover {
      background-color: transparent;
      color: var(--c-text-muted);
    }
    .custom-option-group-label {
      padding: 8px 12px;
      font-weight: 700;
      font-size: 13px;
      color: var(--c-muted);
      background: var(--c-surface-subtle);
      cursor: default;
    }
    .custom-option-group-item {
      padding-left: 24px;
    }
    
    /* Confirmation modal */
    .confirm-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      padding: 24px;
    }
    .confirm-modal {
      background: var(--c-surface);
      border-radius: 12px;
      padding: 24px;
      max-width: 400px;
      width: 100%;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }
    .confirm-header {
      font-size: 18px;
      font-weight: 700;
      margin-bottom: 12px;
      color: var(--c-text);
    }
    .confirm-message {
      color: var(--c-text-muted);
      margin-bottom: 24px;
      line-height: 1.5;
    }
    .confirm-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }
    .confirm-actions button {
      padding: 10px 20px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      border: 1px solid;
    }
    .confirm-btn-cancel {
      background: var(--c-surface);
      border-color: var(--c-border);
      color: var(--c-text);
    }
    .confirm-btn-cancel:hover {
      background: var(--c-surface-muted);
    }
    .confirm-btn-confirm {
      background: var(--c-primary);
      border-color: var(--c-primary);
      color: var(--c-on-primary);
    }
    .confirm-btn-confirm:hover {
      background: var(--c-primary-hover);
    }
    
    .decision-table {
      background: white;
      border: 1px solid #e6e8ef;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 8px;
    }
    .decision-rule {
      background: #f1f5f9;
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 8px;
    }
    .decision-rule:last-child {
      margin-bottom: 0;
    }
    .rule-conditions {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 8px;
      margin-bottom: 8px;
    }
    .rule-condition {
      font-size: 13px;
      padding: 6px 10px;
      background: white;
      border-radius: 6px;
      border: 1px solid #e2e8f0;
    }
    .rule-result {
      background: var(--c-bg-2);
      padding: 8px 12px;
      border-radius: 6px;
      font-weight: 600;
      color: var(--c-primary);
      border: 1px solid var(--c-border);
    }

    /* Step 4 documentation: split view (left inputs, right live draft) */
    .doc-overlay-grid {
      display: grid;
      grid-template-columns: 1fr 1.15fr;
      gap: 20px;
      align-items: start;
      min-height: 0;
    }
    .doc-overlay-top {
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 18px;
    }
    .doc-overlay-left {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .doc-overlay-left-card {
      background: #ffffff;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      padding: 20px;
    }
    .doc-overlay-preview {
      background: #ffffff;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      padding: 16px;
    }
    .doc-overlay-textarea {
      width: 100%;
      min-height: 520px;
      resize: vertical;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      padding: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12.5px;
      line-height: 1.45;
      background: #f8fafc;
      color: var(--c-text);
      white-space: pre;
      overflow: auto;
    }

    /* Ensure the documentation overlay never grows beyond viewport */
    #doc-generator-overlay .bilag-modal {
      max-height: calc(100vh - 48px);
      display: flex;
      flex-direction: column;
    }
    #doc-generator-overlay .bilag-body {
      flex: 1 1 auto;
      min-height: 0;
      overflow: auto;
    }
    #doc-generator-overlay .bilag-actions {
      flex: 0 0 auto;
    }

    .doc-placeholder-fields {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    .doc-placeholder-fields .form-field label {
      font-weight: 600;
    }
    .doc-placeholder-fields textarea {
      min-height: 84px;
      resize: vertical;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      padding: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12.5px;
      line-height: 1.45;
      background: #ffffff;
      color: var(--c-text);
    }

    .doc-attachment-box {
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 10px;
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      background: #ffffff;
    }
    .doc-attachment-row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    .doc-attachment-row input[type="file"] {
      max-width: 100%;
    }
    .doc-attachment-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .doc-attachment-item {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
      padding: 10px;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      background: #f8fafc;
    }
    .doc-attachment-meta {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      font-size: 12.5px;
      color: #0f172a;
    }
    .doc-attachment-meta .muted {
      color: #64748b;
    }
    .doc-attachment-item input[type="text"] {
      width: 100%;
    }
    @media (max-width: 1100px) {
      .doc-overlay-grid { grid-template-columns: 1fr; }
      .doc-overlay-textarea { min-height: 420px; }
    }
    #validation-btn:hover {
      background: var(--c-primary-hover);
    }

    /* =========================================================
       Palette Theme Overrides (applies across full layout)
       ========================================================= */
    html, body {
      background: var(--c-bg) !important;
      color: var(--c-text) !important;
    }

    .topbar,
    .bottombar {
      background: var(--c-surface) !important;
      border-color: var(--c-border) !important;
      color: var(--c-text) !important;
    }

    .brand .logo { background: var(--c-primary) !important; }
    .brand .titles .subtitle,
    .muted { color: var(--c-text-muted) !important; }

    /* Popup/info buttons + guidance tooltip */
    .info-icon,
    .info-icon.para-icon,
    .q-icon,
    .q-icon.q-icon-big,
    .para-icon {
      background: var(--c-accent) !important;
      border-color: var(--c-accent) !important;
      color: var(--c-on-primary) !important;
    }

    /* Make info buttons a bit larger + consistent */
    .info-icon {
      width: 16px !important;
      height: 16px !important;
      line-height: 16px !important;
      font-size: 11px !important;
    }
    .info-icon.para-icon {
      width: 24px !important;
      height: 24px !important;
      line-height: 24px !important;
      font-size: 16px !important;
    }
    .q-icon {
      width: 24px !important;
      height: 24px !important;
      font-size: 14px !important;
    }
    .q-icon.q-icon-big {
      width: 24px !important;
      height: 24px !important;
      line-height: 24px !important;
      font-size: 16px !important;
    }
    .info-icon:hover,
    .q-icon:hover,
    .q-icon.q-icon-big:hover,
    .para-icon:hover {
      filter: brightness(0.95);
    }

    #info-tooltip {
      background: var(--c-surface) !important;
      color: var(--c-text) !important;
      border-color: var(--c-accent) !important;
    }
    #info-tooltip.above::after { border-top-color: var(--c-surface) !important; }
    #info-tooltip.below::after { border-bottom-color: var(--c-surface) !important; }

    /* Validation modal palette fixes */
    .validation-content {
      background: var(--c-surface) !important;
      color: var(--c-text) !important;
    }
    .validation-header,
    .validation-footer {
      border-color: var(--c-border) !important;
    }
    .validation-header h2 {
      color: var(--c-primary) !important;
    }
    .validation-tabs {
      border-bottom-color: var(--c-border) !important;
    }
    .validation-tab {
      color: var(--c-text-muted) !important;
    }
    .validation-tab.active {
      color: var(--c-primary) !important;
      border-bottom-color: var(--c-primary) !important;
    }
    .validation-tab:hover {
      color: var(--c-primary) !important;
    }
    .validation-item {
      background: var(--c-surface-muted) !important;
      border-color: var(--c-border) !important;
    }
    .validation-item-title {
      color: var(--c-text) !important;
    }
    .validation-checkbox input[type="checkbox"] {
      accent-color: var(--c-accent) !important;
    }
    .validation-checkbox label {
      color: var(--c-accent) !important;
    }

    /* “Se figur/Se figurer” pill palette fixes */
    .krav-pill {
      background: var(--c-bg-2) !important;
      border-color: var(--c-primary) !important;
      color: var(--c-primary) !important;
    }
    .krav-pill:hover {
      background: var(--c-surface-muted) !important;
      border-color: var(--c-primary) !important;
      color: var(--c-primary) !important;
    }
    .krav-pill:active {
      background: var(--c-bg) !important;
      border-color: var(--c-primary) !important;
    }
    .krav-pill:focus-visible {
      outline: 2px solid var(--c-primary) !important;
      outline-offset: 2px !important;
    }

    .krav-check-all-btn {
      background: var(--c-accent) !important;
      border-color: var(--c-accent) !important;
      color: var(--c-on-primary) !important;
    }
    .krav-check-all-btn:hover { filter: brightness(0.95); }
    .krav-check-all-btn:active { filter: brightness(0.90); }
    .krav-ok-cb {
      accent-color: var(--c-accent) !important;
    }
    .krav-check.ok .krav-check-text {
      color: var(--c-accent) !important;
      text-decoration-color: var(--c-accent) !important;
    }
    .krav-viewer-missing {
      color: var(--c-primary) !important;
    }

    .card,
    .result-row,
    .result-card,
    .result-section-card,
    .prestep-card,
    .bilag-note,
    .krav-title-block,
    .krav-check,
    .cat-docs-list,
    .mini-popup {
      background: var(--c-surface) !important;
      border-color: var(--c-border) !important;
      color: var(--c-text) !important;
    }

    .acc-item,
    .download-row,
    .continue-btn-wrapper {
      border-color: var(--c-border) !important;
    }

    .acc-header,
    .krav-title-header,
    .cat-docs,
    .upload-area,
    .legend-item,
    .figure-toolbar,
    .figure-frame,
    .lightbox-toolbar,
    .lightbox-frame,
    .doc-attachment-item {
      background: var(--c-surface-muted) !important;
      border-color: var(--c-border) !important;
      color: var(--c-text) !important;
    }

    /* Text colors */
    .result-label,
    .result-value-inline,
    .legend-value,
    .figure-meta .ref,
    .krav-title,
    .krav-desc,
    .krav-desc .text,
    .cat-docs-title,
    .cat-doc-row-title,
    .doc-attachment-meta,
    .doc-attachment-meta strong,
    .step1-field-list .form-field label {
      color: var(--c-text) !important;
    }

    .result-help,
    .result-description,
    .opt-help-title,
    .opt-help-text,
    .figure-caption,
    .figure-meta .count,
    .lightbox-count,
    .lightbox-caption,
    .krav-desc .label,
    .krav-doc-panel label,
    .krav-doc-bilag,
    .cat-docs-sub,
    .cat-doc-field-label,
    .cat-doc-empty,
    .download-row .download-label,
    .legend-label,
    .prestep-kicker,
    .bilag-kicker,
    .bilag-field .help,
    .doc-attachment-meta .muted {
      color: var(--c-text-muted) !important;
    }

    /* Inputs */
    input[type="number"],
    input[type="text"],
    input[type="file"],
    select,
    textarea,
    .json-textarea,
    .cat-doc-input,
    .cat-doc-textarea,
    .doc-overlay-textarea,
    .mini-popup input {
      background: var(--c-surface) !important;
      border-color: var(--c-border) !important;
      color: var(--c-text) !important;
      accent-color: var(--c-primary) !important;
    }

    input:focus,
    select:focus,
    textarea:focus {
      outline: none !important;
      border-color: var(--c-primary) !important;
      box-shadow: var(--focus-ring) !important;
    }

    /* Buttons / tabs */
    .btn-primary,
    #validation-btn,
    .tab-btn.active {
      background: var(--c-primary) !important;
      border-color: var(--c-primary) !important;
      color: var(--c-primary-contrast) !important;
    }
    .btn-primary:hover,
    #validation-btn:hover {
      background: var(--c-primary-hover) !important;
      border-color: var(--c-primary-hover) !important;
    }

    .btn-secondary,
    .tab-btn {
      background: var(--c-surface-muted) !important;
      border-color: var(--c-border) !important;
      color: var(--c-text) !important;
    }
    .btn-secondary:hover { background: var(--c-bg-2) !important; }

    /* Wizard */
    .step-number {
      background: var(--c-surface-muted) !important;
      color: var(--c-text-muted) !important;
    }
    .wizard-step.active .step-number {
      background: var(--c-primary) !important;
      color: var(--c-primary-contrast) !important;
    }
    .wizard-step.completed .step-number {
      background: var(--c-text-muted) !important;
      color: var(--c-primary-contrast) !important;
    }
    .step-label,
    .wizard-step.active .step-label { color: var(--c-text) !important; }
    .wizard-step[role="button"]:focus-visible {
      outline: 3px solid rgba(var(--brand-sand-rgb), 0.70) !important;
      outline-offset: 4px;
    }

    /* Pre-step pills */
    .prestep-step {
      background: var(--c-surface-muted) !important;
      border-color: var(--c-border) !important;
      color: var(--c-text-muted) !important;
    }
    .prestep-step.active {
      background: var(--c-bg-2) !important;
      border-color: var(--c-primary) !important;
      color: var(--c-primary) !important;
    }
    .prestep-step.done {
      background: var(--c-bg-2) !important;
      border-color: var(--c-accent) !important;
      color: var(--c-accent) !important;
    }

    .prestep-badge.ok {
      background: var(--c-bg-2) !important;
      border-color: var(--c-accent) !important;
      color: var(--c-accent) !important;
    }
    .prestep-badge.missing {
      background: var(--c-surface-muted) !important;
      border-color: var(--c-text-muted) !important;
      color: var(--c-text-muted) !important;
    }

    /* Status / badges */
    #validation-status-badge {
      background: var(--c-accent) !important;
      color: var(--c-accent-contrast) !important;
    }
    #current-section-name { color: var(--c-primary) !important; }

    .result-status.ok {
      background: var(--status-ok-bg) !important;
      border-color: var(--status-ok-border) !important;
      color: var(--status-ok-text) !important;
    }
    .result-status.missing {
      background: var(--status-bad-bg) !important;
      border-color: var(--status-bad-border) !important;
      color: var(--status-bad-text) !important;
    }
    .result-status.pending {
      background: var(--c-bg-2) !important;
      border-color: var(--c-border) !important;
      color: var(--c-text-muted) !important;
    }

    .legend-value.brand { color: var(--c-primary) !important; }

    /* Figure/table navigation button states */
    .figure-nav-btn:hover,
    .lightbox-btn:hover {
      background: var(--c-surface-muted) !important;
    }
    .figure-nav-btn:active,
    .lightbox-btn:active {
      background: var(--c-bg-2) !important;
    }

    /* Form-field focus + select option theming */
    .form-field input[type="number"],
    .form-field input[type="text"],
    .form-field select {
      accent-color: var(--c-primary) !important;
      border-color: var(--c-border) !important;
      color: var(--c-text) !important;
      background: var(--c-surface) !important;
    }
    .form-field select:focus {
      outline: none !important;
      border-color: var(--c-primary) !important;
      box-shadow: var(--focus-ring-strong) !important;
    }
    .form-field select option {
      background: var(--c-surface) !important;
      background-color: var(--c-surface) !important;
      color: var(--c-text) !important;
    }
    .form-field select option:hover,
    .form-field select option:focus,
    .form-field select option:active,
    .form-field select option:checked {
      background: var(--c-surface-muted) !important;
      background-color: var(--c-surface-muted) !important;
      color: var(--c-text) !important;
    }
    .form-field select:focus option:checked {
      background: linear-gradient(0deg, var(--c-surface-muted) 0%, var(--c-surface-muted) 100%) !important;
    }

    .validation-item-checkbox {
      accent-color: var(--c-accent) !important;
    }

    /* Optimization highlights */
    .step1-field-list .form-field.opt-highlight {
      border-color: var(--status-bad-border) !important;
      background: var(--status-bad-bg) !important;
      box-shadow: var(--status-bad-ring) !important;
    }
    .step1-field-list .form-field.opt-highlight label {
      color: var(--status-bad-text) !important;
    }
    .step1-field-list .form-field.opt-highlight input,
    .step1-field-list .form-field.opt-highlight select {
      border-color: var(--status-bad-border) !important;
    }
    .step1-field-list .form-field.opt-highlight.opt-highlight-opt {
      border-color: var(--status-ok-border) !important;
      background: var(--status-ok-bg) !important;
      box-shadow: var(--status-ok-ring) !important;
    }
    .step1-field-list .form-field.opt-highlight.opt-highlight-opt input,
    .step1-field-list .form-field.opt-highlight.opt-highlight-opt select {
      border-color: var(--status-ok-border) !important;
    }
    .step1-field-list .form-field.opt-highlight.opt-highlight-opt label {
      color: var(--status-ok-text) !important;
    }
    @keyframes optPulse {
      0% { box-shadow: 0 0 0 0 rgba(var(--brand-slate-rgb), 0.0); }
      40% { box-shadow: 0 0 0 6px rgba(var(--brand-slate-rgb), 0.22); }
      100% { box-shadow: 0 0 0 3px rgba(var(--brand-slate-rgb), 0.18); }
    }

    /* Overlays */
    .prestep-overlay,
    .bilag-overlay,
    .lightbox-overlay {
      background: var(--overlay-bg) !important;
    }

    /* Remove remaining bright status hues from ranked optimization boxes */
    .opt-help-item.rank-1 { background: var(--status-ok-bg) !important; border-color: var(--status-ok-border) !important; }
    .opt-help-item.rank-2 { background: var(--status-warn-bg) !important; border-color: var(--status-warn-border) !important; }
    .opt-help-item.rank-3 {
      background: var(--c-bg-2) !important;
      border-color: var(--brand-brown) !important;
    }
    .opt-help-item.rank-4 { background: var(--status-bad-bg) !important; border-color: var(--status-bad-border) !important; }
    .opt-help-item.rank-1 .opt-rank-name { color: var(--status-ok-text) !important; }
    .opt-help-item.rank-2 .opt-rank-name { color: var(--status-warn-text) !important; }
    .opt-help-item.rank-3 .opt-rank-name { color: var(--brand-brown) !important; }
    .opt-help-item.rank-4 .opt-rank-name { color: var(--status-bad-text) !important; }

    /* Inline-style heavy sections */
    #final-summary,
    #building-tabs,
    #section-tabs {
      background: var(--c-surface-muted) !important;
      border-color: var(--c-border) !important;
      color: var(--c-text) !important;
    }
  </style>
</head>
<body spellcheck="false">
  <div class="topbar">
    <div class="brand" style="cursor: pointer;" onclick="goToStep(1);" title="Tilbage til forsiden">
      <span class="logo"></span>
      <div class="titles">
        <div class="title">Digitalt beslutningssystem til
brandstrategi i tidlig designfase</div>
        <div class="subtitle">Anvendelseskategori → Risikoklasse → Brandklasse</div>
      </div>
    </div>
    <div class="top-actions">
      <div id="validation-status-badge" style="display:none; padding: 6px 12px; background: var(--c-accent); color: var(--c-on-primary); border-radius: 8px; font-size: 13px; font-weight: 600;">
        ✓ System Valideret
      </div>
      <button id="save-project-btn" class="btn-secondary" style="padding: 8px 16px; font-weight: 600;">
        💾 Gem Projekt
      </button>
      <label for="load-project-input" class="btn-secondary" style="padding: 8px 16px; font-weight: 600; cursor: pointer; margin: 0;">
        📂 Indlæs Projekt
      </label>
      <input type="file" id="load-project-input" accept=".json" style="display: none;" />
      <button id="validation-btn" style="background: var(--c-primary); color: var(--c-on-primary); border: none; padding: 8px 16px; border-radius: 8px; font-weight: 600; cursor: pointer; transition: background 0.2s;">
        Brandrådgiver Validering
      </button>
    </div>
  </div>

  

  <div class="layout">
    <!-- Wizard Steps Indicator -->
    <div style="padding: 16px 24px 0 24px;">
      <div class="wizard-steps">
        <div class="wizard-step active" id="step-indicator-1">
          <div class="step-number">1</div>
          <div class="step-label">Grundlæggende data</div>
        </div>
        <div class="wizard-step" id="step-indicator-2">
          <div class="step-number">2</div>
          <div class="step-label">Brandklasse</div>
        </div>
        <div class="wizard-step" id="step-indicator-3">
          <div class="step-number">3</div>
          <div class="step-label">Krav</div>
        </div>
        <div class="wizard-step" id="step-indicator-4">
          <div class="step-number">4</div>
          <div class="step-label">Opsummering</div>
        </div>
      </div>
      <!-- Current section name display -->
      <div id="current-section-name" style="text-align: center; margin-top: 12px; font-size: 45px; font-weight: 600; color: var(--c-primary);">
        Bygningsafsnit 1
      </div>
    </div>
    
    <div class="main" id="wizard-step-1">
      <!-- LEFT PANEL: Bygningsdata form (accordion) -->
      <div class="left-panel">
        <div class="card">
          <div style="display:flex; align-items:center; justify-content:space-between;">
            <h2 style="margin:0;">Bygningsdata</h2>
          </div>

          <!-- Continue Button (top) -->
          <div class="continue-btn-wrapper" style="margin-top: 12px; padding-top: 0; border-top: 0;">
            <button id="btn-continue-step1-top" class="btn-primary" style="padding: 12px 24px; font-size: 15px;">
              Fortsæt til brandklasse →
            </button>
          </div>

          <!-- Step 1: flattened, ordered long list of fields (DOM moved here by JS) -->
          <div id="step1-field-list" class="step1-field-list"></div>

          <div class="accordion" id="data-accordion">
            <div class="acc-item open">
              <div class="acc-header">1. Generelt</div>
              <div class="acc-content">
                <div class="form-grid">
                  <div class="form-field">
                    <label>Bygningstype <span class="info-icon" title="Vælg den type bygning der bedst matcher projektet">i</span></label>
                    <select id="fld_bygningstype"></select>
                  </div>
                  <div class="form-field">
                    <label>Areal af bygningsafsnit [m²] <span class="info-icon" title="Samlet bruttoareal for det aktuelle bygningsafsnit">i</span></label>
                    <input type="number" id="fld_area_BA" />
                  </div>
                  <div class="form-field">
                    <label>Er bygningen brandmæssigt fritliggende? <span class="info-icon" title="En brandmæssigt fritliggende bygning er en bygning, der ligger så langt fra andre bygninger, at en brand ikke forventes at kunne sprede sig til nabobygninger. To bygningsafsnit betragtes som brandmæssigt fritliggende, hvis afstanden mellem de to bygningsafsnit svarer til mindst summen af de to bygningsafsnits afstandskrav til naboskel. Eksempelvis skal et enfamiliehus med facader udført som beklædning klasse K1 10 / D-s2,d2 [Klasse 2-beklædning] og tagdækning udført som tagdækning BROOF (t2) [Klasse T-tagdækning] have en afstand på mindst 2,5 m til naboskel. For at to sådanne enfamiliehuse er brandmæssigt fritliggende, skal afstanden mellem enfamiliehusene mindst være 2,5 m + 2,5 m = 5,0 m.">i</span></label>
                    <select id="fld_fritliggende_BA"><option value="" selected disabled>Vælg…</option><option value="true">Ja</option><option value="false">Nej</option></select>
                  </div>
                  <div class="form-field">
                    <label>Total bygningsareal (hele bygningen) [m²] <span class="info-icon" title="Samlet bruttoareal for hele bygningen">i</span></label>
                    <input type="number" id="fld_area_total" />
                  </div>
                  <div class="form-field"><label>Er der direkte udgange? <span class="info-icon" title="Angiv om der findes direkte adgang til det fri fra alle opholdsrum i bygningsafsnittet">i</span></label><select id="fld_direkte_udgange"><option value="true" selected>Ja</option><option value="false">Nej</option></select></div>
                  <div class="form-field"><label>Er der direkte udgange fra soverummene? <span class="info-icon" title="Angiv om soverum har direkte udgang til det fri.">i</span></label><select id="fld_direkte_udgange_soverum"><option value="true" selected>Ja</option><option value="false">Nej</option></select></div>
                </div>
              </div>
            </div>
            <div class="acc-item">
              <div class="acc-header">2. Anvendelseskategori</div>
              <div class="acc-content">
                <div class="form-grid">
                  <div class="form-field"><label>Er der overnatning i bygningsafsnittet? <span class="info-icon" title="Angiv om brugerne forventes at sove eller opholde sig natten over i afsnittet">i</span></label><select id="fld_overnatning"><option value="" disabled selected>Vælg…</option><option value="true">Ja</option><option value="false">Nej</option></select></div>
                  <div class="form-field"><label>Har brugerne kendskab til flugtvejene? <span class="info-icon" title="Angiv om brugerne er bekendt med flugtveje og nødudgange">i</span></label><select id="fld_kendskab_flugtveje"><option value="" disabled selected>Vælg…</option><option value="false">Nej</option><option value="true">Ja</option></select></div>
                  <div class="form-field"><label>Er brugerne selvhjulpne? <span class="info-icon" title="Angiv om brugerne kan evakuere på egen hånd uden assistance">i</span></label><select id="fld_selvhjulpen"><option value="" disabled selected>Vælg…</option><option value="true">Ja</option><option value="false">Nej</option></select></div>
                  <div class="form-field"><label>Hvor mange personer forventes at bruge bygningsafsnittet? <span class="info-icon" title="Angiv hvor mange personer der maksimalt forventes at bruge bygningsafsnittet på samme tid">i</span></label><input type="number" id="fld_antal_personer_BA" value="55"/></div>
                </div>
              </div>
            </div>
            <div class="acc-item">
              <div class="acc-header">3. Bygning & etager</div>
              <div class="acc-content">
                <div class="form-grid">
                  <div class="form-field"><label>Hvor mange etager er der over terræn i bygningsafsnittet? <span class="info-icon" title="Antal etager der ligger over terræn-niveau">i</span></label><input type="number" id="fld_antal_etager_over_terraen_BA" value="1"/></div>
                  <div class="form-field"><label>Hvor mange etager under terræn er der i bygningsafsnittet? <span class="info-icon" title="Antal etager der ligger under terræn-niveau">i</span></label><input type="number" id="fld_antal_etager_under_terraen_BA" value="1"/></div>
                  <div class="form-field"><label>Hvad er øverste etages gulvhøjde for hele bygningen? [m] <span class="info-icon" title="Gulvhøjde for den øverste etage i hele bygningen, målt fra terræn">i</span></label><input type="number" id="fld_etage_hoejde" /></div>
                  <div class="form-field"><label>Hvad er øverste etages gulvhøjde i dette bygningsafsnit? [m] <span class="info-icon" title="Gulvhøjde for den øverste etage i dette bygningsafsnit, målt fra terræn">i</span></label><input type="number" id="fld_etage_hoejde_BA" value="9"/></div>
                  <div class="form-field"><label>Hvad er bygningsafsnittets dybde under terræn? [m] <span class="info-icon" title="Gulvhøjde af nederste kælderetage i bygningsafsnittet under terræn, målt fra terræn">i</span></label><input type="number" id="fld_etage_dybde_BA" value="4.9"/></div>
                  <div class="form-field"><label>Hvor mange etager er der i bygningsafsnittet? <span class="info-icon" title="Samlet antal etager i det pågældende bygningsafsnit.">i</span></label><input type="number" id="fld_antal_etager_BA" value="2"/></div>
                </div>
              </div>
            </div>
            <div class="acc-item">
              <div class="acc-header">4. Brandbelastning</div>
              <div class="acc-content">
                <div class="form-grid">
                  <div class="form-field"><label>Hvad er bygningens brandbelastning? [MJ/m²] <span class="info-icon" title="Forventet brandbelastning pr. kvadratmeter. Kan udregnes, men opdeles også i følgende grupper (Såfremt byggeriet ikke indebærer risiko for høj brandbelastning, såsom visse lagerbygninger med stort inventar, kan der blot angives en estimeret værdi inden for den lave brandbelastningsgruppe):&#10;• Ultra lav brandbelastning: Højst 50 MJ/m²&#10;• Meget lav brandbelastning: Fra 50 MJ/m² og højst 250 MJ/m²&#10;• Lav brandbelastning: Fra 250 MJ/m² og højst 800 MJ/m²&#10;• Stor brandbelastning: Fra 800 MJ/m² og højst 1.600 MJ/m²&#10;• Meget stor brandbelastning: Større end 1.600 MJ/m²">i</span></label><input type="number" id="fld_brandbelastning_BA" value="1500"/></div>
                </div>
              </div>
            </div>
            <div class="acc-item">
              <div class="acc-header">5. Særlige forhold</div>
              <div class="acc-content">
                <div class="form-grid">
                  <div class="form-field">
                    <label>Er der en tilbygning? <span class="info-icon" title="Angiv om der er en tilbygning.">i</span></label>
                    <select id="fld_med_tilbygning"><option value="" selected disabled>Vælg…</option><option value="false">Nej</option><option value="true">Ja</option></select>
                  </div>
                  <div class="form-field">
                    <label>Er der erhvervssammenbygning? <span class="info-icon" title="Angiv om bygningen er sammenbygget med erhverv">i</span></label>
                    <select id="fld_med_erhvervssammenbygning"><option value="" selected disabled>Vælg…</option><option value="false">Nej</option><option value="true">Ja</option></select>
                  </div>
                  <div class="form-field">
                    <label>Antal fravigelser fra præ-accepterede <span class="info-icon" title="Hvis byggeriet ikke kan henføres til en præ-accepteret løsning, indplaceres det i brandklasse 2, så længe der er færre end tre væsentlige fravigelser. Dette kræver, at en certificeret brandrådgiver (BK2) inddrages. Som udgangspunkt angives 0, men vær opmærksom på, at et større antal fravigelser har betydning og vil kræve yderligere brandrådgivning ud over dette værktøj">i</span></label>
                    <input type="number" id="fld_antal_fravigelser_fra_praeaccepterede" />
                  </div>
                  <div class="form-field"><label>Er nogle af bygningsafnittene i risikoklasse 4? <span class="info-icon" title="Angiv om dele af bygningen klassificeres som risikoklasse 4.">i</span></label><select id="fld_bygningsafsnit_i_RK4"><option value="false" selected>Nej</option><option value="true">Ja</option></select></div>
                  <div class="form-field"><label>Hvor mange overnattende forventes der? <span class="info-icon" title="Angiv antal personer der overnatter i afsnittet.">i</span></label><input type="number" id="fld_antal_overnattende" value="5"/></div>
                </div>
              </div>
            </div>
            <div class="acc-item">
            </div>
          </div>
          
          <!-- Continue Button -->
          <div class="continue-btn-wrapper">
            <button id="btn-continue-step1" class="btn-primary" style="padding: 12px 24px; font-size: 15px;">
              Fortsæt til brandklasse →
            </button>
          </div>
        </div>
      </div>

      <!-- RIGHT PANEL: Tabs JSON / Resultater -->
      <div class="right-panel">
        <div class="card">
          <div class="accordion" id="right-accordion">
            <div class="acc-item open" id="acc-json">
              <div class="acc-header">Automatiseret indtastning</div>
              <div class="acc-content">
                <div style="border:1px solid #e6e8ef; border-radius:10px; padding:12px; background:#fafbfc;">
                  <div style="font-weight:600; margin-bottom:6px;">Fast track (upload/download)</div>
                  <div class="muted" style="margin-bottom:10px;">
                    Hvis du allerede kender felterne, kan du hente en tom JSON-skabelon, udfylde den og uploade den.
                    Du kan også uploade en delvist udfyldt JSON — felter der er tomme (null/"") overskriver ikke formularen.
                  </div>
                  <input type="file" id="file-input" accept=".json" style="display:none;" />
                  <div style="display:flex; flex-wrap:wrap; gap:8px;">
                    <button id="btn-download-template" class="btn-secondary">Hent JSON-skabelon</button>
                    <button id="btn-upload-json" class="btn-secondary">Upload JSON…</button>
                    <button id="load-example" class="btn-secondary">Indlæs eksempel</button>
                    <button id="btn-copy-current" class="btn-secondary" aria-label="Kopiér indtastning" title="Kopiér indtastning" style="padding:8px 10px; min-width:auto;">⧉</button>
                  </div>
                </div>

                <div id="json-advanced" style="display:none; margin-top:10px;">
                  <div class="upload-area" id="upload-area" style="padding:14px;">
                    <div style="font-size: 1.1rem;">📁 Drag/drop JSON her (eller klik)</div>
                  </div>
                  <textarea id="json-textarea" class="json-textarea"></textarea>
                </div>
              </div>
            </div>
            <div class="acc-item open" id="acc-results">
              <div class="acc-header">Resultater</div>
              <div class="acc-content">
                <h3 id="headline-results" style="margin-top:0;">Resultater</h3>
                <div class="muted" style="margin-top: -6px;">Status viser om der er nok data til at beregne feltet.</div>
                <div class="results-list" id="results-list-step1">
                  <div class="result-row" data-key="anvendelse" data-result-row="anvendelse">
                    <div class="left">
                      <div class="result-label">Anvendelseskategori</div>
                      <div id="result-anvendelse-desc" class="result-help"></div>
                    </div>
                    <div class="result-right">
                      <div id="result-anvendelse" class="result-value-inline result-value">-</div>
                      <span id="result-anvendelse-status" class="result-status missing" aria-label="Mangler data" style="display:none;">!</span>
                    </div>
                  </div>

                  <div class="result-row" data-key="risiko" data-result-row="risiko">
                    <div class="left">
                      <div class="result-label">Risikoklasse</div>
                      <div id="result-risiko-desc" class="result-help"></div>
                    </div>
                    <div class="result-right">
                      <div id="result-risiko" class="result-value-inline result-value">-</div>
                      <span id="result-risiko-status" class="result-status missing" aria-label="Mangler data" style="display:none;">!</span>
                    </div>
                  </div>

                  <div class="result-row" data-key="bilag" data-result-row="bilag">
                    <div class="left">
                      <div class="result-label">Relevant bilag</div>
                      <div id="result-bilag-desc" class="result-help"></div>
                    </div>
                    <div class="result-right">
                      <div id="result-bilag" class="result-value-inline result-value">-</div>
                      <span id="result-bilag-status" class="result-status missing" aria-label="Mangler data" style="display:none;">!</span>
                    </div>
                  </div>

                  <div class="result-row" data-key="brand" data-result-row="brandklasse">
                    <div class="left">
                      <div class="result-label">Brandklasse</div>
                      <div id="result-brand-desc" class="result-help"></div>
                    </div>
                    <div class="result-right">
                      <div id="result-brand" class="result-value-inline result-value">-</div>
                      <span id="result-brand-status" class="result-status missing" aria-label="Mangler data" style="display:none;">!</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- STEP 2: Bilag & Brandklasse -->
    <div class="main wizard-content" id="wizard-step-2" style="display:none;">
      <div class="left-panel" style="flex: 1;">
        <div class="card">
          <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom: 12px;">
            <h2 style="margin:0;">Brandklasse</h2>
            <button id="btn-back-step2" class="btn-secondary">← Tilbage til input</button>
          </div>

          <div class="card step2-compact">
            <div id="step2-bk-status" class="muted step2-status">Udfyld input på side 1. Brandklasse beregnes der og vises her.</div>

            <!-- Vigtig information (centered at top, kept compact) -->
            <div id="step2-out-important" class="card step2-important" style="display:none; background:#eff6ff; border: 1px solid #bfdbfe;">
              <div style="font-weight: 850; color:#1e3a8a; margin-bottom: 6px; text-align:center;">Vigtig information</div>
              <div id="step2-out-important-text" class="body" style="color:#0f172a;"></div>
            </div>

            <!-- Legend-style outputs (left aligned, small boxes) -->
            <div id="step2-outputs" style="display:none;">
              <div class="step2-legend step2-legend--main">
                <div id="step2-bk-inline" class="legend-item" style="display:none;">
                  <div class="legend-label">Hvilken brandklasse:</div>
                  <div id="step2-bk-inline-value" class="legend-value brand">-</div>
                  <div id="step2-bk-inline-desc" class="legend-desc"></div>
                </div>
                <div class="legend-item">
                  <div class="legend-label">Er der krav til brandrådgiver?</div>
                  <div id="step2-out-brandraadgiver" class="legend-value">-</div>
                </div>
                <div class="legend-item">
                  <div class="legend-label">Hvilket certificeringsniveau skal brandrådgiveren have?</div>
                  <div id="step2-out-cert" class="legend-value">-</div>
                </div>
                <div class="legend-item">
                  <div class="legend-label">Er der yderligere krav?</div>
                  <div id="step2-out-krav" class="legend-value">-</div>
                </div>
              </div>
            </div>

            <!-- Figures get the remaining space below -->
            <div id="step2-out-figures" class="card step2-figures" style="padding: 12px; margin-top: 12px; display:none;">
              <div class="fig-header">
                <div id="step2-fig-title" class="fig-title" style="white-space: normal; line-height: 1.2; display:none;"></div>
                <div id="step2-fig-subtitle" class="fig-subtitle" style="display:none;"></div>
              </div>
              <div id="step2-figures-debug" class="muted" style="display:none; margin-bottom: 10px; white-space: pre-wrap;"></div>

              <div id="step2-figure-carousel" class="figure-carousel" style="display:none;">
                <button id="step2-fig-prev" class="figure-nav-btn" type="button" aria-label="Forrige figur">‹</button>
                <div class="figure-stage">
                  <div class="figure-frame">
                    <img id="step2-fig-img" alt="" />
                  </div>
                  <div class="figure-meta">
                    <div>
                      <span id="step2-fig-ref" class="ref" style="display:none;">-</span>
                      <span id="step2-fig-count" class="count"></span>
                    </div>
                    <div id="step2-fig-caption" class="figure-caption" style="display:none;"></div>
                    <div id="step2-fig-missing" class="muted" style="display:none; margin-top: 6px; white-space: pre-wrap;"></div>
                    <div style="margin-top: 8px;">
                      <button id="step2-fig-attach" class="btn-secondary" type="button" style="padding: 6px 10px; display:none;">Tilføj til dokumentation</button>
                    </div>
                  </div>
                </div>
                <button id="step2-fig-next" class="figure-nav-btn" type="button" aria-label="Næste figur">›</button>
              </div>
            </div>
          </div>

          <div class="continue-btn-wrapper">
            <button id="btn-continue-step2" class="btn-primary" style="padding: 12px 24px; font-size: 15px;" disabled>Fortsæt til krav →</button>
          </div>
        </div>
      </div>
    </div>

    <!-- STEP 3: Krav & resultater -->
    <div class="main wizard-content" id="wizard-step-3" style="display:none;">
      <div class="left-panel">
        <div class="card">
          <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom: 16px;">
            <h2 style="margin:0;">📋 Krav for dit projekt</h2>
            <div style="display: flex; gap: 12px; align-items: center;">
              <button id="btn-back-step3" class="btn-secondary">← Tilbage til brandklasse</button>
              <button id="btn-continue-step3-top" class="btn-primary" style="padding: 10px 20px; font-size: 14px;">
                Gå til opsummering →
              </button>
            </div>
          </div>
          
          <div style="background: var(--c-bg-2); border: 1px solid var(--c-border); border-radius: 8px; padding: 12px 16px; margin-bottom: 16px;">
            <div style="display: flex; gap: 16px; align-items: center;">
              <div style="flex: 1;">
                <div style="font-size: 13px; color: var(--c-text-muted); margin-bottom: 4px;">Relevant bilag</div>
                <div style="font-weight: 600; font-size: 16px;" id="display-bilag">-</div>
              </div>
              <div style="flex: 1;">
                <div style="font-size: 13px; color: var(--c-text-muted); margin-bottom: 4px;">Anvendelseskategori</div>
                <div style="font-weight: 600; font-size: 16px;" id="display-ak">-</div>
              </div>
              <div style="flex: 1;">
                <div style="font-size: 13px; color: var(--c-text-muted); margin-bottom: 4px;">Risikoklasse</div>
                <div style="font-weight: 600; font-size: 16px;" id="display-rk">-</div>
              </div>
              <div style="flex: 1;">
                <div style="font-size: 13px; color: var(--c-text-muted); margin-bottom: 4px;">Brandklasse</div>
                <div style="font-weight: 600; font-size: 20px; color: var(--c-primary);" id="display-bk">-</div>
              </div>
            </div>
          </div>
          
          <div class="requirements-section" id="requirements-container">
            <!-- Dynamically populated requirements -->
            <div style="text-align: center; padding: 48px; color: #999;">
              <div style="font-size: 48px; margin-bottom: 16px;">📋</div>
              <div>Krav vises når brandklassen er bestemt</div>
            </div>
          </div>
          
          <div class="continue-btn-wrapper" style="margin-top: 24px;">
            <button id="btn-continue-step3" class="btn-primary" style="padding: 12px 24px; font-size: 15px;">
              Gå til opsummering →
            </button>
          </div>
          
        </div>
      </div>
      
      <div class="right-panel">
        <div class="card krav-viewer-card">
          <div class="krav-viewer-header">
            <div id="krav-viewer-title" class="krav-viewer-title">RELEVANTE FIGURER / TABELLER</div>
            <button id="krav-viewer-minimize" class="btn-secondary" type="button" style="padding: 8px 12px;">Vis</button>
          </div>
          <div id="krav-viewer-body" class="krav-viewer-body">
            <div id="krav-viewer-slots" class="krav-viewer-slots">
              <div id="krav-viewer-placeholder" class="krav-viewer-placeholder">Klik “Se figur(er)” eller “Se tabel(ler)” ved et krav for at få vist materialet her.</div>
            </div>

            <div id="krav-viewer-carousel" class="krav-carousel" style="display:none;">
              <button id="krav-viewer-prev" class="figure-nav-btn" type="button" aria-label="Forrige">‹</button>
              <div class="krav-stage">
                <div class="krav-frame">
                  <img id="krav-viewer-img" alt="" />
                </div>
                <div class="krav-viewer-meta">
                  <div>
                    <span id="krav-viewer-ref" class="ref" style="display:none;">-</span>
                    <span id="krav-viewer-count" class="count"></span>
                  </div>
                  <div id="krav-viewer-caption" class="krav-viewer-caption" style="display:none;"></div>
                  <div id="krav-viewer-missing" class="krav-viewer-missing" style="display:none;"></div>
                </div>
              </div>
              <button id="krav-viewer-next" class="figure-nav-btn" type="button" aria-label="Næste">›</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- STEP 4: Opsummering -->
    <div class="main wizard-content" id="wizard-step-4" style="display:none;">
      <div class="card" style="max-width: 1400px; margin: 0 auto;">
        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom: 24px;">
          <div>
            <h2 style="margin:0 0 8px 0;">📊 Samlet opsummering</h2>
            <p style="margin:0; color:var(--c-muted);">Overblik over alle bygningsafsnit og deres brandklassificering</p>
          </div>
          <button id="btn-back-step4" class="btn-secondary">← Tilbage til krav</button>
        </div>

        <!-- Project summary header -->
        <div style="background:var(--c-surface); border:1px solid var(--c-border-strong); border-radius: 12px; padding: 18px 20px; margin-bottom: 24px; color:var(--c-heading);">
          <div style="display:flex; justify-content:space-between; align-items:flex-start; gap: 16px;">
            <div>
              <div style="font-size: 12px; font-weight: 700; color:#64748b; margin-bottom: 6px;">Projekt</div>
              <div style="font-size: 22px; font-weight: 800;" id="summary-project-name">Bygningsprojekt</div>
            </div>
            <div style="text-align: right;">
              <div style="font-size: 12px; font-weight: 700; color:#64748b; margin-bottom: 6px;">Status</div>
              <div style="display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border:1px solid #e6e8ef; border-radius:999px; background:#f8fafc; font-size: 12px; font-weight: 800;">
                <span id="summary-completed-count">0</span>/<span id="summary-total-count">0</span>
                <span style="font-weight:700; color:#64748b;">færdige</span>
              </div>
            </div>
          </div>
        </div>

        <!-- Sections overview -->
        <div id="final-overview" style="display: flex; flex-direction: column; gap: 12px;">
          <!-- Populated by renderFinalOverview() -->
        </div>

        <div id="final-summary" style="margin-top: 24px; padding: 14px 16px; background: #f8fafc; border: 1px solid #e6e8ef; border-radius: 10px; color: #334155; font-size: 14px; text-align: center;">
          <!-- Summary text -->
        </div>

        <!-- Export actions -->
        <div style="display: flex; gap: 12px; margin-top: 32px; padding-top: 24px; border-top: 1px solid #e6e8ef; justify-content: center;">
          <button id="btn-export-pdf" class="btn-secondary" style="padding: 12px 24px;">
            📄 Eksporter til PDF
          </button>
          <button id="btn-export-json" class="btn-secondary" style="padding: 12px 24px;">
            💾 Download JSON
          </button>
          <button id="btn-new-project" class="btn-primary" style="padding: 12px 24px;">
            ➕ Start nyt projekt
          </button>
        </div>
      </div>
    </div>

    <!-- Building + Section Tabs Footer -->
    <div id="building-tabs" style="display:flex; flex-wrap:wrap; gap:8px; align-items:center; padding:8px 24px; border-top:1px solid #e6e8ef; background:#f8fafc;"></div>
    <div id="section-tabs" style="display:flex; flex-wrap:wrap; gap:8px; align-items:center; padding:8px 24px; border-top:1px solid #e6e8ef; background:#fafafa;"></div>

    <!-- BOTTOM ACTION BAR -->
    <div class="bottombar">
      <div id="status-line" class="muted">Sidst opdateret: –</div>
      <div style="display:flex; gap:8px;"></div>
    </div>
  </div>

  <!-- Pre-step explainer overlay (shown before Step 2) -->
  <div id="prestep-overlay" class="prestep-overlay" aria-hidden="true">
    <div class="prestep-modal">
      <div class="prestep-header">
        <div>
          <div class="prestep-kicker">Overblik før du går videre</div>
          <h2 id="prestep-title" style="margin: 2px 0 0;">Forklaring af resultater</h2>
        </div>
        <button id="prestep-close" class="btn-secondary" type="button">Luk</button>
      </div>
      <div id="prestep-steps" class="prestep-steps"></div>
      <div id="prestep-content" class="prestep-content"></div>
      <div class="continue-btn-wrapper" style="justify-content: space-between;">
        <button id="prestep-back" class="btn-secondary" type="button">← Tilbage</button>
        <div style="display:flex; gap:8px;">
          <button id="prestep-skip" class="btn-secondary" type="button">Spring over</button>
          <button id="prestep-next" class="btn-primary" type="button">Næste →</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Documentation Generator Overlay (Step 4) -->
  <div id="doc-generator-overlay" class="bilag-overlay" aria-hidden="true" style="display: none;">
    <div class="bilag-modal" style="max-width: 1280px;">
      <div class="bilag-header">
        <div>
          <div id="doc-generator-kicker" class="bilag-kicker">Brandklasse 1 Dokumentation</div>
          <h2 id="doc-generator-title" style="margin: 2px 0 0;">Generer dokumentation til kommunen</h2>
          <div id="doc-generator-subtitle" class="muted" style="margin-top:6px;">Udfyld projektinformation nedenfor. Værktøjet genererer automatisk den tekniske information.</div>
        </div>
        <button id="doc-gen-close" class="btn-secondary" type="button">Luk</button>
      </div>

      <div class="bilag-body" style="padding: 24px;">

        <div class="doc-overlay-top">
          <h3 style="margin: 0 0 12px 0; font-size: 16px; font-weight: 600; color: var(--c-text);">Teknisk information (genereres automatisk)</h3>
          <div style="display: grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap: 12px; font-size: 14px;">
            <div>
              <span style="color: var(--c-muted);">Dato:</span>
              <strong style="color: var(--c-text); margin-left: 8px;" id="doc-preview-dato"></strong>
            </div>
            <div>
              <span style="color: var(--c-muted);">Version:</span>
              <strong style="color: var(--c-text); margin-left: 8px;">1.0</strong>
            </div>
            <div>
              <span style="color: var(--c-muted);">Bygningstype:</span>
              <strong style="color: var(--c-text); margin-left: 8px;" id="doc-preview-bygningstype"></strong>
            </div>
            <div>
              <span style="color: var(--c-muted);">Forudsat brandklasse:</span>
              <strong style="color: var(--c-text); margin-left: 8px;" id="doc-preview-bk">1</strong>
            </div>
            <div>
              <span style="color: var(--c-muted);">Anvendelseskategori:</span>
              <strong style="color: var(--c-text); margin-left: 8px;" id="doc-preview-ak"></strong>
            </div>
            <div>
              <span style="color: var(--c-muted);">Risikoklasse:</span>
              <strong style="color: var(--c-text); margin-left: 8px;" id="doc-preview-rk"></strong>
            </div>
          </div>
        </div>

        <div class="doc-overlay-grid">
          <!-- LEFT: inputs + technical preview -->
          <div class="doc-overlay-left">
            <div class="doc-overlay-left-card">
              <h3 style="margin: 0 0 10px 0; font-size: 16px; font-weight: 600; color: var(--c-text);">Projektinformation og dokumentfelter</h3>
              <div class="muted" style="margin-top: 10px; line-height: 1.55;">
                <span id="doc-generator-intro">Der skal udarbejdes dokumentation for brandforhold, som redegør for, hvordan brandsikkerheden i enfamiliehuset påtænkes udført, og som dokumenterer, at byggeriet er i overensstemmelse med de præ-accepterede løsninger. For byggeri omfattet af brandklasse 1 skal dokumentationen for brandforhold omfatte alt relevant materiale for byggeriet. Dette inkluderer overordnede beskrivelser og forudsætninger, en redegørelse for valg af brandklasse samt oplysninger om og dokumentation for byggeriets indsatsmæssige forhold.</span>
              </div>

              <div style="margin-top: 16px;">
                <div class="form-grid" style="gap: 16px;">
                  <div class="form-field">
                    <label for="doc-projektnavn" style="font-weight: 600;">Projektnavn *</label>
                    <input type="text" id="doc-projektnavn" placeholder="F.eks. Nyt enfamiliehus, Storegade 123" required>
                  </div>
                  <div class="form-field">
                    <label for="doc-adresse" style="font-weight: 600;">Adresse og matrikel *</label>
                    <input type="text" id="doc-adresse" placeholder="F.eks. Storegade 123, 8000 Aarhus C, Matr.nr. 12a" required>
                  </div>
                  <div class="form-field">
                    <label for="doc-bygherre" style="font-weight: 600;">Bygherre *</label>
                    <input type="text" id="doc-bygherre" placeholder="F.eks. Jens Jensen" required>
                  </div>
                  <div class="form-field">
                    <label for="doc-raadgiver" style="font-weight: 600;">Rådgiver *</label>
                    <input type="text" id="doc-raadgiver" placeholder="F.eks. ABC Arkitekter ApS" required>
                  </div>
                </div>
              </div>

              <div style="height: 1px; background: var(--c-border-strong); margin: 18px 0;"></div>

              <div style="display:flex; align-items:baseline; justify-content:space-between; gap: 12px; flex-wrap: wrap;">
                <h3 style="margin: 0; font-size: 16px; font-weight: 600; color: var(--c-text);">Dokumentfelter</h3>
                <div id="doc-placeholder-summary" class="muted" style="font-size: 13px;"></div>
              </div>
              <div id="doc-placeholder-fields" class="doc-placeholder-fields" style="margin-top: 14px;"></div>
            </div>

          </div>

          <!-- RIGHT: live editable draft -->
          <div class="doc-overlay-preview">
            <div style="display:flex; align-items:flex-start; justify-content:space-between; gap: 12px;">
              <div>
                <div style="font-weight:700; color:var(--c-text);">Dokument (udkast)</div>
                <div class="muted" style="margin-top:4px;">Du kan skrive direkte her. “Generer dokument” downloader teksten som den ser ud nu.</div>
              </div>
              <button id="doc-gen-refresh" class="btn-secondary" type="button" style="padding: 10px 14px;">↻ Opdater udkast</button>
            </div>
            <div style="margin-top: 12px;">
              <textarea id="doc-live-text" class="doc-overlay-textarea" spellcheck="false" placeholder="Udkast genereres når du åbner denne dialog..."></textarea>
            </div>
          </div>
        </div>
      </div>

      <div class="bilag-actions">
        <button id="doc-gen-cancel" class="btn-secondary" type="button">Annuller</button>
        <button id="doc-gen-export-pdf" class="btn-secondary" type="button">📄 PDF</button>
        <button id="doc-gen-export-html" class="btn-secondary" type="button">🖨️ Print (HTML)</button>
        <button id="doc-gen-export-docx" class="btn-secondary" type="button">📝 Word (DOCX)</button>
        <button id="doc-gen-generate" class="btn-primary" type="button">📄 TXT</button>
      </div>
    </div>
  </div>

  <!-- Bilag input overlay (shown before Step 3) -->
  <div id="bilag-overlay" class="bilag-overlay" aria-hidden="true">
    <div class="bilag-modal">
      <div class="bilag-header">
        <div>
          <div class="bilag-kicker">Ekstra oplysninger før krav</div>
          <h2 id="bilag-title" style="margin: 2px 0 0;">Udfyld bilag-specifikke oplysninger</h2>
          <div id="bilag-subtitle" class="muted" style="margin-top:6px;">Disse spørgsmål afhænger af dit relevante bilag og bruges til at finde de korrekte krav.</div>
        </div>
        <button id="bilag-close" class="btn-secondary" type="button">Luk</button>
      </div>

      <div id="bilag-body" class="bilag-body"></div>

      <div class="bilag-actions">
        <div class="right">
          <button id="bilag-save" class="btn-primary" type="button">Gem og fortsæt →</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Fullscreen / expanded image viewer (figures & tables) -->
  <div id="image-lightbox" class="lightbox-overlay" aria-hidden="true">
    <div class="lightbox-modal" role="dialog" aria-modal="true" aria-label="Udvidet figurvisning">
      <div class="lightbox-toolbar">
        <button id="lightbox-close" class="lightbox-btn" type="button" aria-label="Luk">×</button>
      </div>
      <div class="lightbox-stage">
        <button id="lightbox-prev" class="lightbox-nav prev" type="button" aria-label="Forrige">‹</button>
        <img id="lightbox-img" alt="" />
        <button id="lightbox-next" class="lightbox-nav next" type="button" aria-label="Næste">›</button>
      </div>
      <div class="lightbox-meta">
        <div id="lightbox-count" class="lightbox-count"></div>
        <div id="lightbox-caption" class="lightbox-caption" style="display:none;"></div>
        <div id="lightbox-missing" class="krav-viewer-missing" style="display:none;"></div>
      </div>
    </div>
  </div>

  <!-- Lockable, draggable detail panel for Krav_Korrekt_Dimensionering -->
  <div id="krav-dim-panel" aria-hidden="true">
    <div class="dim-header" id="krav-dim-header">
      <div class="dim-title" id="krav-dim-title">Uddybning (korrekt dimensionering)</div>
      <div class="dim-actions">
        <button id="krav-dim-pin" class="dim-btn" type="button">Lås</button>
        <button id="krav-dim-close" class="dim-btn" type="button">Luk</button>
      </div>
    </div>
    <div class="dim-body" id="krav-dim-body"></div>
  </div>

  <script>
    const API_BASE = "http://127.0.0.1:8000";
    let jsonManualEdit = false;
    let syncingFromJson = false;
    let currentStep = 1;
    let latestEvaluation = null;

    // Helper function to format checklist items in a natural way
    function formatChecklistItem(field, name, value, condition) {
      const numValue = parseFloat(value);
      const isNumber = !isNaN(numValue);
      
      // Handle bygningstype
      if (field === 'bygningstype') {
        const typeMap = {
          'Rækkehus': 'et rækkehus',
          'Fritliggende enfamiliehus': 'et fritliggende enfamiliehus',
          'Etagebolig': 'en etagebolig',
          'Butik': 'en butik',
          'Kontor': 'et kontor',
          'Museum': 'et museum',
          'Restaurant': 'en restaurant',
          'Biograf': 'en biograf',
          'Hotel': 'et hotel',
          'Hospital': 'et hospital',
          'Plejehjem': 'et plejehjem',
          'Fængsel': 'et fængsel',
          'Kaserne': 'en kaserne',
          'Idrætshal': 'en idrætshal',
          'Forsamlingslokale': 'et forsamlingslokale'
        };
        const article = typeMap[value] || value.toLowerCase();
        return `Det er ${article}`;
      }

      // Handle fravigelser (deviations)
      if (field.includes('fravigelse') || name.toLowerCase().includes('fravigelse')) {
        const num = parseInt(value);
        if (num === 0) {
          return `Der er ingen fravigelser fra de præ-accepterede løsninger`;
        } else if (num === 1) {
          return `Der er 1 fravigelse fra de præ-accepterede løsninger`;
        }
        return `Der er ${value} fravigelser fra de præ-accepterede løsninger`;
      }

      // Handle gulvhøjde (floor height)
      if (field.includes('gulvhoejde') || field.includes('gulvhøjde') || name.toLowerCase().includes('gulvhøjde')) {
        return `Gulvhøjden på øverste etage er ${value} m`;
      }

      // Handle totalhøjde (total height)
      if (field.includes('totalhoejde') || field.includes('totalhøjde') || name.toLowerCase().includes('totalhøjde')) {
        return `Bygningens totalhøjde er ${value} m`;
      }

      // Handle etager (floors)
      if (field.includes('etager_over_terraen') || name.toLowerCase().includes('etager over terræn')) {
        const num = parseInt(value);
        if (num === 1) {
          return `Der er 1 etage over terræn i bygningsafsnittet`;
        }
        return `Der er ${value} etager over terræn i bygningsafsnittet`;
      }

      if (field.includes('etager_under_terraen') || name.toLowerCase().includes('etager under terræn')) {
        const num = parseInt(value);
        if (num === 1) {
          return `Der er 1 etage under terræn i bygningsafsnittet`;
        }
        return `Der er ${value} etager under terræn i bygningsafsnittet`;
      }

      if (field.includes('antal_etager') && !field.includes('over') && !field.includes('under')) {
        const num = parseInt(value);
        if (num === 1) {
          return `Der er i alt 1 etage i bygningsafsnittet`;
        }
        return `Der er i alt ${value} etager i bygningsafsnittet`;
      }

      // Handle areal (area)
      if (field.includes('areal') || field.includes('area')) {
        if (field === 'area_BA') {
          return `Arealet af bygningsafsnittet er ${value} m²`;
        }
        if (field === 'area_total') {
          return `Det totale areal af bygningen er ${value} m²`;
        }
        if (field.includes('bygningsafsnit')) {
          return `Bygningsafsnittet har et areal på ${value} m²`;
        }
        return `Arealet er ${value} m²`;
      }

      // Handle boolean values
      if (condition === 'true' || condition === 'ja' || condition === true) {
        if (field === 'overnatning') return 'Der foregår overnatning';
        if (field === 'kendskab_flugtveje') return 'Brugerne er bekendt med flugtvejene';
        if (field === 'selvhjulpen') return 'Personerne er selvhjulpne';
        if (field === 'simpelt_bygningsafsnit') return 'Bygningen er simpelt';
        if (field === 'tilbygning' || field === 'med_tilbygning') return 'Der er en tilbygning';
        if (field === 'erhvervssammenbygning' || field === 'med_erhvervssammenbygning') return 'Der er erhvervssammenbygning';
      } else if (condition === 'false' || condition === 'nej' || condition === false) {
        if (field === 'overnatning') return 'Der foregår ikke overnatning';
        if (field === 'kendskab_flugtveje') return 'Brugerne er ikke bekendt med flugtvejene';
        if (field === 'selvhjulpen') return 'Personerne er ikke selvhjulpne';
        if (field === 'simpelt_bygningsafsnit') return 'Bygningen er ikke simpelt';
        if (field === 'tilbygning' || field === 'med_tilbygning') return 'Der er ikke en tilbygning';
        if (field === 'erhvervssammenbygning' || field === 'med_erhvervssammenbygning') return 'Der er ikke erhvervssammenbygning';
      }

      // Don't show comparison operators - they're already validated by the system
      // Just show the clean value in natural language

      // Fallback to original format
      return `${name}: ${value}`;
    }

    // Pre-step explainer state (shown when user clicks "Fortsæt til brandklasse")
    const PRESTEP_EXPLANATIONS = {
      anvendelseskategori: {
        default: 'Her kan du forklare hvorfor dit input lander i denne anvendelseskategori (anmeldelseskriterier) og hvad det betyder for resten af processen.'
      },
      risikoklasse: {
        default: 'Her kan du forklare hvad risikoklassen betyder, og hvorfor denne risikoklasse passer til de indtastede forhold.'
      },
      brandklasse: {
        default: 'Her kan du forklare hvad brandklassen betyder, og hvilke typiske konsekvenser den har for dokumentation og rådgivning.'
      },
      bilag: {
        default: 'Her kan du forklare hvad dette bilag indeholder, og hvorfor det er relevant for projektet.'
      }
    };
    const prestepState = { open: false, index: 0, pages: [] };

    // Bilag-input overlay state (shown when user clicks "Fortsæt til krav")
    const bilagState = {
      open: false,
      bilagId: null,
      template: null,
      fields: [],
    };

    const BILAG_FIELD_DEFAULT_INFO = {
      'med_altan': 'Angiv om bygningen har altan/altaner',
      'sammenbygget': 'Består bygningen af flere sammenbyggede enheder (eksempelvis rækkehuse), hvor der deles ydervægge)',
      'med_straatag': 'Angiv om der er stråtag på bygningen',
      'med_integreret-bygning': 'Er bygningen integreret med en anden bygning (fx garage, carport eller lignende)',
      'B11_gronnetage': 'Er der tagflader med vegetation (grønne tage)',
      'B11_flere_primaere_boligenheder': 'Angiv om der er flere boligenheder på grunden som anses for at være primære bygninger',
    };

    function normalizeBilagId(raw){
      if (raw === null || raw === undefined) return '';
      const s = String(raw).trim().replace(',', '.');
      if (!s) return '';

      const token = s
        .toLowerCase()
        .replace(/\s+/g, '')
        .replace(/[_-]+/g, '');

      // Accept user-facing 1a/1b labels, but keep internal IDs stable.
      // Internal mapping:
      // - 1a -> "1" (assets folder bilag1)
      // - 1b -> "1.1" (assets folder bilag11)
      if (token === '1a' || token === 'bilag1a' || token === 'bilag_1a') return '1';
      if (token === '1b' || token === 'bilag1b' || token === 'bilag_1b') return '1.1';

      // Legacy/numeric aliases
      if (token === '1' || token === 'bilag1' || token === 'bilag_1') return '1';
      if (token === '11' || token === 'bilag11' || token === 'bilag_11') return '1.1';

      return s;
    }

    function formatBilagDisplayId(raw){
      const b = normalizeBilagId(raw);
      if (b === '1') return '1a';
      if (b === '1.1') return '1b';
      return b || '';
    }

    function formatBilagLabel(raw){
      const id = formatBilagDisplayId(raw);
      return id ? `Bilag ${id}` : 'Bilag';
    }

    function getBilagValueFromEvaluation(evalRes){
      if (!evalRes) return '';
      const rb = evalRes.relevant_bilag;
      // New/desired shape: { value, matched_rule_id, description }
      if (rb && typeof rb === 'object' && ('value' in rb)) {
        const v = rb.value;
        return (v === null || v === undefined) ? '' : String(v).trim();
      }
      // Legacy/transition shapes
      if (rb !== null && rb !== undefined) return String(rb).trim();
      if (evalRes.bilag !== null && evalRes.bilag !== undefined) return String(evalRes.bilag).trim();
      return '';
    }

    function getBilagTitleFromEvaluation(evalObj){
      if (!evalObj) return '';
      // Preferred: explicit title field
      const bt = evalObj.bilag_titel;
      if (bt && typeof bt === 'object' && ('value' in bt)) {
        const v = bt.value;
        return (v === null || v === undefined) ? '' : String(v).trim();
      }
      if (bt !== null && bt !== undefined) return String(bt).trim();

      // Fallback: some payloads include a human description on relevant_bilag
      const rb = evalObj.relevant_bilag;
      if (rb && typeof rb === 'object') {
        const d = rb.description ?? rb.title ?? rb.label;
        if (d !== null && d !== undefined) return String(d).trim();
      }
      return '';
    }

    function getCurrentBilagId(){
      const evalRes = getActiveEvaluation();
      const raw = getBilagValueFromEvaluation(evalRes);
      return normalizeBilagId(raw);
    }

    function getBilagPassThrough(){
      const bilagId = getCurrentBilagId();
      return {
        Relevant_bilag: bilagId || null,
        antal_etager_over_terraen_BA: asNum('fld_antal_etager_over_terraen_BA'),
        area_BA: asNum('fld_area_BA'),
        bygningstype: (()=>{
          const raw = asStr('fld_bygningstype');
          return raw ? String(raw).trim() : '';
        })(),
      };
    }

    function getBilagTemplateUrl(bilagId){
      if (bilagId === '1') return `${API_BASE}/inputB1.json`;
      if (bilagId === '1.1') return `${API_BASE}/inputB11.json`;
      return '';
    }

    function buildBilagFieldsFromTemplate(bilagId, templateObj){
      const keys = (templateObj && typeof templateObj === 'object') ? Object.keys(templateObj) : [];
      const hasKey = (k)=> keys.includes(k);
      const fields = [];

      // Note: Pass-through felter (relevant bilag, bygningstype, areal, etager, osv.)
      // gemmes stadig i `saveBilagAnswers()`, men vises ikke i overlay'et for at undgå forvirring.

      // Bilag-specific inputs
      if (bilagId === '1'){
        if (hasKey('B1_med_altan')) fields.push({ key: 'B1_med_altan', label: 'Er der altan?', type: 'bool', mapTo: 'med_altan' });
        if (hasKey('B1_sammenbygget')) fields.push({ key: 'B1_sammenbygget', label: 'Er byggeriet sammenbygget?', type: 'bool', mapTo: 'sammenbygget' });
        if (hasKey('straatag')) fields.push({ key: 'straatag', label: 'Er der stråtag?', type: 'bool', mapTo: 'med_straatag' });
        if (hasKey('B1_med_integreret-bygning')) fields.push({ key: 'B1_med_integreret-bygning', label: 'Er der integreret bygning?', type: 'bool', mapTo: 'med_integreret-bygning' });
      }
      if (bilagId === '1.1'){
        if (hasKey('straatag')) fields.push({ key: 'straatag', label: 'Er der stråtag?', type: 'bool', mapTo: 'med_straatag' });
        if (hasKey('B11_gronnetage')) fields.push({ key: 'B11_gronnetage', label: 'Er der grønne tage?', type: 'bool' });
        if (hasKey('B11_flere_primaere_boligenheder')) fields.push({ key: 'B11_flere_primaere_boligenheder', label: 'Er der flere primære boligenheder?', type: 'bool' });
      }

      // Fallback: if template is missing or unknown bilag, still show a minimal message
      if (fields.length === 0){
        fields.push({
          key: '__info__',
          label: 'Ingen ekstra spørgsmål fundet',
          type: 'info',
          value: bilagId ? `Der er pt. ingen bilag-spørgsmål for ${formatBilagLabel(bilagId)}.` : 'Relevant bilag er ikke bestemt endnu. Gå tilbage og udfyld grunddata.'
        });
      }
      return fields;
    }

    function readBilagFieldValue(field, el){
      if (!field || !el) return null;
      if (field.type === 'bool'){
        const v = String(el.value || '').trim();
        if (v === 'true') return true;
        if (v === 'false') return false;
        return null;
      }
      if (field.type === 'number'){
        const raw = String(el.value ?? '').trim();
        if (raw === '') return null;
        const n = Number(raw);
        return Number.isFinite(n) ? n : null;
      }
      if (field.type === 'text'){
        const raw = String(el.value ?? '').trim();
        return raw === '' ? null : raw;
      }
      return null;
    }

    function setBilagOverlayOpen(open){
      const overlay = document.getElementById('bilag-overlay');
      if (!overlay) return;
      bilagState.open = !!open;
      overlay.style.display = open ? 'block' : 'none';
      overlay.setAttribute('aria-hidden', open ? 'false' : 'true');
    }

    function renderBilagOverlay(){
      const body = document.getElementById('bilag-body');
      const title = document.getElementById('bilag-title');
      if (!body) return;
      body.innerHTML = '';

      const bilagId = bilagState.bilagId || '';
      if (title) title.textContent = bilagId ? `Udfyld uddybende spørgsmål på baggrund af ${formatBilagLabel(bilagId)}` : 'Udfyld bilag-specifikke oplysninger';

      const fields = bilagState.fields || [];
      const qWrap = document.createElement('div');
      qWrap.style.marginTop = '12px';
      const qGrid = document.createElement('div');
      qGrid.className = 'bilag-grid';
      qWrap.appendChild(qGrid);
      body.appendChild(qWrap);

      const extras = getActiveBilagExtras();

      fields.forEach((f)=>{
        // Read-only/pass-through felter vises ikke i overlay'et
        if (f.type === 'readonly') return;

        if (f.type === 'info'){
          const info = document.createElement('div');
          info.className = 'bilag-note';
          info.style.gridColumn = '1 / -1';
          info.textContent = String(f.value || '');
          qGrid.appendChild(info);
          return;
        }

        const wrap = document.createElement('div');
        wrap.className = 'bilag-field';
        const lab = document.createElement('label');
        const labelText = document.createElement('span');
        labelText.textContent = f.label;
        lab.appendChild(labelText);

        const info = document.createElement('span');
        info.className = 'info-icon';
        info.textContent = 'i';
        const infoKey = (f.mapTo || f.key);
        const defaultInfo = BILAG_FIELD_DEFAULT_INFO[infoKey] || BILAG_FIELD_DEFAULT_INFO[f.key] || '';
        if (defaultInfo && defaultInfo.trim()) info.setAttribute('data-tip', defaultInfo);
        lab.appendChild(info);
        wrap.appendChild(lab);
        // Always reserve space for helper text so the grid aligns vertically
        const help = document.createElement('div');
        help.className = 'help';
        if (f.help){
          help.textContent = f.help;
        } else {
          help.textContent = ' '; // reserve height
          help.style.visibility = 'hidden';
        }
        wrap.appendChild(help);

        let input;
        if (f.type === 'bool'){
          input = document.createElement('select');
          const opt0 = document.createElement('option'); opt0.value = ''; opt0.textContent = 'Vælg…';
          const opt1 = document.createElement('option'); opt1.value = 'true'; opt1.textContent = 'Ja';
          const opt2 = document.createElement('option'); opt2.value = 'false'; opt2.textContent = 'Nej';
          input.appendChild(opt0); input.appendChild(opt1); input.appendChild(opt2);
          const existing = (extras[f.mapTo || f.key] !== undefined) ? extras[f.mapTo || f.key] : extras[f.key];
          if (existing === true) input.value = 'true';
          else if (existing === false) input.value = 'false';
          else input.value = '';
        } else if (f.type === 'number'){
          input = document.createElement('input');
          input.type = 'number';
          input.step = 'any';
          const existing = (extras[f.mapTo || f.key] !== undefined) ? extras[f.mapTo || f.key] : extras[f.key];
          if (existing !== undefined && existing !== null && String(existing).trim() !== '') input.value = String(existing);
        } else {
          input = document.createElement('input');
          input.type = 'text';
          const existing = (extras[f.mapTo || f.key] !== undefined) ? extras[f.mapTo || f.key] : extras[f.key];
          if (existing !== undefined && existing !== null && String(existing).trim() !== '') input.value = String(existing);
        }

        input.setAttribute('data-bilag-field', f.key);
        wrap.appendChild(input);
        qGrid.appendChild(wrap);
      });
      
      // Re-initialize custom selects after bilag overlay is rendered
      setTimeout(() => {
        if (typeof initCustomSelects === 'function') initCustomSelects();
      }, 50);
    }

    async function openBilagOverlay(){
      const bilagId = getCurrentBilagId();
      bilagState.bilagId = bilagId;
      bilagState.template = null;

      const url = getBilagTemplateUrl(bilagId);
      if (url){
        try {
          const resp = await fetch(url, { cache: 'no-store' });
          if (resp.ok) bilagState.template = await resp.json();
        } catch(_) {
          bilagState.template = null;
        }
      }

      // If template can't be loaded, use a minimal synthetic template to still show questions
      if (!bilagState.template){
        if (bilagId === '1') bilagState.template = { Relevant_bilag:null, antal_etager_over_terraen_BA:null, area_BA:null, B1_med_altan:null, bygningstype:null, B1_sammenbygget:null, straatag:null, 'B1_med_integreret-bygning': null };
        else if (bilagId === '1.1') bilagState.template = { Relevant_bilag:null, antal_etager_over_terraen_BA:null, area_BA:null, bygningstype:null, straatag:null, B11_gronnetage:null, B11_flere_primaere_boligenheder:null };
        else bilagState.template = { Relevant_bilag:null, antal_etager_over_terraen_BA:null, area_BA:null, bygningstype:null };
      }

      bilagState.fields = buildBilagFieldsFromTemplate(bilagId, bilagState.template);
      setBilagOverlayOpen(true);
      renderBilagOverlay();
      
      // Re-initialize custom selects after overlay is opened and rendered
      setTimeout(() => {
        if (typeof initCustomSelects === 'function') initCustomSelects();
      }, 100);
    }

    function closeBilagOverlay(){
      setBilagOverlayOpen(false);
    }

    function resetBilagAnswers(){
      const bilagId = bilagState.bilagId || getCurrentBilagId();
      const clearKeys = [];
      if (bilagId === '1'){
        clearKeys.push('B1_med_altan', 'B1_sammenbygget', 'straatag', 'B1_med_integreret-bygning');
        clearKeys.push('med_altan', 'sammenbygget', 'med_straatag', 'med_integreret-bygning');
      } else if (bilagId === '1.1'){
        clearKeys.push('straatag', 'B11_gronnetage', 'B11_flere_primaere_boligenheder');
        clearKeys.push('med_straatag');
      }
      clearKeys.forEach(k => setActiveBilagExtra(k, undefined));
      try { renderBilagOverlay(); } catch(_) {}
    }

    function saveBilagAnswers(){
      const body = document.getElementById('bilag-body');
      if (!body) return;
      const inputs = Array.from(body.querySelectorAll('[data-bilag-field]'));
      const fieldsByKey = new Map((bilagState.fields || []).map(f => [f.key, f]));
      inputs.forEach(el => {
        const key = el.getAttribute('data-bilag-field');
        const field = fieldsByKey.get(key);
        if (!field) return;
        const value = readBilagFieldValue(field, el);

        // Always store the raw template key
        setActiveBilagExtra(key, value);

        // Also store mapped key used by Krav.json (if any)
        if (field.mapTo && field.mapTo !== key){
          setActiveBilagExtra(field.mapTo, value);
        }
      });

      // Ensure pass-through fields are present as well (harmless if unused)
      const pass = getBilagPassThrough();
      setActiveBilagExtra('Relevant_bilag', pass.Relevant_bilag);
      setActiveBilagExtra('antal_etager_over_terraen_BA', pass.antal_etager_over_terraen_BA);
      setActiveBilagExtra('area_BA', pass.area_BA);
      setActiveBilagExtra('bygningstype', pass.bygningstype);
    }

    function setResultRowValue(prefix, valueText, descText, opts = {}){
      const valEl = document.getElementById(`result-${prefix}`);
      const descEl = document.getElementById(`result-${prefix}-desc`);
      if (valEl) valEl.textContent = (valueText === null || valueText === undefined || String(valueText).trim() === '') ? '-' : String(valueText);
      if (descEl) {
        const isHtml = !!opts?.descHtml;
        const raw = (descText === null || descText === undefined) ? '' : String(descText);
        if (isHtml) descEl.innerHTML = raw;
        else descEl.textContent = raw;
      }
    }

    function setResultRowStatus(prefix, isComplete){
      const statusEl = document.getElementById(`result-${prefix}-status`);
      if (!statusEl) return;
      // Status icons removed - validation badges show this information instead
      statusEl.classList.remove('ok','missing','pending');
      statusEl.textContent = '';
      statusEl.title = '';
      statusEl.setAttribute('aria-label', '');
      statusEl.style.display = 'none'; // Hide the circle completely
    }

    function prestepExplain(kind, value){
      const cfg = PRESTEP_EXPLANATIONS?.[kind];
      if (!cfg) return '';
      const key = (value === null || value === undefined) ? '' : String(value);
      return (cfg[key] ?? cfg.default ?? '');
    }

    function getActiveEvaluation(){
      try {
        const idx = getActiveSectionIndex();
        return sectionsState?.evaluations?.[idx] ?? latestEvaluation ?? {};
      } catch(_) {
        return latestEvaluation ?? {};
      }

      return '';
    }

    function describeBygningstypeArticle(bygningstype) {
      const raw = (bygningstype === null || bygningstype === undefined) ? '' : String(bygningstype).trim();
      if (!raw) return 'et byggeri';

      // Reuse the same wording style as formatChecklistItem's bygningstype mapping.
      const typeMap = {
        'Rækkehus': 'et rækkehus',
        'Fritliggende enfamiliehus': 'et fritliggende enfamiliehus',
        'Etagebolig': 'en etagebolig',
        'Butik': 'en butik',
        'Kontor': 'et kontor',
        'Museum': 'et museum',
        'Restaurant': 'en restaurant',
        'Biograf': 'en biograf',
        'Hotel': 'et hotel',
        'Hospital': 'et hospital',
        'Plejehjem': 'et plejehjem',
        'Fængsel': 'et fængsel',
        'Kaserne': 'en kaserne',
        'Idrætshal': 'en idrætshal',
        'Forsamlingslokale': 'et forsamlingslokale'
      };

      if (raw in typeMap) return typeMap[raw];

      // Fallback that reads well in sentences like: "Byggeriet er <...> i anvendelseskategori ..."
      return 'af typen "' + raw + '"';
    }

    function getBrandklasseDisplay(evalRes){
      const bkValue = evalRes?.brandklasse?.value;
      if (bkValue !== null && bkValue !== undefined && String(bkValue).trim() !== '') return String(bkValue);
      return '';
    }

    function buildPrestepPages(evalRes){
      const bilagVal = getBilagValueFromEvaluation(evalRes);
      const brandVal = getBrandklasseDisplay(evalRes);

      return [
        {
          kind: 'anvendelseskategori',
          title: '',
          short: 'Anvendelseskategori',
          value: (evalRes?.anvendelseskategori?.value ?? ''),
          description: (evalRes?.anvendelseskategori?.description ?? '')
        },
        {
          kind: 'risikoklasse',
          title: 'Risikoklasse',
          short: 'Risikoklasse',
          value: (evalRes?.risikoklasse?.value ?? ''),
          description: (evalRes?.risikoklasse?.description ?? '')
        },
        {
          kind: 'bilag',
          title: 'Relevant bilag',
          short: 'Bilag',
          value: bilagVal,
          description: ''
        },
        {
          kind: 'brandklasse',
          title: 'Brandklasse',
          short: 'Brandklasse',
          value: brandVal,
          description: (evalRes?.brandklasse?.description ?? '')
        }
      ];
    }

    function openPrestepOverlay(){
      const overlay = document.getElementById('prestep-overlay');
      if (!overlay) return;
      prestepState.pages = buildPrestepPages(getActiveEvaluation());
      prestepState.index = 0;
      prestepState.open = true;
      overlay.style.display = 'block';
      overlay.setAttribute('aria-hidden', 'false');
      try { renderPrestepOverlay(); } catch(_) {}
    }

    function closePrestepOverlay(){
      const overlay = document.getElementById('prestep-overlay');
      if (!overlay) return;
      prestepState.open = false;
      overlay.style.display = 'none';
      overlay.setAttribute('aria-hidden', 'true');
    }

    function renderPrestepOverlay(){
      const overlay = document.getElementById('prestep-overlay');
      if (!overlay || !prestepState.open) return;

      const stepsEl = document.getElementById('prestep-steps');
      const contentEl = document.getElementById('prestep-content');
      const btnBack = document.getElementById('prestep-back');
      const btnNext = document.getElementById('prestep-next');

      const pages = prestepState.pages || [];
      const idx = Math.max(0, Math.min(prestepState.index, pages.length - 1));
      prestepState.index = idx;
      const page = pages[idx] || { title:'', short:'', value:'', description:'', kind:'' };

      const hasValue = (v) => v !== null && v !== undefined && String(v).trim() !== '' && String(v).trim() !== '-';
      const ok = hasValue(page.value);
      const badgeClass = ok ? 'ok' : 'missing';
      const badgeText = ok ? '✓ Klar' : '! Mangler data';

      if (stepsEl){
        stepsEl.innerHTML = pages.map((p, i) => {
          const done = i < idx;
          const active = i === idx;
          const cls = `prestep-step${done ? ' done' : ''}${active ? ' active' : ''}`;
          return `<span class="${cls}">${i+1}. ${p.short || p.title || 'Trin'}</span>`;
        }).join('');
      }

      if (contentEl){
        const explain = prestepExplain(page.kind, page.value);
        const desc = (page.description ?? '').toString().trim();
        const showExplain = (explain ?? '').toString().trim().length > 0;
        
        // Get current section info
        const sectionIdx = getActiveSectionIndex();
        const sectionTitle = sectionsState.titles?.[sectionIdx] || `Bygningsafsnit ${sectionIdx + 1}`;
        
        // Build enhanced explanation based on page type
        let enhancedContent = '';
        if (page.kind === 'anvendelseskategori' && ok) {
          enhancedContent = buildAnvendelseskategoriExplanation(page.value, sectionTitle, sectionIdx);
        } else if (page.kind === 'risikoklasse' && ok) {
          enhancedContent = buildRisikoklasseExplanation(page.value, sectionTitle, sectionIdx);
        } else if (page.kind === 'brandklasse' && ok) {
          enhancedContent = buildBrandklasseExplanation(page.value, sectionTitle, sectionIdx);
        } else if (page.kind === 'bilag' && ok) {
          enhancedContent = buildBilagExplanation(page.value, sectionTitle, sectionIdx);
        }
        
        contentEl.innerHTML = `
          <div class="prestep-card">
            ${enhancedContent ? enhancedContent : `
              <div class="prestep-value">${ok ? String(page.value) : '-'}</div>
              <div class="muted">Dette er beregnet ud fra dine indtastninger på side 1.</div>
              ${(desc || showExplain) ? `<div class="prestep-text">${desc ? `<div style="margin-bottom:8px;"><strong>Systemets begrundelse:</strong><br>${escapeHtml(desc)}</div>` : ''}${showExplain ? `<div><strong>Din forklaring:</strong><br>${escapeHtml(explain)}</div>` : ''}</div>` : ''}
            `}
          </div>
        `;
      }

      if (btnBack) btnBack.disabled = idx <= 0;
      if (btnNext){
        const last = idx >= pages.length - 1;
        btnNext.textContent = last ? 'Videre til brandklasse →' : 'Næste →';
      }
    }
    
    function buildAnvendelseskategoriExplanation(akValue, sectionTitle, sectionIdx) {
      // Get inputs and evaluation for this section
      const inputs = sectionsState.inputData?.[sectionIdx] || {};
      const evaluation = sectionsState.evaluations?.[sectionIdx] || {};
      const matchedRuleId = evaluation?.anvendelseskategori?.matched_rule_id;
      
      console.log('[AK Explanation] Section:', sectionIdx);
      console.log('[AK Explanation] Matched Rule ID:', matchedRuleId);
      console.log('[AK Explanation] Model available:', !!window.BRANDKLASSE_MODEL);
      console.log('[AK Explanation] Inputs:', inputs);
      
      // Try to get the actual active conditions from the matched rule
      let activeConditions = [];
      if (matchedRuleId && window.BRANDKLASSE_MODEL) {
        try {
          const akNode = window.BRANDKLASSE_MODEL.nodes.find(n => n.name === 'Anvendelseskategori 2.0');
          console.log('[AK Explanation] Found AK node:', !!akNode);
          
          if (akNode) {
            const rule = akNode.content.rules.find(r => r._id === matchedRuleId);
            console.log('[AK Explanation] Found matched rule:', !!rule);
            
            // If not found directly, try removing node prefix
            let foundRule = rule;
            if (!foundRule && matchedRuleId.includes('_rule_')) {
              const ruleIndex = parseInt(matchedRuleId.split('_rule_')[1]);
              foundRule = akNode.content.rules[ruleIndex];
              console.log('[AK Explanation] Trying by index:', ruleIndex, 'found:', !!foundRule);
            }
            console.log('[AK Explanation] Rule details:', foundRule);
            
            if (foundRule) {
              const inputDefs = akNode.content.inputs;
              console.log('[AK Explanation] Input definitions:', inputDefs);
              
              // Check each input to see if it was used in the rule
              inputDefs.forEach(inp => {
                const conditionValue = foundRule[inp.id];
                console.log(`[AK Explanation] Field ${inp.field} (${inp.id}): condition="${conditionValue}"`);
                
                // If condition is not empty/wildcard, it was used
                if (conditionValue !== '' && conditionValue !== undefined && conditionValue !== null) {
                  const fieldName = inp.field;
                  const inputValue = inputs[fieldName];
                  const displayName = inp.name;
                  
                  // Format the condition
                  let conditionText = '';
                  if (conditionValue === 'true' || conditionValue === true) {
                    conditionText = 'ja';
                  } else if (conditionValue === 'false' || conditionValue === false) {
                    conditionText = 'nej';
                  } else if (conditionValue.startsWith && (conditionValue.startsWith('<=') || conditionValue.startsWith('<') || conditionValue.startsWith('>'))) {
                    conditionText = conditionValue;
                  } else {
                    conditionText = conditionValue;
                  }
                  
                  activeConditions.push({
                    name: displayName,
                    field: fieldName,
                    condition: conditionText,
                    value: inputValue
                  });
                  
                  console.log(`[AK Explanation] Added active condition:`, { field: fieldName, condition: conditionText, value: inputValue });
                }
              });
              
              console.log('[AK Explanation] Total active conditions found:', activeConditions.length);
            }
          }
        } catch (e) {
          console.error('[AK Explanation] Error analyzing matched rule:', e);
        }
      } else {
        console.log('[AK Explanation] Skipping rule analysis - matchedRuleId:', matchedRuleId, 'model:', !!window.BRANDKLASSE_MODEL);
      }
      
      // Build bullet list from active conditions
      let conditionsList = [];
      if (activeConditions.length > 0) {
        conditionsList = activeConditions.map(ac => {
          return formatChecklistItem(ac.field, ac.name, ac.value, ac.condition);
        });
      } else {
        // Fallback hvis vi ikke kan finde den matchede regel
        conditionsList = [];
        if (inputs.overnatning === 'Ja') {
          conditionsList.push('Der foregår overnatning');
        } else if (inputs.overnatning === 'Nej') {
          conditionsList.push('Der ikke foregår overnatning');
        }
        
        if (inputs.kendskab_flugtveje === 'Ja') {
          conditionsList.push('Brugerne er bekendt med flugtvejene');
        } else if (inputs.kendskab_flugtveje === 'Nej') {
          conditionsList.push('Brugerne ikke er bekendt med flugtvejene');
        }
        
        if (inputs.selvhjulpen === 'Ja') {
          conditionsList.push('Personerne er selvhjulpne');
        } else if (inputs.selvhjulpen === 'Nej') {
          conditionsList.push('Personerne ikke er selvhjulpne');
        }
        
        if (conditionsList.length === 0) conditionsList.push('De indtastede oplysninger');
      }
      
      // Get description for this category
      const categoryDescriptions = {
        '1': {
          desc: 'Bygningsafsnit uden overnatning, hvor personer er stedkendte, og hvor personbelastningen er lav. Flugtvejene er typisk enkle, og der er begrænset behov for særlige evakueringstiltag.',
          examples: 'Kontorer, industribygninger, lagerbygninger, garager, teknikbygninger og mindre klinikker.'
        },
        '2': {
          desc: 'Bygningsafsnit uden overnatning, indrettet til højst 50 personer, hvor personerne ikke nødvendigvis er stedkendte.',
          examples: 'Undervisningsrum, dagcentre for selvhjulpne, mindre butikker, klinikker, mindre forsamlingslokaler og fritidstilbud.'
        },
        '3': {
          desc: 'Bygningsafsnit uden overnatning, indrettet til flere end 50 personer. Ofte høj personbelastning og mange ikke-stedkendte personer, hvilket giver skærpede krav til flugtveje og brandforanstaltninger.',
          examples: 'Butikker, biografer, restauranter, teatre, koncertsale, idrætshaller, diskoteker, mødelokaler og større forsamlingslokaler.'
        },
        '4': {
          desc: 'Bygningsafsnit med overnatning, hvor personerne er selvhjulpne og stedkendte.',
          examples: 'Enfamiliehuse, etageboliger, rækkehuse, kollegier, ungdomsboliger, sommerhuse, shelters og mindre overnatningshytter.'
        },
        '5': {
          desc: 'Bygningsafsnit med overnatning, hvor personerne ikke er stedkendte.',
          examples: 'Hoteller, vandrehjem, kroer med overnatning, pensionater samt kost-, efter- og højskoler samt kollegier, der benyttes som hotellignende funktion med kortvarige ophold.'
        },
        '6': {
          desc: 'Bygningsafsnit hvor personer ikke kan bringe sig selv i sikkerhed, eller kun med væsentlig hjælp.',
          examples: 'Plejeboliger, behandlings- og sengeafsnit på hospitaler, plejhjem, fængsler, vuggestuer, børnehaver og dagcentre for ældre.'
        }
      };
      
      const catInfo = categoryDescriptions[String(akValue)] || { desc: '', examples: '' };
      
      // Format conditions as bullet list
      const bulletList = conditionsList.map(c => `<li style="margin-bottom: 4px;">${c}</li>`).join('');
      
      return `
        <div style="margin: 20px 0 16px 0; padding: 0;">
          <p style="margin: 0 0 12px 0; color: #0f172a; line-height: 1.6;">
            <strong>${sectionTitle}</strong> er indplaceret i <strong>anvendelseskategori ${akValue}</strong> baseret på:
          </p>
          <ul style="margin: 0 0 16px 0; padding-left: 24px; color: #475569; line-height: 1.6;">
            ${bulletList}
          </ul>
        </div>
        ${catInfo.desc ? `
        <div style="margin: 0 0 16px 0;">
          <p style="margin: 0 0 4px 0; font-weight: 600; color: #0f172a;">Om anvendelseskategori ${akValue}:</p>
          <p style="margin: 0; color: #475569; line-height: 1.6;">${catInfo.desc}</p>
        </div>
        ` : ''}
        ${catInfo.examples ? `
        <div style="margin: 0;">
          <p style="margin: 0 0 4px 0; font-weight: 600; color: #0f172a;">Typiske bygningstyper:</p>
          <p style="margin: 0; color: #475569; line-height: 1.6;">${catInfo.examples}</p>
        </div>
        ` : ''}
      `;
    }
    
    function buildRisikoklasseExplanation(rkValue, sectionTitle, sectionIdx) {
      // Get inputs and evaluation for this section
      const inputs = sectionsState.inputData?.[sectionIdx] || {};
      const evaluation = sectionsState.evaluations?.[sectionIdx] || {};
      const matchedRuleId = evaluation?.risikoklasse?.matched_rule_id;
      
      // Get anvendelseskategori from evaluation (from previous page)
      const akValue = evaluation?.anvendelseskategori?.value;
      
      console.log('[RK Explanation] Section:', sectionIdx);
      console.log('[RK Explanation] Matched Rule ID:', matchedRuleId);
      console.log('[RK Explanation] AK Value:', akValue);
      console.log('[RK Explanation] Inputs:', inputs);
      
      // Try to get the actual active conditions from the matched rule
      let activeConditions = [];
      if (matchedRuleId && window.BRANDKLASSE_MODEL) {
        try {
          const rkNode = window.BRANDKLASSE_MODEL.nodes.find(n => n.name === 'Risikoklasse');
          console.log('[RK Explanation] Found RK node:', !!rkNode);
          
          if (rkNode) {
            let foundRule = rkNode.content.rules.find(r => r._id === matchedRuleId);
            
            // If not found directly, try by index
            if (!foundRule && matchedRuleId.includes('_rule_')) {
              const ruleIndex = parseInt(matchedRuleId.split('_rule_')[1]);
              foundRule = rkNode.content.rules[ruleIndex];
              console.log('[RK Explanation] Trying by index:', ruleIndex, 'found:', !!foundRule);
            }
            
            console.log('[RK Explanation] Found matched rule:', !!foundRule);
            
            if (foundRule) {
              const inputDefs = rkNode.content.inputs;
              
              // Check each input to see if it was used in the rule
              inputDefs.forEach(inp => {
                const conditionValue = foundRule[inp.id];
                
                // If condition is not empty/wildcard, it was used
                if (conditionValue !== '' && conditionValue !== undefined && conditionValue !== null) {
                  const fieldName = inp.field;
                  let inputValue = inputs[fieldName];
                  
                  // Special handling for anvendelseskategori - use from evaluation
                  if (fieldName === 'anvendelseskategori') {
                    inputValue = akValue;
                  }
                  
                  const displayName = inp.name;
                  
                  activeConditions.push({
                    name: displayName,
                    field: fieldName,
                    condition: conditionValue,
                    value: inputValue
                  });
                  
                  console.log(`[RK Explanation] Active:`, { field: fieldName, condition: conditionValue, value: inputValue });
                }
              });
              
              console.log('[RK Explanation] Total active conditions:', activeConditions.length);
            }
          }
        } catch (e) {
          console.error('[RK Explanation] Error:', e);
        }
      }
      
      // Build bullet list from active conditions
      let conditionsList = [];
      if (activeConditions.length > 0) {
        conditionsList = activeConditions.map(ac => {
          const field = ac.field;
          const value = ac.value;
          const condition = ac.condition;
          
          // Format based on field type
          if (field === 'anvendelseskategori') {
            return `Anvendelseskategori: ${value}`;
          }
          return formatChecklistItem(field, ac.name, value, condition);
        });
      } else {
        // Fallback
        conditionsList = ['De indtastede oplysninger'];
        if (akValue) {
          conditionsList.push(`Anvendelseskategori: ${akValue}`);
        }
      }
      
      // Get description for this risk class
      const riskDescriptions = {
        '1': 'Risikoklasse 1 indikerer, at byggeriet er simpelt at evakuere uden høj brandbelastning og med et kort brandforløb.',
        '2': 'Risikoklasse 2 kræver skærpede krav sammenlignet med risikoklasse 1.',
        '3': 'Risikoklasse 3 indikerer, at evakueringen er forholdsvis kompleks med længere brandforløb.',
        '4': 'Risikoklasse 4 er den kategori, hvor der sættes højeste krav til brandsikkerhed grundet komplekst og langt brandforløb.'
      };
      
      const riskDesc = riskDescriptions[String(rkValue)] || '';
      
      // Format conditions as bullet list
      const bulletList = conditionsList.map(c => `<li style="margin-bottom: 4px;">${c}</li>`).join('');
      
      return `
        <div style="margin: 20px 0 16px 0; padding: 0;">
          <p style="margin: 0 0 12px 0; color: #0f172a; line-height: 1.6;">
            <strong>${sectionTitle}</strong> er indplaceret i <strong>risikoklasse ${rkValue}</strong> baseret på:
          </p>
          <ul style="margin: 0 0 16px 0; padding-left: 24px; color: #475569; line-height: 1.6;">
            ${bulletList}
          </ul>
        </div>
        ${riskDesc ? `
        <div style="margin: 0 0 16px 0;">
          <p style="margin: 0 0 4px 0; font-weight: 600; color: #0f172a;">Om risikoklasse ${rkValue}:</p>
          <p style="margin: 0; color: #475569; line-height: 1.6;">${riskDesc}</p>
        </div>
        ` : ''}
      `;
    }
    
    function buildBrandklasseExplanation(bkValue, sectionTitle, sectionIdx) {
      // Get inputs and evaluation for this section
      const inputs = sectionsState.inputData?.[sectionIdx] || {};
      const evaluation = sectionsState.evaluations?.[sectionIdx] || {};
      const matchedRuleId = evaluation?.brandklasse?.matched_rule_id;
      
      // Get values from evaluation (from previous pages)
      const akValue = evaluation?.anvendelseskategori?.value;
      const rkValue = evaluation?.risikoklasse?.value;
      
      console.log('[BK Explanation] Section:', sectionIdx);
      console.log('[BK Explanation] Matched Rule ID:', matchedRuleId);
      console.log('[BK Explanation] AK Value:', akValue, 'RK Value:', rkValue);
      
      // Try to get the actual active conditions from the matched rule
      let activeConditions = [];
      if (matchedRuleId && window.BRANDKLASSE_MODEL) {
        try {
          // Try multiple possible node names
          let bkNode = window.BRANDKLASSE_MODEL.nodes.find(n => n.name === 'Brandklasse');
          if (!bkNode) {
            bkNode = window.BRANDKLASSE_MODEL.nodes.find(n => n.name === 'Præ-accepterede løsninger');
          }
          if (!bkNode) {
            // Try to find by checking if node has brandklasse in output
            bkNode = window.BRANDKLASSE_MODEL.nodes.find(n => 
              n.content && n.content.hitPolicy && 
              n.content.outputs && n.content.outputs.some(o => o.field === 'brandklasse')
            );
          }
          console.log('[BK Explanation] Found BK node:', !!bkNode);
          if (bkNode) {
            console.log('[BK Explanation] Node name:', bkNode.name);
          }
          
          if (bkNode) {
            let foundRule = bkNode.content.rules.find(r => r._id === matchedRuleId);
            
            // If not found directly, try by index
            if (!foundRule && matchedRuleId.includes('_rule_')) {
              const ruleIndex = parseInt(matchedRuleId.split('_rule_')[1]);
              foundRule = bkNode.content.rules[ruleIndex];
              console.log('[BK Explanation] Trying by index:', ruleIndex, 'found:', !!foundRule);
            }
            
            console.log('[BK Explanation] Found matched rule:', !!foundRule);
            
            if (foundRule) {
              console.log('[BK Explanation] Full matched rule object:', foundRule);
              const inputDefs = bkNode.content.inputs;
              console.log('[BK Explanation] Input definitions count:', inputDefs.length);
              console.log('[BK Explanation] All input definitions:', inputDefs);
              
              // Check each input to see if it was used in the rule
              inputDefs.forEach(inp => {
                const conditionValue = foundRule[inp.id];
                const conditionType = typeof conditionValue;
                const isArray = Array.isArray(conditionValue);
                console.log(`[BK Explanation] Field: ${inp.field}, ID: ${inp.id}, Condition: ${JSON.stringify(conditionValue)}, Type: ${conditionType}, IsArray: ${isArray}`);
                
                // If condition is not empty/wildcard, it was used
                // Handle arrays (like bygningstype lists) as active conditions
                const isActive = conditionValue !== '' && 
                                conditionValue !== undefined && 
                                conditionValue !== null && 
                                !(isArray && conditionValue.length === 0);
                
                console.log(`[BK Explanation] Is active: ${isActive}`);
                
                if (isActive) {
                  const fieldName = inp.field;
                  let inputValue = inputs[fieldName];
                  
                  // Special handling for previous page values (computed results from earlier nodes)
                  if (fieldName === 'anvendelseskategori') {
                    inputValue = akValue;
                  } else if (fieldName === 'risikoklasse') {
                    inputValue = rkValue;
                  } else if (fieldName === 'relevant_bilag') {
                    inputValue = evaluation?.relevant_bilag?.value;
                  }
                  
                  const displayName = inp.name;
                  
                  activeConditions.push({
                    name: displayName,
                    field: fieldName,
                    condition: conditionValue,
                    value: inputValue
                  });
                  
                  console.log(`[BK Explanation] Active:`, { field: fieldName, condition: conditionValue, value: inputValue });
                }
              });
              
              console.log('[BK Explanation] Total active conditions:', activeConditions.length);
            }
          }
        } catch (e) {
          console.error('[BK Explanation] Error:', e);
        }
      }
      
      // Build bullet list from active conditions
      let conditionsList = [];
      if (activeConditions.length > 0) {
        conditionsList = activeConditions.map(ac => {
          const field = ac.field;
          const value = ac.value;
          const condition = ac.condition;
          
          // Format based on field type
          if (field === 'anvendelseskategori') {
            return `Anvendelseskategori: ${value}`;
          } else if (field === 'risikoklasse') {
            return `Risikoklasse: ${value}`;
          } else if (field === 'relevant_bilag') {
            return `Relevant bilag: ${value}`;
          }
          return formatChecklistItem(field, ac.name, value, condition);
        });
      } else {
        // Fallback - show all relevant values
        conditionsList = [];
        if (akValue) conditionsList.push(`Anvendelseskategori: ${akValue}`);
        if (rkValue) conditionsList.push(`Risikoklasse: ${rkValue}`);
        
        // Add key inputs from section
        if (inputs.simpelt_bygningsafsnit === 'Ja') {
          conditionsList.push('Bygningen er simpelt');
        } else if (inputs.simpelt_bygningsafsnit === 'Nej') {
          conditionsList.push('Bygningen ikke er simpelt');
        }
        
        if (inputs.tilbygning === 'Ja') {
          conditionsList.push('Der er en tilbygning');
        }
        
        if (inputs.erhvervssammenbygning === 'Ja') {
          conditionsList.push('Der er erhvervssammenbygning');
        }
        
        if (inputs.total_bygningsareal) {
          conditionsList.push(`Total bygningsareal: ${inputs.total_bygningsareal} m²`);
        }
        
        if (inputs.antal_etager_over_terræn) {
          conditionsList.push(`Antal etager over terræn: ${inputs.antal_etager_over_terræn}`);
        }
        
        if (conditionsList.length === 0) conditionsList.push('De indtastede oplysninger');
      }
      
      // Get description for this brand class
      const brandDescriptions = {
        '1': 'Brandklasse 1 er for enkle byggerier med lave risici, hvor præ-accepterede løsninger kan anvendes.',
        '2': 'Brandklasse 2 kræver certificeret rådgivning og anvendes ved komplekse projekter eller afvigelser fra præ-accepterede løsninger.',
        '3': 'Brandklasse 3 anvendes primært til ældre bygninger.',
        '4': 'Brandklasse 4 anvendes til helt særlige bygningstyper.'
      };
      
      const brandDesc = brandDescriptions[String(bkValue)] || '';
      
      // Format conditions as bullet list
      const bulletList = conditionsList.map(c => `<li style="margin-bottom: 4px;">${c}</li>`).join('');
      
      return `
        <div style="margin: 20px 0 16px 0; padding: 0;">
          <p style="margin: 0 0 12px 0; color: #0f172a; line-height: 1.6;">
            <strong>${sectionTitle}</strong> er indplaceret i <strong>brandklasse ${bkValue}</strong> baseret på:
          </p>
          <ul style="margin: 0 0 16px 0; padding-left: 24px; color: #475569; line-height: 1.6;">
            ${bulletList}
          </ul>
        </div>
        ${brandDesc ? `
        <div style="margin: 0 0 16px 0;">
          <p style="margin: 0 0 4px 0; font-weight: 600; color: #0f172a;">Om brandklasse ${bkValue}:</p>
          <p style="margin: 0; color: #475569; line-height: 1.6;">${brandDesc}</p>
        </div>
        ` : ''}
      `;
    }
    
    function buildBilagExplanation(bilagValue, sectionTitle, sectionIdx) {
      const getBilagTitleFromEvaluation = (evalObj) => {
        if (!evalObj) return '';
        const bt = evalObj.bilag_titel;
        if (bt && typeof bt === 'object' && ('value' in bt)) {
          const v = bt.value;
          return (v === null || v === undefined) ? '' : String(v).trim();
        }
        if (bt !== null && bt !== undefined) return String(bt).trim();
        return '';
      };

      function getBilagDownloadInfo(rawBilagValue){
        const raw = (rawBilagValue === null || rawBilagValue === undefined) ? '' : String(rawBilagValue).trim();
        const lower = raw.toLowerCase();

        // Normalize common shapes
        if (lower === 'bilag_1' || lower === 'bilag1' || lower === '1') {
          return {
            label: 'Bilag 1a (PDF)',
            url: `${API_BASE}/assets/bilag1/bilag-1a-fritliggende-og-sammenbyggede-enfamiliehuse-ver-20-20220103-a.pdf`
          };
        }
        if (lower === 'bilag_11' || lower === 'bilag11' || lower === '11' || lower === '1.1') {
          return {
            label: 'Bilag 1b (PDF)',
            url: `${API_BASE}/assets/bilag11/bilag-1b-ver-2020220218-a.pdf`
          };
        }

        // Try a numeric normalization fallback
        const normalized = normalizeBilagId(raw);
        if (normalized === '1') {
          return {
            label: 'Bilag 1a (PDF)',
            url: `${API_BASE}/assets/bilag1/bilag-1a-fritliggende-og-sammenbyggede-enfamiliehuse-ver-20-20220103-a.pdf`
          };
        }
        if (normalized === '1.1') {
          return {
            label: 'Bilag 1b (PDF)',
            url: `${API_BASE}/assets/bilag11/bilag-1b-ver-2020220218-a.pdf`
          };
        }
        return null;
      }

      // Get inputs and evaluation for this section
      const inputs = sectionsState.inputData?.[sectionIdx] || {};
      const evaluation = sectionsState.evaluations?.[sectionIdx] || {};
      // Note: matched_rule_id is in relevant_bilag, not bilag
      const matchedRuleId = evaluation?.relevant_bilag?.matched_rule_id;
      
      // Get values from evaluation (from previous pages)
      const akValue = evaluation?.anvendelseskategori?.value;
      const rkValue = evaluation?.risikoklasse?.value;
      const bkValue = evaluation?.brandklasse?.value;

      const bilagTitle = getBilagTitleFromEvaluation(evaluation);
      const bilagDisplay = (bilagTitle && bilagTitle.trim() !== '')
        ? bilagTitle
        : formatBilagLabel(bilagValue);
      
      console.log('[Bilag Explanation] Section:', sectionIdx);
      console.log('[Bilag Explanation] Matched Rule ID:', matchedRuleId);
      console.log('[Bilag Explanation] AK:', akValue, 'RK:', rkValue, 'BK:', bkValue);
      
      // Try to get the actual active conditions from the matched rule
      let activeConditions = [];
      if (matchedRuleId && window.BRANDKLASSE_MODEL) {
        try {
          // Try multiple possible node names
          let bilagNode = window.BRANDKLASSE_MODEL.nodes.find(n => n.name === 'Bilag');
          if (!bilagNode) {
            bilagNode = window.BRANDKLASSE_MODEL.nodes.find(n => n.name === 'Relevant bilag');
          }
          if (!bilagNode) {
            // Try to find by checking if node has relevant_bilag in output
            bilagNode = window.BRANDKLASSE_MODEL.nodes.find(n => 
              n.content && n.content.hitPolicy && 
              n.content.outputs && n.content.outputs.some(o => o.field === 'relevant_bilag')
            );
          }
          console.log('[Bilag Explanation] Found Bilag node:', !!bilagNode);
          if (bilagNode) {
            console.log('[Bilag Explanation] Node name:', bilagNode.name);
          }
          
          if (bilagNode) {
            let foundRule = bilagNode.content.rules.find(r => r._id === matchedRuleId);
            
            // If not found directly, try by index
            if (!foundRule && matchedRuleId.includes('_rule_')) {
              const ruleIndex = parseInt(matchedRuleId.split('_rule_')[1]);
              foundRule = bilagNode.content.rules[ruleIndex];
              console.log('[Bilag Explanation] Trying by index:', ruleIndex, 'found:', !!foundRule);
            }
            
            console.log('[Bilag Explanation] Found matched rule:', !!foundRule);
            
            if (foundRule) {
              console.log('[Bilag Explanation] Full matched rule object:', foundRule);
              const inputDefs = bilagNode.content.inputs;
              console.log('[Bilag Explanation] Input definitions count:', inputDefs.length);
              console.log('[Bilag Explanation] All input definitions:', inputDefs);
              
              // Check each input to see if it was used in the rule
              inputDefs.forEach(inp => {
                const conditionValue = foundRule[inp.id];
                const conditionType = typeof conditionValue;
                const isArray = Array.isArray(conditionValue);
                console.log(`[Bilag Explanation] Field: ${inp.field}, ID: ${inp.id}, Condition: ${JSON.stringify(conditionValue)}, Type: ${conditionType}, IsArray: ${isArray}`);
                
                // If condition is not empty/wildcard, it was used
                // Handle arrays (like bygningstype lists) as active conditions
                const isActive = conditionValue !== '' && 
                                conditionValue !== undefined && 
                                conditionValue !== null && 
                                !(isArray && conditionValue.length === 0);
                
                console.log(`[Bilag Explanation] Is active: ${isActive}`);
                
                if (isActive) {
                  const fieldName = inp.field;
                  let inputValue = inputs[fieldName];
                  
                  // Special handling for previous page values
                  if (fieldName === 'anvendelseskategori') {
                    inputValue = akValue;
                  } else if (fieldName === 'risikoklasse') {
                    inputValue = rkValue;
                  } else if (fieldName === 'brandklasse') {
                    inputValue = bkValue;
                  }
                  
                  const displayName = inp.name;
                  
                  activeConditions.push({
                    name: displayName,
                    field: fieldName,
                    condition: conditionValue,
                    value: inputValue
                  });
                  
                  console.log(`[Bilag Explanation] Active:`, { field: fieldName, condition: conditionValue, value: inputValue });
                }
              });
              
              console.log('[Bilag Explanation] Total active conditions:', activeConditions.length);
            }
          }
        } catch (e) {
          console.error('[Bilag Explanation] Error:', e);
        }
      }
      
      // Build bullet list from active conditions
      let conditionsList = [];
      if (activeConditions.length > 0) {
        conditionsList = activeConditions.map(ac => {
          const field = ac.field;
          const value = ac.value;
          const condition = ac.condition;
          
          // Format based on field type
          if (field === 'anvendelseskategori') {
            return `Anvendelseskategori: ${value}`;
          } else if (field === 'risikoklasse') {
            return `Risikoklasse: ${value}`;
          } else if (field === 'brandklasse') {
            return `Brandklasse: ${value}`;
          }
          return formatChecklistItem(field, ac.name, value, condition);
        });
      } else {
        // Fallback
        conditionsList = [];
        if (akValue) conditionsList.push(`Anvendelseskategori: ${akValue}`);
        if (rkValue) conditionsList.push(`Risikoklasse: ${rkValue}`);
        if (bkValue) conditionsList.push(`Brandklasse: ${bkValue}`);
        if (conditionsList.length === 0) conditionsList.push('De indtastede oplysninger');
      }
      
      // Parse bilag value to show which one(s)
      const bilagInfo = {
        '1': 'Dette bilag til Bygningsreglementets vejledning om brand indeholder præ-accepterede løsninger for brandsikring af fritliggende og sammenbyggede enfamiliehuse efter BR18. Følges løsningerne, dokumenteres overholdelse af brandkrav og grundlag for indplacering i brandklasse 1 eller 2. Ved brandklasse 2 skal en certificeret brandrådgiver tilknyttes, og mindre fravigelser kan indarbejdes.',
        '1.1': 'Dette bilag til Bygningsreglementets vejledning om brand indeholder præ-accepterede løsninger for brandsikring af sekundær bebyggelse til enfamiliehuse. Bilaget kan anvendes til at dokumentere overholdelse af BR18’s brandkrav og grundlag for indplacering i brandklasse 1 eller 2. Ved brandklasse 2 skal en certificeret brandrådgiver tilknyttes, og der kan indarbejdes få simple fravigelser.',
        'bilag_1': 'Dette bilag indeholder de relevante krav for dit byggeri.',
        'bilag_11': 'Dette bilag indeholder de relevante krav for dit byggeri.',
        'bilag_1+bilag_11': 'Dette bilag indeholder de relevante krav for dit byggeri.'
      };

      const bilagKey = normalizeBilagId(String(bilagValue ?? '').trim()) || String(bilagValue ?? '').trim();
      const bilagDesc = bilagInfo[bilagKey] || 'Dette bilag indeholder de relevante krav for dit byggeri.';
      
      // Format conditions as bullet list
      const bulletList = conditionsList.map(c => `<li style="margin-bottom: 4px;">${c}</li>`).join('');

      const bilagIdForDownload = normalizeBilagId(getBilagValueFromEvaluation(evaluation)) || String(bilagValue ?? '').trim();
      const downloadInfo = getBilagDownloadInfo(bilagIdForDownload);
      const downloadHtml = downloadInfo ? `
        <div class="download-row">
          <div class="download-label">Download det relevante bilag som PDF:</div>
          <a class="btn-secondary download-link" href="${downloadInfo.url}" target="_blank" rel="noopener" style="text-decoration:none;">
            <span class="download-icon" aria-hidden="true">⬇</span>
            <span>${escapeHtml(downloadInfo.label)}</span>
          </a>
        </div>
      ` : '';
      
      return `
        <div style="margin: 20px 0 16px 0; padding: 0;">
          <p style="margin: 0 0 12px 0; color: #0f172a; line-height: 1.6;">
            <strong>${sectionTitle}</strong> skal følge <strong>${escapeHtml(bilagDisplay)}</strong> baseret på:
          </p>
          <ul style="margin: 0 0 16px 0; padding-left: 24px; color: #475569; line-height: 1.6;">
            ${bulletList}
          </ul>
        </div>
        <div style="margin: 0 0 16px 0;">
          <p style="margin: 0 0 4px 0; font-weight: 600; color: #0f172a;">Om bilaget:</p>
          <p style="margin: 0; color: #475569; line-height: 1.6;">${bilagDesc}</p>
          ${downloadHtml}
        </div>
      `;
    }

    function escapeHtml(str){
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    // Step 2 figures carousel state
    let step2FigureRefs = [];
    let step2FigureIndex = 0;
    let step2CaptionsCache = null;
    let step2FigureTextBlocks = [];
    let step2FigureBindingsReady = false;

    const STEP2_DOC_SECTION3_FIG_LABEL = 'Figurer til brandklasse';
    const STEP2_ATTACH_BTN_LABEL = 'Tilføj til dokumentation';
    const STEP2_REMOVE_BTN_LABEL = 'Tilføjet (klik for at fjerne)';
    const STEP2_ATTACH_TOOLTIP = 'Vælg den/de præ-accepterede løsning(er), du vurderer passer til projektet. Valget bruges i dokumentationsrapporten til at dokumentere, at brandklasse 1 følger de præ-accepterede løsninger (et krav i BR18).';
    const STEP2_ATTACH_TOOLTIP_MAX_W = 280;

    function step2NormalizeRefKey(ref){
      return String(ref || '').trim().toLowerCase();
    }

    function step2GetDocSection3FigureAttachmentEntry(){
      const state = step2EnsureDocOverlayPlaceholderState();
      if (!state) return { state: null, key: '', entry: null };
      const key = step2VedlaegKeyForLabel(STEP2_DOC_SECTION3_FIG_LABEL);
      const raw = state.attachments?.[key];
      const entry = (raw && typeof raw === 'object') ? raw : { files: [] };
      if (!Array.isArray(entry.files)) entry.files = [];
      return { state, key, entry };
    }

    function step2IsRefAlreadyAttachedToDocSection3(ref){
      try {
        const { entry } = step2GetDocSection3FigureAttachmentEntry();
        if (!entry) return false;
        const needle = step2NormalizeRefKey(ref);
        if (!needle) return false;
        return (entry.files || []).some((f) => {
          const a = step2NormalizeRefKey(f?.sourceRef);
          const b = step2NormalizeRefKey(f?.name);
          return (a && a === needle) || (b && b === needle);
        });
      } catch (_) {
        return false;
      }
    }

    function step2NormalizePlaceholderLabel(label){
      return String(label || '')
        .replace(/\s+/g, ' ')
        .replace(/\u00A0/g, ' ')
        .trim();
    }

    function step2VedlaegKeyForLabel(label){
      const l = step2NormalizePlaceholderLabel(label).toLowerCase();
      return `VEDLÆG:${l}`;
    }

    function step2EnsureDocOverlayPlaceholderState(){
      const overlay = document.getElementById('doc-generator-overlay');
      if (!overlay) return null;
      if (!overlay.__docPlaceholderState) {
        overlay.__docPlaceholderState = {
          values: {},
          attachments: {},
          placeholders: null,
          baseDraft: null,
          renderTimer: null,
          applyTimer: null
        };
      }
      if (!overlay.__docPlaceholderState.attachments || typeof overlay.__docPlaceholderState.attachments !== 'object') {
        overlay.__docPlaceholderState.attachments = {};
      }
      return overlay.__docPlaceholderState;
    }

    function step2GuessExtFromUrl(url){
      const u = String(url || '').split('?')[0].split('#')[0];
      const m = u.match(/\.([a-z0-9]+)$/i);
      return m ? String(m[1]).toLowerCase() : '';
    }

    function step2NormalizeBaseName(s){
      let t = String(s || '').trim();
      if (!t) return 'figur';
      t = t.replace(/\.[a-z0-9]+$/i, '');
      t = t.replace(/[^a-z0-9æøå _-]+/gi, ' ').trim();
      t = t.replace(/\s+/g, '_');
      return t || 'figur';
    }

    async function step2BlobToPngFile(blob, baseName, fallbackExt){
      const safeBase = step2NormalizeBaseName(baseName);
      const url = URL.createObjectURL(blob);
      try {
        const img = await new Promise((resolve, reject) => {
          try {
            const im = new Image();
            im.onload = () => resolve(im);
            im.onerror = () => reject(new Error('Billede kunne ikke indlæses'));
            im.src = url;
          } catch (e) { reject(e); }
        });

        const canvas = document.createElement('canvas');
        canvas.width = Math.max(1, img.naturalWidth || img.width || 1);
        canvas.height = Math.max(1, img.naturalHeight || img.height || 1);
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        const outBlob = await new Promise((resolve) => {
          try { canvas.toBlob((b) => resolve(b), 'image/png'); }
          catch(_) { resolve(null); }
        });

        if (outBlob && String(outBlob.type || '').toLowerCase().includes('png')) {
          try {
            return new File([outBlob], `${safeBase}.png`, { type: 'image/png' });
          } catch(_) {
            outBlob.name = `${safeBase}.png`;
            return outBlob;
          }
        }

        // Conversion failed; keep original blob.
        const ext = String(fallbackExt || '').trim().toLowerCase() || (String(blob?.type || '').includes('/') ? String(blob.type).split('/')[1] : 'img');
        const name = `${safeBase}.${ext}`;
        try {
          return new File([blob], name, { type: String(blob?.type || '') });
        } catch(_) {
          blob.name = name;
          return blob;
        }
      } finally {
        try { URL.revokeObjectURL(url); } catch(_) {}
      }
    }

    async function step2AttachCurrentFigureToDocSection3(){
      const img = document.getElementById('step2-fig-img');
      const captionEl = document.getElementById('step2-fig-caption');
      if (!img) return;
      const ref = String(step2FigureRefs?.[step2FigureIndex] ?? '').trim() || 'figur';

      const url = String(img.currentSrc || img.src || '').trim();
      if (!url) throw new Error('Mangler figur-URL');

      const { state, key, entry } = step2GetDocSection3FigureAttachmentEntry();
      if (!state || !entry) {
        alert('Kunne ikke finde dokumentations-oversigten. Prøv at åbne “Opsummering”/dokumentation én gang og prøv igen.');
        return;
      }

      // Do not allow duplicates for the same figure.
      if (step2IsRefAlreadyAttachedToDocSection3(ref)) return;

      // Fetch the image bytes first to avoid tainted-canvas issues, then convert (or keep original).
      let fetchedBlob = null;
      try {
        const resp = await fetch(url, { cache: 'no-store' });
        if (!resp.ok) throw new Error('Kunne ikke hente figuren');
        fetchedBlob = await resp.blob();
      } catch (e) {
        // If fetch fails (often due to CORS), try a direct canvas conversion as a best-effort.
        // This may still fail if the image was loaded cross-origin without CORS headers.
        console.warn('Step2 attach: fetch failed; trying canvas fallback', e);
        try {
          const canvas = document.createElement('canvas');
          canvas.width = Math.max(1, Number(img?.naturalWidth || img?.width || 1));
          canvas.height = Math.max(1, Number(img?.naturalHeight || img?.height || 1));
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0);
          fetchedBlob = await new Promise((resolve) => {
            try { canvas.toBlob((b)=> resolve(b), 'image/png'); }
            catch(_) { resolve(null); }
          });
        } catch (_) {
          fetchedBlob = null;
        }
      }

      if (!fetchedBlob) throw new Error('Kunne ikke konvertere billedet til PNG');

      const ext = step2GuessExtFromUrl(url);
      const file = await step2BlobToPngFile(fetchedBlob, ref, ext);
      const cap = String(captionEl?.textContent || '').trim();
      entry.files.push({
        file,
        name: String(ref || 'figur'),
        sourceRef: String(ref || '').trim(),
        sourceUrl: url,
        type: String(file?.type || ''),
        caption: cap,
        description: ''
      });
      state.attachments[key] = entry;

      // If the overlay placeholder UI is open later, it will pick this up from state.
    }

    function step2RemoveFigureFromDocSection3ByRef(ref){
      try {
        const needle = step2NormalizeRefKey(ref);
        if (!needle) return false;
        const { state, key, entry } = step2GetDocSection3FigureAttachmentEntry();
        if (!state || !entry) return false;
        const before = Array.isArray(entry.files) ? entry.files.length : 0;
        entry.files = (entry.files || []).filter((f) => {
          const a = step2NormalizeRefKey(f?.sourceRef);
          const b = step2NormalizeRefKey(f?.name);
          return !((a && a === needle) || (b && b === needle));
        });
        state.attachments[key] = entry;
        return (before !== (entry.files || []).length);
      } catch (_) {
        return false;
      }
    }

    const clamp = (n, min, max) => Math.min(max, Math.max(min, n));

    function ensureStep2FigureBindings(){
      if (step2FigureBindingsReady) return;
      step2FigureBindingsReady = true;

      const btnPrev = document.getElementById('step2-fig-prev');
      const btnNext = document.getElementById('step2-fig-next');
      const btnAttach = document.getElementById('step2-fig-attach');
      if (btnPrev) btnPrev.addEventListener('click', () => setStep2FigureIndex(step2FigureIndex - 1));
      if (btnNext) btnNext.addEventListener('click', () => setStep2FigureIndex(step2FigureIndex + 1));
      if (btnAttach) btnAttach.addEventListener('click', async () => {
        if (btnAttach.disabled) return;
        const prev = btnAttach.textContent;
        btnAttach.disabled = true;
        const ref = String(step2FigureRefs?.[step2FigureIndex] ?? '').trim() || 'figur';
        const already = ref ? step2IsRefAlreadyAttachedToDocSection3(ref) : false;
        btnAttach.textContent = already ? 'Fjerner…' : 'Tilføjer…';
        try {
          if (already) {
            step2RemoveFigureFromDocSection3ByRef(ref);
          } else {
            await step2AttachCurrentFigureToDocSection3();
          }
        } catch (e) {
          console.error(e);
          alert('Kunne ikke tilføje figuren. Tjek Console (F12) for fejl.');
          btnAttach.textContent = prev;
        } finally {
          try { await renderStep2Figure(); } catch(_) {}
        }
      });
    }

    function setStep2FigureIndex(nextIndex){
      if (!Array.isArray(step2FigureRefs) || step2FigureRefs.length === 0) return;
      step2FigureIndex = clamp(nextIndex, 0, step2FigureRefs.length - 1);
      try { renderStep2Figure(); } catch(_) {}
    }

    async function loadStep2Captions(){
      if (step2CaptionsCache !== null) return step2CaptionsCache;
      const getFigureDirs = ()=>{
        const out = [];
        try {
          const b = normalizeBilagId(getCurrentBilagId());
          const digits = b ? String(b).replace(/\D/g, '') : '';
          if (digits) out.push(`${API_BASE}/assets/bilag${digits}/figures`);
        } catch(_) {}
        out.push(`${API_BASE}/assets/figures`);
        return out;
      };

      for (const baseDir of getFigureDirs()) {
        try {
          const capResp = await fetch(`${baseDir}/captions.json`, { cache: 'no-store' });
          if (capResp.ok) {
            const capJson = await capResp.json();
            if (capJson && typeof capJson === 'object') {
              step2CaptionsCache = capJson;
              return step2CaptionsCache;
            }
          }
        } catch (_) {}
      }
      step2CaptionsCache = {};
      return step2CaptionsCache;
    }

    async function renderStep2Figure(){
      ensureStep2FigureBindings();
      const carousel = document.getElementById('step2-figure-carousel');
      const img = document.getElementById('step2-fig-img');
      const refEl = document.getElementById('step2-fig-ref');
      const countEl = document.getElementById('step2-fig-count');
      const captionEl = document.getElementById('step2-fig-caption');
      const missingEl = document.getElementById('step2-fig-missing');
      const btnPrev = document.getElementById('step2-fig-prev');
      const btnNext = document.getElementById('step2-fig-next');
      const btnAttach = document.getElementById('step2-fig-attach');

      if (!carousel || !img || !refEl || !countEl || !captionEl || !missingEl) return;
      if (!Array.isArray(step2FigureRefs) || step2FigureRefs.length === 0) {
        carousel.style.display = 'none';
        if (btnAttach) btnAttach.style.display = 'none';
        return;
      }

      const getFigureDirs = ()=>{
        const out = [];
        try {
          const b = normalizeBilagId(getCurrentBilagId());
          const digits = b ? String(b).replace(/\D/g, '') : '';
          if (digits) out.push(`${API_BASE}/assets/bilag${digits}/figures`);
        } catch(_) {}
        out.push(`${API_BASE}/assets/figures`);
        return out;
      };
      const figureDirs = getFigureDirs();
      const mkSrc = (baseDir, ref, ext) => `${baseDir}/${encodeURIComponent(ref)}${ext}`;

      step2FigureIndex = clamp(step2FigureIndex, 0, step2FigureRefs.length - 1);
      const ref = String(step2FigureRefs[step2FigureIndex] ?? '').trim();
      carousel.style.display = '';
      refEl.textContent = ref || '-';
      countEl.textContent = step2FigureRefs.length > 1 ? `(${step2FigureIndex + 1}/${step2FigureRefs.length})` : '';
      if (btnPrev) btnPrev.disabled = step2FigureIndex <= 0;
      if (btnNext) btnNext.disabled = step2FigureIndex >= step2FigureRefs.length - 1;

      // Captions
      const captions = await loadStep2Captions();
      const lookupKey = ref.replace(/\.(png|jpg|jpeg|svg|webp)$/i, '');
      const humanCaption = (captions && (captions[lookupKey] ?? captions[ref])) ? String(captions[lookupKey] ?? captions[ref]) : '';
      const figureText = (Array.isArray(step2FigureTextBlocks) && step2FigureTextBlocks[step2FigureIndex] !== undefined)
        ? String(step2FigureTextBlocks[step2FigureIndex] ?? '').trim()
        : '';
      const preferredCaption = figureText || (humanCaption ? String(humanCaption).trim() : '');
      if (preferredCaption) {
        captionEl.style.display = '';
        captionEl.textContent = preferredCaption;
      } else {
        captionEl.style.display = 'none';
        captionEl.textContent = '';
      }

      // Image loading (try common extensions if ref has none)
      missingEl.style.display = 'none';
      missingEl.textContent = '';
      img.alt = ref;
      // Attempt to load with CORS enabled so canvas conversion can work when server sends CORS headers.
      try { img.crossOrigin = 'anonymous'; } catch(_) {}

      const hasExt = /\.(png|jpg|jpeg|svg|webp)$/i.test(ref);
      const baseRef = hasExt ? ref.replace(/\.(png|jpg|jpeg|svg|webp)$/i, '') : ref;
      const tryExts = hasExt ? [''] : ['.png', '.jpg', '.jpeg', '.svg', '.webp'];
      let dirIndex = 0;
      let tryIndex = 0;

      const setTrySrc = () => {
        const ext = tryExts[tryIndex];
        const baseDir = figureDirs[Math.min(dirIndex, figureDirs.length - 1)];
        img.src = hasExt ? `${baseDir}/${encodeURIComponent(ref)}` : mkSrc(baseDir, baseRef, ext);
      };

      img.onerror = () => {
        tryIndex++;
        if (tryIndex < tryExts.length) {
          setTrySrc();
          return;
        }
        // Next base dir
        dirIndex++;
        if (dirIndex < figureDirs.length) {
          tryIndex = 0;
          setTrySrc();
          return;
        }
        const attempted = hasExt
          ? figureDirs.map(d => `${d}/${encodeURIComponent(ref)}`)
          : figureDirs.flatMap(d => tryExts.map(ext => mkSrc(d, baseRef, ext)));
        missingEl.textContent = `Kunne ikke finde billedfil for "${ref}".\nForsøgt:\n- ${attempted.join('\n- ')}`;
        missingEl.style.display = '';
      };

      if (btnAttach) {
        const enabled = !!ref;
        const already = enabled ? step2IsRefAlreadyAttachedToDocSection3(ref) : false;
        btnAttach.style.display = enabled ? '' : 'none';
        btnAttach.disabled = !enabled;
        btnAttach.textContent = already ? STEP2_REMOVE_BTN_LABEL : STEP2_ATTACH_BTN_LABEL;
        // Use the global red custom tooltip system (same as info-icons), but keep it narrower.
        btnAttach.setAttribute('data-tip', STEP2_ATTACH_TOOLTIP);
        btnAttach.setAttribute('data-tip-maxwidth', String(STEP2_ATTACH_TOOLTIP_MAX_W));
        btnAttach.classList.add('tip-target');
        btnAttach.removeAttribute('title');
      }

      setTrySrc();
    }
    // Multi-building + multi-section state
    function createEmptySectionsState(){
      return {
        count: 1,
        titles: [],
        inputs: {},
        inputData: {},  // Store complete input data for each section (for explanations)
        bilagExtras: {},
        evaluations: {},
        progress: {},
        lastStep: {},
        kravChecks: {},
        kravExcluded: {},
        kravNotes: {},
        kravResults: {},
        // Step 3: canonical order for requirement categories (matches Krav page ordering)
        // Shape: { [sectionIdx]: Array<string> }
        kravCategoryOrder: {},
        // Step 3: documentation uploads per requirement category (JSON-export safe)
        // Shape: { [sectionIdx]: { [categoryLabel]: Array<{ id, name, type, size, lastModified, caption, description }> } }
        kravCategoryDocs: {}
      };
    }

    function sortCategoryLabelsByOrder(labels, order){
      const list = Array.isArray(labels) ? labels.slice() : [];
      const orderArr = Array.isArray(order) ? order : [];
      const idx = new Map();
      for (let i = 0; i < orderArr.length; i++) {
        const k = String(orderArr[i] ?? '').trim();
        if (!k || idx.has(k)) continue;
        idx.set(k, i);
      }

      list.sort((a, b) => {
        const aa = String(a ?? '').trim();
        const bb = String(b ?? '').trim();
        const ia = idx.has(aa) ? idx.get(aa) : Infinity;
        const ib = idx.has(bb) ? idx.get(bb) : Infinity;
        if (ia !== ib) return ia - ib;
        return aa.localeCompare(bb, 'da');
      });
      return list;
    }

    function ensureKravCategoryDocsForSection(sectionIdx){
      if (!sectionsState.kravCategoryDocs || typeof sectionsState.kravCategoryDocs !== 'object') {
        sectionsState.kravCategoryDocs = {};
      }
      const k = String(sectionIdx);
      if (!sectionsState.kravCategoryDocs[k] || typeof sectionsState.kravCategoryDocs[k] !== 'object') {
        sectionsState.kravCategoryDocs[k] = {};
      }
      return sectionsState.kravCategoryDocs[k];
    }

    function getKravCategoryDocs(sectionIdx, categoryLabel){
      const perSection = ensureKravCategoryDocsForSection(sectionIdx);
      const key = String(categoryLabel || '').trim();
      if (!key) return [];
      if (!Array.isArray(perSection[key])) perSection[key] = [];
      return perSection[key];
    }

    function getKravDocFileStore(){
      try {
        if (!window.__kravDocFileStore || typeof window.__kravDocFileStore !== 'object') {
          window.__kravDocFileStore = {};
        }
        return window.__kravDocFileStore;
      } catch(_) {
        return {};
      }
    }

    function getKravDocFileById(docId){
      if (!docId) return null;
      const store = getKravDocFileStore();
      return store[String(docId)] || null;
    }

    function addKravCategoryDocsFromFiles(sectionIdx, categoryLabel, files){
      const key = String(categoryLabel || '').trim();
      if (!key) return;
      const list = getKravCategoryDocs(sectionIdx, key);
      const arr = Array.from(files || []).filter(Boolean);
      if (arr.length === 0) return;

      const mkId = () => {
        try { return (crypto && crypto.randomUUID) ? crypto.randomUUID() : null; } catch(_) { return null; }
      };

      const store = getKravDocFileStore();
      for (const f of arr) {
        const id = mkId() || `doc_${Date.now()}_${Math.random().toString(16).slice(2)}`;
        try { store[String(id)] = f; } catch(_) {}
        list.push({
          id,
          name: String(f.name || 'fil'),
          type: String(f.type || ''),
          size: Number.isFinite(Number(f.size)) ? Number(f.size) : null,
          lastModified: Number.isFinite(Number(f.lastModified)) ? Number(f.lastModified) : null,
          caption: '',
          description: '',
          // Step 3: which checklist items this bilag documents.
          // Values are checklist-keys (same format as sectionsState.kravChecks keys).
          coversChecklistKeys: []
        });
      }
    }

    function updateKravCategoryDocField(sectionIdx, categoryLabel, docId, field, value){
      const key = String(categoryLabel || '').trim();
      if (!key || !docId) return;
      const list = getKravCategoryDocs(sectionIdx, key);
      const entry = list.find(x => String(x?.id) === String(docId));
      if (!entry) return;
      if (field === 'caption') entry.caption = String(value ?? '');
      if (field === 'description') entry.description = String(value ?? '');
      if (field === 'uiCollapsed') entry.uiCollapsed = Boolean(value);
    }

    function setKravCategoryDocCoverageKeys(sectionIdx, categoryLabel, docId, keys){
      const key = String(categoryLabel || '').trim();
      if (!key || !docId) return;
      const list = getKravCategoryDocs(sectionIdx, key);
      const entry = list.find(x => String(x?.id) === String(docId));
      if (!entry) return;
      const arr = Array.isArray(keys) ? keys : [];
      const out = [];
      const seen = new Set();
      for (const k of arr) {
        const kk = String(k || '').trim();
        if (!kk) continue;
        if (seen.has(kk)) continue;
        seen.add(kk);
        out.push(kk);
      }
      entry.coversChecklistKeys = out;
    }

    function removeKravCategoryDoc(sectionIdx, categoryLabel, docId){
      const key = String(categoryLabel || '').trim();
      if (!key || !docId) return;
      const list = getKravCategoryDocs(sectionIdx, key);
      const idx = list.findIndex(x => String(x?.id) === String(docId));
      if (idx >= 0) list.splice(idx, 1);
      try {
        const store = getKravDocFileStore();
        delete store[String(docId)];
      } catch(_) {}
    }

    // ---- PDF helpers (for embedding bilag as images) ----
    async function ensurePdfJsLoaded(){
      if (window.pdfjsLib) return window.pdfjsLib;

      const existing = document.querySelector('script[data-pdfjs="true"]');
      if (!existing) {
        await new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.dataset.pdfjs = 'true';
          // CDN is simplest for a single-file frontend. If you prefer vendoring, we can.
          s.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.js';
          s.onload = resolve;
          s.onerror = reject;
          document.head.appendChild(s);
        });
      } else {
        await new Promise((resolve, reject) => {
          if (window.pdfjsLib) return resolve();
          existing.addEventListener('load', resolve, { once: true });
          existing.addEventListener('error', reject, { once: true });
        });
      }

      const lib = window.pdfjsLib;
      if (!lib) throw new Error('Kunne ikke indlæse PDF.js');
      try {
        lib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.js';
      } catch(_) {}
      return lib;
    }

    async function pdfFileToPngFile(pdfFile, opts){
      const options = opts || {};
      const pageNumber = Number.isFinite(Number(options.pageNumber)) ? Number(options.pageNumber) : 1;
      const scale = Number.isFinite(Number(options.scale)) ? Number(options.scale) : 2;

      const lib = await ensurePdfJsLoaded();
      const data = await pdfFile.arrayBuffer();
      const loadingTask = lib.getDocument({ data });
      const pdf = await loadingTask.promise;
      const page = await pdf.getPage(pageNumber);
      const viewport = page.getViewport({ scale });

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = Math.ceil(viewport.width);
      canvas.height = Math.ceil(viewport.height);
      await page.render({ canvasContext: ctx, viewport }).promise;

      const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png', 0.95));
      if (!blob) throw new Error('PDF -> PNG konvertering fejlede');
      const baseName = String(pdfFile.name || 'bilag.pdf').replace(/\.pdf$/i, '');
      return new File([blob], `${baseName}.png`, { type: 'image/png' });
    }

    const buildingsState = {
      count: 1,
      titles: [],
      buildings: {},
      lastActiveSection: {}
    };

    // This variable always points at the active building's sections state.
    // Many parts of the UI assume a single "sectionsState"; this keeps changes localized.
    let sectionsState = createEmptySectionsState();
    buildingsState.buildings[0] = sectionsState;

    function getActiveSectionIndex(){
      const el = document.body.getAttribute('data-active-section');
      return el ? parseInt(el) : 0;
    }

    function getActiveBuildingIndex(){
      const el = document.body.getAttribute('data-active-building');
      return el ? parseInt(el) : 0;
    }

    function setActiveBuildingIndex(idx){
      const prevB = getActiveBuildingIndex();
      const prevS = getActiveSectionIndex();
      if (prevB !== idx) {
        // Capture current section and remember last active section for this building.
        try { captureInputsToSection(prevS); } catch(_) {}
        buildingsState.lastActiveSection[prevB] = prevS;
      }

      // Ensure building exists
      if (!buildingsState.buildings[idx]) {
        buildingsState.buildings[idx] = createEmptySectionsState();
      }

      document.body.setAttribute('data-active-building', String(idx));
      sectionsState = buildingsState.buildings[idx];

      // Re-render tabs and restore last active section for the building.
      try { renderBuildingTabs(); } catch(_) {}
      const targetSection = buildingsState.lastActiveSection[idx] ?? 0;
      setActiveSectionIndex(Math.max(0, Math.min(targetSection, (sectionsState.count || 1) - 1)));
      updateCurrentSectionNameDisplay();
    }
    function setActiveSectionIndex(idx){
      // CRITICAL: Capture current section data BEFORE switching
      const prevIdx = getActiveSectionIndex();
      if (prevIdx !== idx) {
        try { captureInputsToSection(prevIdx); } catch(_) {}
      }
      
      document.body.setAttribute('data-active-section', String(idx));
      renderSectionTabs();
      updateCurrentSectionNameDisplay();
      // Restore inputs for this section
      hydrateInputsFromSection(idx);
      // Preload any existing evaluation for smooth rendering
      const existing = sectionsState.evaluations[idx];
      latestEvaluation = existing || null;
      // Navigate to this section's last visited step (default 1)
      const targetStep = sectionsState.lastStep[idx] || 1;
      goToStep(targetStep);

      // If we already have data for this section, render it immediately.
      // Otherwise the UI can look like only the "currently open" section was saved.
      if (targetStep === 3) {
        const eval3 = existing || sectionsState.evaluations[idx];
        if (eval3) {
          latestEvaluation = eval3;
          try { Promise.resolve(updateStep3Display()).catch(()=>{}); } catch(_) {}
        }
      }
      // If we landed on step 2 without an evaluation yet, compute now
      if (targetStep === 2 && !existing) {
        try { scheduleBrandklasseEvaluate({ immediate: true }); } catch(_) {}
      }
    }

    function renderBuildingTabs(){
      const tabs = document.getElementById('building-tabs');
      if (!tabs) return;
      const active = getActiveBuildingIndex();
      tabs.innerHTML = '';

      for (let i = 0; i < buildingsState.count; i++){
        const title = buildingsState.titles[i] || `Bygning ${i+1}`;
        const b = buildingsState.buildings[i];
        const total = Math.max(1, Number(b?.count ?? 1) || 1);
        const completed = Object.values(b?.progress || {}).filter(p => p?.evaluated && p?.requirementsViewed).length;
        const done = (completed === total && total > 0);

        const btn = document.createElement('button');
        btn.className = i === active ? 'btn-primary' : 'btn-secondary';
        btn.style.padding = '6px 12px';
        btn.style.position = 'relative';
        btn.style.display = 'flex';
        btn.style.alignItems = 'center';
        btn.style.gap = '8px';

        const titleSpan = document.createElement('span');
        titleSpan.textContent = title + (done ? ' ✓' : '');
        btn.appendChild(titleSpan);

        // Remove button (×) - only show if more than 1 building
        if (buildingsState.count > 1) {
          const removeBtn = document.createElement('span');
          removeBtn.innerHTML = '×';
          removeBtn.title = 'Fjern bygning';
          removeBtn.style.cssText = 'font-size: 18px; font-weight: bold; cursor: pointer; opacity: 0.7; margin-left: 4px;';
          removeBtn.addEventListener('mouseenter', () => { removeBtn.style.opacity = '1'; });
          removeBtn.addEventListener('mouseleave', () => { removeBtn.style.opacity = '0.7'; });
          removeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            showConfirmDialog(
              'Fjern bygning?',
              `Er du sikker på at du vil fjerne "${title}"? Alle bygningsafsnit og data for denne bygning vil blive slettet.`,
              () => removeBuilding(i)
            );
          });
          btn.appendChild(removeBtn);
        }

        btn.addEventListener('click', ()=> setActiveBuildingIndex(i));

        // Rename (same mini-popup UX)
        btn.addEventListener('dblclick', (e)=>{
          e.preventDefault();
          e.stopPropagation();
          if (i !== active) return;
          openRenamePopup(i, title, e, 'building');
        });
        btn.addEventListener('contextmenu', (e)=>{
          e.preventDefault();
          openRenamePopup(i, title, e, 'building');
        });

        tabs.appendChild(btn);
      }

      const addBtn = document.createElement('button');
      addBtn.className = 'btn-secondary';
      addBtn.innerHTML = '+ Tilføj bygning';
      addBtn.style.padding = '6px 12px';
      addBtn.style.fontWeight = '600';
      addBtn.addEventListener('click', () => addBuilding());
      tabs.appendChild(addBtn);
    }

    function addBuilding(){
      // Capture current section before adding
      try { captureInputsToSection(getActiveSectionIndex()); } catch(_) {}

      const newIndex = buildingsState.count;
      buildingsState.count++;
      buildingsState.titles[newIndex] = `Bygning ${buildingsState.count}`;
      buildingsState.buildings[newIndex] = createEmptySectionsState();
      buildingsState.lastActiveSection[newIndex] = 0;
      renderBuildingTabs();
      updateCurrentSectionNameDisplay();
    }

    function removeBuilding(indexToRemove){
      if (buildingsState.count <= 1) {
        alert('Du skal have mindst én bygning.');
        return;
      }

      const activeB = getActiveBuildingIndex();
      const activeS = getActiveSectionIndex();
      try { captureInputsToSection(activeS); } catch(_) {}

      buildingsState.count--;

      for (let i = indexToRemove; i < buildingsState.count; i++) {
        buildingsState.titles[i] = buildingsState.titles[i + 1];
        buildingsState.buildings[i] = buildingsState.buildings[i + 1];
        buildingsState.lastActiveSection[i] = buildingsState.lastActiveSection[i + 1];
      }

      delete buildingsState.titles[buildingsState.count];
      delete buildingsState.buildings[buildingsState.count];
      delete buildingsState.lastActiveSection[buildingsState.count];

      // Fix active building index after removal
      let nextActive = activeB;
      if (activeB >= buildingsState.count) nextActive = Math.max(0, buildingsState.count - 1);
      else if (activeB >= indexToRemove) nextActive = Math.max(0, activeB - 1);

      setActiveBuildingIndex(nextActive);
      renderBuildingTabs();
    }

    function renderSectionTabs(){
      const tabs = document.getElementById('section-tabs');
      if (!tabs) return;
      const active = getActiveSectionIndex();
      tabs.innerHTML = '';

      // Keep building-level badges in sync
      try { renderBuildingTabs(); } catch(_) {}
      for (let i=0;i<sectionsState.count;i++){
        const title = sectionsState.titles[i] || `Bygningsafsnit ${i+1}`;
        const prog = sectionsState.progress[i] || { evaluated:false, requirementsViewed:false };
        const done = prog.evaluated && prog.requirementsViewed;
        const btn = document.createElement('button');
        btn.className = i===active ? 'btn-primary' : 'btn-secondary';
        btn.style.padding = '6px 12px';
        btn.style.position = 'relative';
        btn.style.display = 'flex';
        btn.style.alignItems = 'center';
        btn.style.gap = '8px';
        
        const titleSpan = document.createElement('span');
        titleSpan.textContent = title + (done ? ' ✓' : '');
        btn.appendChild(titleSpan);
        
        // Remove button (×) - only show if more than 1 section
        if (sectionsState.count > 1) {
          const removeBtn = document.createElement('span');
          removeBtn.innerHTML = '×';
          removeBtn.title = 'Fjern bygningsafsnit';
          removeBtn.style.cssText = 'font-size: 18px; font-weight: bold; cursor: pointer; opacity: 0.7; margin-left: 4px;';
          removeBtn.addEventListener('mouseenter', () => { removeBtn.style.opacity = '1'; });
          removeBtn.addEventListener('mouseleave', () => { removeBtn.style.opacity = '0.7'; });
          removeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            showConfirmDialog(
              'Fjern bygningsafsnit?',
              `Er du sikker på at du vil fjerne "${title}"? Alle data for dette afsnit vil blive slettet.`,
              () => removeBuildingSection(i)
            );
          });
          btn.appendChild(removeBtn);
        }
        
        // Single click: switch immediately (no delay)
        btn.addEventListener('click', ()=> setActiveSectionIndex(i));
        
        // Double click: rename via the SAME mini-popup UI as right-click.
        // To avoid losing the dblclick due to re-render: only allow dblclick rename on the ACTIVE tab.
        btn.addEventListener('dblclick', (e)=>{
          e.preventDefault();
          e.stopPropagation();
          if (i !== active) return;
          openRenamePopup(i, title, e);
        });
        // Right-click fallback: prompt-based rename
        btn.addEventListener('contextmenu', (e)=>{
          e.preventDefault();
          openRenamePopup(i, title, e);
        });
        tabs.appendChild(btn);
      }
      
      // Add (+) button to create new section
      const addBtn = document.createElement('button');
      addBtn.className = 'btn-secondary';
      addBtn.innerHTML = '+ Tilføj bygningsafsnit';
      addBtn.style.padding = '6px 12px';
      addBtn.style.fontWeight = '600';
      addBtn.addEventListener('click', () => {
        addBuildingSection();
      });
      tabs.appendChild(addBtn);
      
      // Removed right-side inline editor; rename via double-click / hover pencil / right-click
    }
    
    // Update the current section name display at the top
    function updateCurrentSectionNameDisplay() {
      const nameEl = document.getElementById('current-section-name');
      if (nameEl) {
        const bIdx = getActiveBuildingIndex();
        const sIdx = getActiveSectionIndex();
        const buildingLabel = `Bygning ${bIdx+1}`;
        const buildingTitleRaw = String(buildingsState.titles[bIdx] || '').trim();
        const sectionTitle = String(sectionsState.titles[sIdx] || `Bygningsafsnit ${sIdx+1}`).trim();

        const isDefaultBuildingTitle = (!buildingTitleRaw || buildingTitleRaw.toLowerCase() === buildingLabel.toLowerCase());

        // Prefer an explicit building title if the user renamed the building.
        // Otherwise fall back to the active section title (so the header becomes e.g. "Bygning 1 - Villa").
        const buildingName = isDefaultBuildingTitle ? '' : buildingTitleRaw;
        const derivedBuildingName = buildingName || (sectionTitle && sectionTitle !== `Bygningsafsnit ${sIdx+1}` ? sectionTitle : '');

        // Avoid "Bygning 1 - Villa - Villa" if we derived the building name from the section title.
        if (derivedBuildingName && sectionTitle && derivedBuildingName.toLowerCase() === sectionTitle.toLowerCase()) {
          nameEl.textContent = `${buildingLabel} - ${derivedBuildingName}`;
        } else if (derivedBuildingName) {
          nameEl.textContent = `${buildingLabel} - ${derivedBuildingName} - ${sectionTitle}`;
        } else {
          nameEl.textContent = `${buildingLabel} - ${sectionTitle}`;
        }
      }
    }
    
    function addBuildingSection() {
      // CRITICAL: Capture current section data BEFORE switching
      const currentIdx = getActiveSectionIndex();
      captureInputsToSection(currentIdx);
      
      const newIndex = sectionsState.count;
      sectionsState.count++;
      sectionsState.titles[newIndex] = `Bygningsafsnit ${sectionsState.count}`;
      sectionsState.inputs[newIndex] = null;
      sectionsState.evaluations[newIndex] = null;
      sectionsState.progress[newIndex] = { evaluated: false, requirementsViewed: false };
      sectionsState.lastStep[newIndex] = 1;
      renderSectionTabs();

      // Do NOT auto-switch; keep user on current section.
      // The new section stays blank until the user clicks its tab.
      updateCurrentSectionNameDisplay();

      // Keep derived/global keys (like antal_BA) in sync immediately.
      // Without this, the right-side JSON (and evaluation payload) may still show the previous count
      // until the user changes a form field.
      try { scheduleEvaluate(); } catch(_) {}
    }
    
    function removeBuildingSection(indexToRemove) {
      if (sectionsState.count <= 1) {
        alert('Du skal have mindst ét bygningsafsnit.');
        return;
      }
      
      // Remove data for this index
      sectionsState.count--;
      
      // Shift all data after this index down by one
      for (let i = indexToRemove; i < sectionsState.count; i++) {
        sectionsState.titles[i] = sectionsState.titles[i + 1];
        sectionsState.inputs[i] = sectionsState.inputs[i + 1];
        sectionsState.evaluations[i] = sectionsState.evaluations[i + 1];
        sectionsState.progress[i] = sectionsState.progress[i + 1];
        sectionsState.lastStep[i] = sectionsState.lastStep[i + 1];
        if (sectionsState.bilagExtras) sectionsState.bilagExtras[i] = sectionsState.bilagExtras[i + 1];
        if (sectionsState.kravChecks) sectionsState.kravChecks[i] = sectionsState.kravChecks[i + 1];
        if (sectionsState.kravExcluded) sectionsState.kravExcluded[i] = sectionsState.kravExcluded[i + 1];
        if (sectionsState.kravNotes) sectionsState.kravNotes[i] = sectionsState.kravNotes[i + 1];
        if (sectionsState.kravResults) sectionsState.kravResults[i] = sectionsState.kravResults[i + 1];
        if (sectionsState.inputData) sectionsState.inputData[i] = sectionsState.inputData[i + 1];

        // Object-keyed state (string keys)
        if (sectionsState.kravCategoryDocs && typeof sectionsState.kravCategoryDocs === 'object') {
          sectionsState.kravCategoryDocs[String(i)] = sectionsState.kravCategoryDocs[String(i + 1)];
        }
        if (sectionsState.kravCategoryOrder && typeof sectionsState.kravCategoryOrder === 'object') {
          sectionsState.kravCategoryOrder[String(i)] = sectionsState.kravCategoryOrder[String(i + 1)];
        }
      }
      
      // Clean up last index
      delete sectionsState.titles[sectionsState.count];
      delete sectionsState.inputs[sectionsState.count];
      delete sectionsState.evaluations[sectionsState.count];
      delete sectionsState.progress[sectionsState.count];
      delete sectionsState.lastStep[sectionsState.count];
      if (sectionsState.bilagExtras) delete sectionsState.bilagExtras[sectionsState.count];
      if (sectionsState.kravChecks) delete sectionsState.kravChecks[sectionsState.count];
      if (sectionsState.kravExcluded) delete sectionsState.kravExcluded[sectionsState.count];
      if (sectionsState.kravNotes) delete sectionsState.kravNotes[sectionsState.count];
      if (sectionsState.kravResults) delete sectionsState.kravResults[sectionsState.count];
      if (sectionsState.inputData) delete sectionsState.inputData[sectionsState.count];

      if (sectionsState.kravCategoryDocs && typeof sectionsState.kravCategoryDocs === 'object') {
        delete sectionsState.kravCategoryDocs[String(sectionsState.count)];
      }
      if (sectionsState.kravCategoryOrder && typeof sectionsState.kravCategoryOrder === 'object') {
        delete sectionsState.kravCategoryOrder[String(sectionsState.count)];
      }
      
      // If we removed the active section, switch to the previous one (or 0)
      const currentActive = getActiveSectionIndex();
      if (currentActive >= sectionsState.count) {
        setActiveSectionIndex(Math.max(0, sectionsState.count - 1));
      } else if (currentActive >= indexToRemove) {
        // Stay on same logical section (which has shifted down in index)
        setActiveSectionIndex(currentActive);
      } else {
        // We're before the removed section, no change needed
        renderSectionTabs();

        // Active section didn't change, but section count did.
        // Refresh JSON/evaluation so antal_BA reflects the new count.
        try { scheduleEvaluate(); } catch(_) {}
      }
    }
    
    // Show confirmation dialog
    function showConfirmDialog(title, message, onConfirm, onCancel, options) {
      const opts = options && typeof options === 'object' ? options : {};
      const confirmText = typeof opts.confirmText === 'string' ? opts.confirmText : 'Fjern';
      const cancelText = typeof opts.cancelText === 'string' ? opts.cancelText : 'Annuller';

      const overlay = document.createElement('div');
      overlay.className = 'confirm-overlay';

      const modal = document.createElement('div');
      modal.className = 'confirm-modal';
      modal.setAttribute('role', 'dialog');
      modal.setAttribute('aria-modal', 'true');

      const header = document.createElement('div');
      header.className = 'confirm-header';
      header.textContent = title;

      const msg = document.createElement('div');
      msg.className = 'confirm-message';
      msg.textContent = message;

      const actions = document.createElement('div');
      actions.className = 'confirm-actions';

      let closed = false;
      const handleEscape = (e) => {
        if (e.key === 'Escape') close(false);
      };

      function close(confirmed) {
        if (closed) return;
        closed = true;
        try {
          if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
        } catch (_) {}
        document.removeEventListener('keydown', handleEscape);

        if (confirmed) {
          if (onConfirm) onConfirm();
        } else {
          if (onCancel) onCancel();
        }
      }

      const cancelBtn = document.createElement('button');
      cancelBtn.className = 'confirm-btn-cancel';
      cancelBtn.textContent = cancelText;
      cancelBtn.addEventListener('click', () => close(false));

      const confirmBtn = document.createElement('button');
      confirmBtn.className = 'confirm-btn-confirm';
      confirmBtn.textContent = confirmText;
      confirmBtn.addEventListener('click', () => close(true));

      actions.appendChild(cancelBtn);
      actions.appendChild(confirmBtn);

      modal.appendChild(header);
      modal.appendChild(msg);
      modal.appendChild(actions);

      overlay.appendChild(modal);
      document.body.appendChild(overlay);

      // Close on overlay click
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) close(false);
      });

      // Close on Escape key
      document.addEventListener('keydown', handleEscape);
    }

    function showProceedToKravPopup() {
      const msg = 'Inden vi går videre til kravene, bedes du dobbelttjekke, at dit design samt værktøjets valg af brandklasse og bilag stemmer overens med de relevante præ-accepterede løsninger, som nu vises.';
      return new Promise((resolve) => {
        showConfirmDialog(
          'Dobbelttjek før krav',
          msg,
          () => resolve(true),
          () => resolve(false),
          { confirmText: 'OK, fortsæt', cancelText: 'Luk' }
        );
      });
    }

    function openRenamePopup(index, currentTitle, evt, kind){
      const targetKind = (kind === 'building') ? 'building' : 'section';
      // Remove existing popup
      document.querySelectorAll('.mini-popup').forEach(p => p.remove());
      const pop = document.createElement('div');
      pop.className = 'mini-popup';
      const input = document.createElement('input');
      input.type = 'text';
      input.value = currentTitle;
      const actions = document.createElement('div');
      actions.className = 'actions';
      const btnOk = document.createElement('button'); btnOk.className='btn-primary'; btnOk.textContent='Gem'; btnOk.style.padding='6px 10px';
      const btnCancel = document.createElement('button'); btnCancel.className='btn-secondary'; btnCancel.textContent='Annullér'; btnCancel.style.padding='6px 10px';
      actions.appendChild(btnOk); actions.appendChild(btnCancel);
      pop.appendChild(input); pop.appendChild(actions);
      document.body.appendChild(pop);
      const x = evt.clientX, y = evt.clientY;
      const pad = 8;
      // Temporarily place, then measure to position ABOVE the click and centered
      pop.style.left = x + 'px';
      pop.style.top = y + 'px';
      // After next frame, compute size and adjust
      requestAnimationFrame(()=>{
        const rect = pop.getBoundingClientRect();
        const left = Math.max(8, x - rect.width/2);
        const top = Math.max(8, y - rect.height - pad);
        pop.style.left = left + 'px';
        pop.style.top = top + 'px';
      });
      input.focus(); input.select();
      const commit = ()=>{
        const v = input.value.trim();
        if (targetKind === 'building') {
          buildingsState.titles[index] = v;
          renderBuildingTabs();
        } else {
          sectionsState.titles[index] = v;
          renderSectionTabs();
        }
        updateCurrentSectionNameDisplay();
        pop.remove();
      };
      btnOk.addEventListener('click', commit);
      btnCancel.addEventListener('click', ()=> pop.remove());
      input.addEventListener('keydown', (e)=>{ if(e.key==='Enter') commit(); if(e.key==='Escape') pop.remove(); });
      // Close on outside click
      const onDocClick = (e)=>{ if(!pop.contains(e.target)) { pop.remove(); document.removeEventListener('click', onDocClick); } };
      setTimeout(()=> document.addEventListener('click', onDocClick), 0);
    }
    function captureInputsToSection(idx){
      sectionsState.inputs[idx] = canonicalizeInputData(buildJsonFromForm());
      // Also ensure bilagExtras are captured for this section
      const tilbygEl = document.getElementById('fld_med_tilbygning');
      const erhvEl = document.getElementById('fld_med_erhvervssammenbygning');
      if (!sectionsState.bilagExtras) sectionsState.bilagExtras = {};
      if (!sectionsState.bilagExtras[idx]) sectionsState.bilagExtras[idx] = {};
      if (tilbygEl && tilbygEl.value !== '') {
        sectionsState.bilagExtras[idx].med_tilbygning = (tilbygEl.value === 'true');
      }
      if (erhvEl && erhvEl.value !== '') {
        sectionsState.bilagExtras[idx].med_erhvervssammenbygning = (erhvEl.value === 'true');
      }
    }
    function hydrateInputsFromSection(idx){
      const obj = sectionsState.inputs[idx];
      // Always clear first, then apply section data.
      // This prevents any values from the previous section from "sticking" when the next section is blank/partial.
      clearFormInputs();
      if (!obj) return;
      try { updateFormFromJson(obj); } catch(_) {}
      
      // Restore bilag extras for this section
      const bilagExtras = sectionsState.bilagExtras?.[idx];
      if (bilagExtras) {
        const tilbygEl = document.getElementById('fld_med_tilbygning');
        const erhvEl = document.getElementById('fld_med_erhvervssammenbygning');
        if (tilbygEl && bilagExtras.med_tilbygning !== undefined) {
          tilbygEl.value = String(bilagExtras.med_tilbygning);
        }
        if (erhvEl && bilagExtras.med_erhvervssammenbygning !== undefined) {
          erhvEl.value = String(bilagExtras.med_erhvervssammenbygning);
        }
      }
      
      // Trigger status/eval refresh without overwriting manual JSON
      scheduleEvaluate();
      // Re-initialize custom selects after hydration
      setTimeout(() => {
        if (typeof initCustomSelects === 'function') initCustomSelects();
      }, 50);
    }
    
    // Clear all form inputs to default/empty state
    function clearFormInputs(){
      // Text/number inputs - NO DEFAULT VALUES, make everything blank
      document.querySelectorAll('input[type="number"]').forEach(input => {
        if (input.id === 'section-count') {
          // Don't clear section count - it's global
        } else {
          input.value = '';
        }
      });
      document.querySelectorAll('input[type="text"]').forEach(input => input.value = '');
      
      // Selects - ALWAYS set to first empty/disabled option or -1
      document.querySelectorAll('select').forEach(select => {
        // Look for first option that is disabled, has empty value, or says "Vælg"
        let emptyOptionIndex = -1;
        for (let i = 0; i < select.options.length; i++) {
          const opt = select.options[i];
          if (opt.disabled || opt.value === '' || opt.textContent.includes('Vælg')) {
            emptyOptionIndex = i;
            break;
          }
        }
        if (emptyOptionIndex >= 0) {
          select.selectedIndex = emptyOptionIndex;
        } else {
          // Force clear by setting selectedIndex to -1 (no selection)
          select.selectedIndex = -1;
        }
        // Force update the select display
        select.value = '';
      });
      
      // Clear bilag extras selects explicitly
      const tilbygEl = document.getElementById('fld_med_tilbygning');
      const erhvEl = document.getElementById('fld_med_erhvervssammenbygning');
      if (tilbygEl) tilbygEl.value = '';
      if (erhvEl) erhvEl.value = '';
      
      // Update JSON textarea
      const jsonTextarea = document.getElementById('json-input');
      if (jsonTextarea) jsonTextarea.value = '{}';
      
      // Re-initialize custom selects
      setTimeout(() => {
        if (typeof initCustomSelects === 'function') initCustomSelects();
      }, 50);
      
      // Update status display
      updateStatus();
    }

    // Wizard navigation
    function goToStep(stepNumber) {
      currentStep = stepNumber;
      
      // Hide all steps
      document.getElementById('wizard-step-1').style.display = 'none';
      document.getElementById('wizard-step-2').style.display = 'none';
      const s3 = document.getElementById('wizard-step-3'); if (s3) s3.style.display = 'none';
      const s4 = document.getElementById('wizard-step-4'); if (s4) s4.style.display = 'none';
      
      // Show current step
      document.getElementById(`wizard-step-${stepNumber}`).style.display = 'flex';
      
      // Re-initialize custom selects after content visibility changes
      setTimeout(() => {
        if (typeof initCustomSelects === 'function') initCustomSelects();
      }, 50);
      
      // Update step indicators
      document.getElementById('step-indicator-1').classList.remove('active', 'completed');
      document.getElementById('step-indicator-2').classList.remove('active', 'completed');
      const i3 = document.getElementById('step-indicator-3'); if (i3) i3.classList.remove('active', 'completed');
      const i4 = document.getElementById('step-indicator-4'); if (i4) i4.classList.remove('active', 'completed');
      
      if (stepNumber === 1) {
        document.getElementById('step-indicator-1').classList.add('active');
        // IMPORTANT: Step 1 result cards (AK/RK/Bilag/BK) must reflect the active section.
        // Switching building/section hydrates inputs but does not fire input events, so we
        // re-render (or clear) the results explicitly to avoid stale values.
        try {
          const idx = getActiveSectionIndex();
          const existing = sectionsState?.evaluations?.[idx];
          latestEvaluation = existing || null;

          if (existing) {
            try { displayResults(existing); } catch(_) {}
          } else {
            try {
              // Reset matched rule IDs
              if (typeof currentMatchedRules === 'object' && currentMatchedRules) {
                currentMatchedRules.anvendelseskategori = null;
                currentMatchedRules.risikoklasse = null;
                currentMatchedRules.relevant_bilag = null;
                currentMatchedRules.brandklasse = null;
              }
            } catch(_) {}

            try { setResultRowValue('anvendelse', '-', ''); } catch(_) {}
            try { setResultRowStatus('anvendelse', false); } catch(_) {}
            try { setResultRowValue('risiko', '-', ''); } catch(_) {}
            try { setResultRowStatus('risiko', false); } catch(_) {}
            try { setResultRowValue('bilag', '-', ''); } catch(_) {}
            try { setResultRowStatus('bilag', false); } catch(_) {}

            const headline = document.getElementById('headline-results');
            if (headline) headline.textContent = 'Resultater';
            const banner = document.getElementById('eval-error-banner');
            if (banner) banner.remove();

            try { updateResultValidationStatus(); } catch(_) {}
          }
        } catch(_) {}

        try { updateStep1BrandklasseCard(); } catch(_) {}
      } else if (stepNumber === 2) {
        document.getElementById('step-indicator-1').classList.add('completed');
        document.getElementById('step-indicator-2').classList.add('active');
        // Update step 2 displays
        updateStep2Display();
      } else if (stepNumber === 3) {
        document.getElementById('step-indicator-1').classList.add('completed');
        document.getElementById('step-indicator-2').classList.add('completed');
        const i3b = document.getElementById('step-indicator-3'); if (i3b) i3b.classList.add('active');
        updateStep3Display();
      } else if (stepNumber === 4) {
        document.getElementById('step-indicator-1').classList.add('completed');
        document.getElementById('step-indicator-2').classList.add('completed');
        const i3c = document.getElementById('step-indicator-3'); if (i3c) i3c.classList.add('completed');
        const i4b = document.getElementById('step-indicator-4'); if (i4b) i4b.classList.add('active');
        renderFinalOverview();
      }
      // Remember last visited step per section
      const activeIdx = getActiveSectionIndex();
      sectionsState.lastStep[activeIdx] = stepNumber;
    }

    // Allow clicking the top step indicators to navigate directly.
    function initWizardStepIndicatorNavigation(){
      const steps = [1,2,3,4];
      steps.forEach((n)=>{
        const el = document.getElementById(`step-indicator-${n}`);
        if (!el) return;

        el.setAttribute('role', 'button');
        el.setAttribute('tabindex', '0');
        el.setAttribute('aria-label', `Gå til trin ${n}`);

        const navigate = async (evt)=>{
          try { evt?.preventDefault?.(); } catch(_) {}
          try { evt?.stopPropagation?.(); } catch(_) {}

          // Capture current section inputs before leaving the page.
          try { captureInputsToSection(getActiveSectionIndex()); } catch(_) {}

          // Keep latestEvaluation in sync with the active section, if present.
          try {
            const idx = getActiveSectionIndex();
            const existing = sectionsState?.evaluations?.[idx];
            if (existing) latestEvaluation = existing;
          } catch(_) {}

          // Convenience: if user jumps to Step 2 from Step 1 and BK isn't computed yet, compute once.
          try {
            const idx = getActiveSectionIndex();
            if (n === 2 && currentStep === 1 && !sectionsState?.evaluations?.[idx]) {
              await evaluateBrandklasseNow();
            }
          } catch(_) {}

          goToStep(n);
        };

        el.addEventListener('click', navigate);
        el.addEventListener('keydown', (e)=>{
          if (e.key === 'Enter' || e.key === ' ') navigate(e);
        });
      });
    }

    try { initWizardStepIndicatorNavigation(); } catch(_) {}

    let brandklasseTimer = null;
    function setStep2Status(text){
      const el = document.getElementById('step2-bk-status');
      if (!el) return;
      el.textContent = text;
      const t = (text === null || text === undefined) ? '' : String(text);
      const isInstruction = /tjek\s+om\s+dine\s+valg\s+stemmer\s+med\s+de\s+figurer/i.test(t);
      el.classList.toggle('step2-status--instruction', isInstruction);
    }
    function showStep2InlineBrandklasse(show){
      const el = document.getElementById('step2-bk-inline');
      if (!el) return;
      el.style.display = show ? '' : 'none';
    }
    function scheduleBrandklasseEvaluate({ immediate = false } = {}){
      if (brandklasseTimer) clearTimeout(brandklasseTimer);
      const run = ()=>{
        // Brandklasse must be computed from Step 1 only. Step 2 is view-only.
        if (currentStep !== 1) return;
        evaluateBrandklasseNow();
      };
      if (immediate) return run();
      brandklasseTimer = setTimeout(run, 250);
    }

    // --- Result-driven field highlights (Step 1) ---
    let lastOptimizationHighlightKeys = new Set();
    // NOTE: These are the *requirements we actually display* on the right.
    // Each item is either a string (legacy) or an object like: { field, question }.
    let latestDisplayedHighlightQuestionsBase = [];

    function normalizeHintText(v){
      const s = (v === null || v === undefined) ? '' : String(v);
      return s
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
    }

    function getStep1FieldRows(){
      const root = document.getElementById('step1-field-list');
      if (!root) return [];
      return Array.from(root.querySelectorAll('.form-field'));
    }

    function getStep1FieldRowByControlId(controlId){
      if (!controlId) return null;
      const el = document.getElementById(controlId);
      if (!el) return null;
      return el.closest('.form-field');
    }

    function mapFieldKeyToControlId(fieldKey){
      const f = (fieldKey === null || fieldKey === undefined) ? '' : String(fieldKey).trim();
      if (!f) return null;
      const id = `fld_${f}`;
      return document.getElementById(id) ? id : null;
    }

    function clearOptimizationHighlights(){
      getStep1FieldRows().forEach(row => {
        row.classList.remove('opt-highlight');
        row.classList.remove('opt-highlight-opt');
        row.classList.remove('opt-pulse');
      });
      lastOptimizationHighlightKeys = new Set();
    }

    function applyHighlightsFromDisplayedQuestions(questions){
      // Supports:
      // - { field: 'antal_personer_BA', question?: '...', kind?: 'missing'|'opt' }: stable ID mapping
      const rawItems = Array.isArray(questions) ? questions : [];
      const seen = new Set();
      const uniq = [];
      rawItems.forEach((item)=>{
        if (item === null || item === undefined) return;
        if (typeof item === 'object') {
          const field = (item.field === null || item.field === undefined) ? '' : String(item.field).trim();
          const question = (item.question === null || item.question === undefined) ? '' : String(item.question).trim();
          const kind = (item.kind === 'opt' || item.kind === 'missing') ? item.kind : null;
          const k = field ? `f:${field}` : '';
          if (!k || seen.has(k)) return;
          seen.add(k);
          uniq.push({ field: field || null, question: question || null, kind });
        }
      });

      const rows = getStep1FieldRows();
      rows.forEach(r => { r.classList.remove('opt-highlight'); r.classList.remove('opt-highlight-opt'); r.classList.remove('opt-pulse'); });

      if (!uniq.length) {
        lastOptimizationHighlightKeys = new Set();
        return;
      }

      // Track pulses per control id (stable)
      const matchedKeys = new Set();
      const matchedRows = new Set();
      const rowKinds = new Map();

      const controlHasValue = (controlId)=>{
        if (!controlId) return false;
        const el = document.getElementById(controlId);
        if (!el) return false;
        // Select
        if (el.tagName && el.tagName.toLowerCase() === 'select') {
          return String(el.value ?? '').trim() !== '';
        }
        // Input
        if (el.tagName && el.tagName.toLowerCase() === 'input') {
          const t = (el.getAttribute('type') || '').toLowerCase();
          if (t === 'checkbox' || t === 'radio') return el.checked === true;
          return String(el.value ?? '').trim() !== '';
        }
        // Fallback
        return String(el.value ?? '').trim() !== '';
      };

      uniq.forEach(item => {
        if (!item || typeof item !== 'object' || !item.field) return;
        const mappedId = mapFieldKeyToControlId(item.field);
        if (!mappedId) return;
        const row = getStep1FieldRowByControlId(mappedId);
        if (!row) return;

        matchedRows.add(row);
        matchedKeys.add(mappedId);

        // Apply green only when this is an optimization-change AND the control already has a value.
        const wantsOpt = (item.kind === 'opt');
        const isFilled = controlHasValue(mappedId);
        if (wantsOpt && isFilled) rowKinds.set(row, 'opt');
      });

      matchedRows.forEach(row => {
        row.classList.add('opt-highlight');
        if (rowKinds.get(row) === 'opt') row.classList.add('opt-highlight-opt');
        const key = (()=>{
          try {
            const el = row.querySelector('input,select,textarea');
            return el?.id ? String(el.id) : null;
          } catch(_) {
            return null;
          }
        })();
        if (key && !lastOptimizationHighlightKeys.has(key)) {
          row.classList.add('opt-pulse');
          setTimeout(()=>{ row.classList.remove('opt-pulse'); }, 750);
        }
      });

      lastOptimizationHighlightKeys = matchedKeys;
    }

    function updateStep1BrandklasseCard(){
      // Keep Brandklasse quiet on initial page load.
      try {
        const idx = getActiveSectionIndex();
        const evaluated = !!(sectionsState?.progress?.[idx]?.evaluated);
        if (!evaluated) {
          const elVal0 = document.getElementById('result-brand');
          const elDesc0 = document.getElementById('result-brand-desc');
          if (elVal0) elVal0.textContent = '-';
          if (elDesc0) elDesc0.textContent = '';
          try { applyHighlightsFromDisplayedQuestions(latestDisplayedHighlightQuestionsBase); } catch(_) {}
          return;
        }
      } catch(_) {}

      const bkValue = latestEvaluation?.brandklasse?.value;
      const kravOut = latestEvaluation?.bilag_outputs?.krav ?? latestEvaluation?.bilag_outputs?.Krav;
      const kravText = Array.isArray(kravOut) ? kravOut.join('; ') : (kravOut ?? '');
      const hasBk = (bkValue !== null && bkValue !== undefined);

      const displayVal = hasBk ? String(bkValue) : '-';

      const elVal = document.getElementById('result-brand');
      const elDesc = document.getElementById('result-brand-desc');
      if (elVal) elVal.textContent = hasBk ? displayVal : '-';
      if (elDesc) {
        if (hasBk) {
          const opt = latestEvaluation?.suggestions?.brandklasse;
          if (Array.isArray(opt) && opt.length) {
            const bkQuestions = [];
            const parseRankNumber = (v) => {
              if (v === null || v === undefined) return null;
              const n = Number.parseInt(String(v).trim(), 10);
              return Number.isFinite(n) ? n : null;
            };

            const optSorted = opt
              .filter(s => s && s.target_value !== null && s.target_value !== undefined)
              .slice()
              .sort((a, b) => {
                const an = parseRankNumber(a?.target_value);
                const bn = parseRankNumber(b?.target_value);
                if (an === null && bn === null) return String(a?.target_value).localeCompare(String(b?.target_value));
                if (an === null) return 1;
                if (bn === null) return -1;
                return an - bn;
              })
              .slice(0, 4);

            const rowsHtml = optSorted.map((s)=>{
              const target = s?.target_value;
              const rankNum = parseRankNumber(target);
              const itemRankCls = (rankNum && rankNum >= 1 && rankNum <= 4) ? `rank-${rankNum}` : '';
              const targetStr = escapeHtml(String(target));

              const parts = [];

              const missing = Array.isArray(s?.missing_questions) ? s.missing_questions : [];
              if (missing.length) {
                const missTxt = missing.slice(0, 4).map(x => escapeHtml(String(x))).join(', ');
                parts.push(`Udfyld: ${missTxt}`);
              }
              // Prefer stable fields for highlighting.
              const mf = Array.isArray(s?.missing_fields) ? s.missing_fields : [];
              if (mf.length) mf.forEach(f => bkQuestions.push({ field: f, kind: 'missing' }));

              const req = Array.isArray(s?.required_fields) ? s.required_fields : [];
              const reqTxt = req
                .map(r => {
                  const q = r?.question;
                  const exp = r?.expected_value;
                  if (!q) return '';
                  if (exp === null || exp === undefined || String(exp).trim() === '') return escapeHtml(String(q));
                  return `${escapeHtml(String(q))} = ${escapeHtml(String(exp))}`;
                })
                .filter(Boolean);
              if (reqTxt.length) parts.push(`Sæt: ${reqTxt.slice(0, 3).join('; ')}`);
              req.forEach(r => {
                if (r?.field) bkQuestions.push({ field: r.field, question: r?.question || null, kind: 'opt' });
              });

              const nums = Array.isArray(s?.numeric_adjustments) ? s.numeric_adjustments : [];
              const numsTxt = nums
                .map(a => {
                  const q = a?.question;
                  const exp = a?.expected;
                  const d = a?.delta_abs;
                  if (!q || !exp) return '';
                  const deltaTxt = (d !== null && d !== undefined && Number.isFinite(Number(d)))
                    ? ` (afvigelse: ${escapeHtml(String(Number(d).toFixed(0)))})`
                    : '';
                  return `${escapeHtml(String(q))} ${escapeHtml(String(exp))}${deltaTxt}`;
                })
                .filter(Boolean);
              if (numsTxt.length) parts.push(`Justér: ${numsTxt.slice(0, 3).join('; ')}`);
              nums.forEach(a => {
                if (a?.field) bkQuestions.push({ field: a.field, question: a?.question || null, kind: 'opt' });
              });

              const detail = parts.length ? parts.join(' | ') : '';
              const rankName = `BK${targetStr}`;
              const suffix = detail ? `: ${detail}` : '';

              return (
                `<div class="opt-help-item ${itemRankCls}">` +
                  `<div class="opt-help-text"><span class="opt-rank-name">${rankName}</span>${suffix}</div>` +
                '</div>'
              );
            }).join('');

            elDesc.innerHTML = `<div class="opt-help"><div class="opt-help-title">Optimering:</div><div class="opt-help-list">${rowsHtml}</div></div>`;

            // Only highlight when BK is actually showing requirements (not "Afventer").
            try { applyHighlightsFromDisplayedQuestions([...latestDisplayedHighlightQuestionsBase, ...bkQuestions]); } catch(_) {}
          } else {
            elDesc.textContent = '';
            try { applyHighlightsFromDisplayedQuestions(latestDisplayedHighlightQuestionsBase); } catch(_) {}
          }
        } else {
          const cand = latestEvaluation?.candidates?.brandklasse;
          if (Array.isArray(cand) && cand.length) {
            const values = Array.from(new Set(cand.map(c => c?.value).filter(v => v !== null && v !== undefined).map(v => String(v))));
            const missingQs = Array.from(new Set(
              cand.flatMap(c => Array.isArray(c?.missing_questions) ? c.missing_questions : [])
                .map(v => String(v ?? '').trim())
                .filter(Boolean)
            )).slice(0, 4);
            const missingFields = Array.from(new Set(
              cand.flatMap(c => Array.isArray(c?.missing_fields) ? c.missing_fields : [])
                .map(v => String(v ?? '').trim())
                .filter(Boolean)
            )).slice(0, 6);
            const lines = [];
            if (values.length) lines.push(`Kan blive: ${values.slice(0, 6).map(v => `BK${v}`).join(' eller ')}`);
            if (missingQs.length) {
              lines.push('For at afgøre:');
              missingQs.forEach(q => lines.push(`• ${q}`));
            }
            elDesc.textContent = lines.join('\n');

            // Highlight by stable fields when available.
            const hl = missingFields.length ? missingFields.map(f => ({ field: f, kind: 'missing' })) : [];
            try { applyHighlightsFromDisplayedQuestions([...latestDisplayedHighlightQuestionsBase, ...hl]); } catch(_) {}
          } else {
            const waiting = [];
            const akMissing = (latestEvaluation?.anvendelseskategori?.value === null || latestEvaluation?.anvendelseskategori?.value === undefined || String(latestEvaluation?.anvendelseskategori?.value ?? '').trim() === '');
            const rkMissing = (latestEvaluation?.risikoklasse?.value === null || latestEvaluation?.risikoklasse?.value === undefined || String(latestEvaluation?.risikoklasse?.value ?? '').trim() === '');
            const bilagMissing = (()=>{
              const v = latestEvaluation?.relevant_bilag?.value ?? latestEvaluation?.relevant_bilag ?? latestEvaluation?.bilag;
              return (v === null || v === undefined || String(v).trim() === '');
            })();
            if (akMissing) waiting.push('Anvendelseskategori');
            if (rkMissing) waiting.push('Risikoklasse');
            if (bilagMissing) waiting.push('Relevant bilag');
            // If prerequisites are complete but BK isn't (yet), avoid leaving the box empty.
            // (Often BK is coming from the /evaluate-complete call or awaits totalareal.)
            if (waiting.length) {
              elDesc.textContent = `Afventer: ${waiting.join(', ')}`;
              // If BK is waiting, do not highlight BK requirements.
              try { applyHighlightsFromDisplayedQuestions(latestDisplayedHighlightQuestionsBase); } catch(_) {}
            } else {
              // Prereqs are known; show what BK still needs (field-based) instead of just "Beregner".
              // If we haven't called /evaluate-complete yet, we may not have missing_inputs/candidates.
              // In that case, fall back to known BK prerequisite(s) like totalareal.
              try {
                const areaTotalNum = asNum('fld_area_total');
                const hasAreaTotalNum = (areaTotalNum !== null);
                if (!hasAreaTotalNum) {
                  elDesc.textContent = 'For at beregne:\n• Total bygningsareal (hele bygningen) [m²]';
                  try { applyHighlightsFromDisplayedQuestions([...latestDisplayedHighlightQuestionsBase, { field: 'area_total', kind: 'missing' }]); } catch(_) {}
                  return;
                }
              } catch(_) {}

              const mi = Array.isArray(latestEvaluation?.missing_inputs) ? latestEvaluation.missing_inputs : [];
              const bkMi = mi
                .filter(x => {
                  const n = String(x?.node_name ?? x?.node ?? '').toLowerCase();
                  return n.includes('brand');
                })
                .sort((a, b) => Number(b?.score ?? 0) - Number(a?.score ?? 0));

              const bkMiQuestions = Array.from(new Set(bkMi.map(x => x?.question).filter(Boolean))).slice(0, 6);
              const bkMiFields = Array.from(new Set(bkMi.map(x => x?.field).filter(Boolean))).slice(0, 8);

              if (bkMiQuestions.length || bkMiFields.length) {
                const lines = [];
                lines.push('For at beregne:');
                if (bkMiQuestions.length) bkMiQuestions.forEach(q => lines.push(`• ${q}`));
                else bkMiFields.forEach(f => lines.push(`• ${f}`));
                elDesc.textContent = lines.join('\n');
                const hl = bkMiFields.map(f => ({ field: f, kind: 'missing' }));
                try { applyHighlightsFromDisplayedQuestions([...latestDisplayedHighlightQuestionsBase, ...hl]); } catch(_) {}
              } else {
                elDesc.textContent = 'Beregner…';
                try { applyHighlightsFromDisplayedQuestions(latestDisplayedHighlightQuestionsBase); } catch(_) {}
              }
            }
          }
        }
      }

      try { setResultRowStatus('brand', hasBk); } catch(_) {}
      
      // Update brandklasse matched_rule_id for validation
      currentMatchedRules.brandklasse = latestEvaluation?.brandklasse?.matched_rule_id || null;
      console.log('[Brandklasse] updateStep1BrandklasseCard - matched_rule_id:', currentMatchedRules.brandklasse);
      console.log('[Brandklasse] latestEvaluation.brandklasse:', latestEvaluation?.brandklasse);
      // Update validation badge for brandklasse specifically
      updateResultValidationStatus();

      // Highlights are applied above based on what BK is currently showing.
    }

    async function evaluateBrandklasseNow(){
      // Compute brandklasse from Step 1 only. Step 2 is display-only.
      if (currentStep !== 1) return;

      const areaTotal = asNum('fld_area_total');
      const hasAreaTotal = (areaTotal !== null);

      const idx = getActiveSectionIndex();

      setStep2Status(hasAreaTotal ? 'Beregner brandklasse…' : 'Beregner forslag (brandklasse kræver totalareal)…');
      try {
        const data = { ...canonicalizeInputData(buildJsonFromForm()), ...getActiveBilagExtras() };
        const response = await fetch(`${API_BASE}/evaluate-complete`, {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify(data)
        });
        if (!response.ok) throw new Error('BK API request failed');
        const result = await response.json();
        
        // Store brandklasse matched rule ID
        console.log('[Brandklasse] evaluateBrandklasseNow - result.brandklasse:', result?.brandklasse);
        if (result?.brandklasse?.matched_rule_id) {
          currentMatchedRules.brandklasse = result.brandklasse.matched_rule_id;
          console.log('[Brandklasse] Stored matched_rule_id:', currentMatchedRules.brandklasse);
        } else {
          console.warn('[Brandklasse] No matched_rule_id in result!');
        }
        
        // Merge brandklasse outputs into existing evaluation to avoid wiping AK/RK/Bilag.
        const previous = sectionsState.evaluations[idx] ?? latestEvaluation ?? {};
        const merged = { ...previous, ...result };
        if (!('anvendelseskategori' in result) && previous.anvendelseskategori !== undefined) merged.anvendelseskategori = previous.anvendelseskategori;
        if (!('risikoklasse' in result) && previous.risikoklasse !== undefined) merged.risikoklasse = previous.risikoklasse;
        if (!('relevant_bilag' in result) && previous.relevant_bilag !== undefined) merged.relevant_bilag = previous.relevant_bilag;
        if (!('bilag' in result) && previous.bilag !== undefined) merged.bilag = previous.bilag;
        latestEvaluation = merged;
        // Persist per section
        sectionsState.evaluations[idx] = merged;
        // Store input data for explanations
        sectionsState.inputData[idx] = data;
        sectionsState.progress[idx] = { ...(sectionsState.progress[idx]||{}), evaluated:true };
        renderSectionTabs();
        // Update UI
        await updateStep2Display();
        try { updateStep1BrandklasseCard(); } catch(_) {}
        
        // Update validation badges for brandklasse
        updateResultValidationStatus();
        const bkValue = result?.brandklasse?.value;
        const hasBk = (bkValue !== null && bkValue !== undefined);
        if (!hasAreaTotal) {
          setStep2Status('Indtast det totale bygningsareal på side 1 for endelig brandklasse. Forslag vises i resultater.');
        } else {
          setStep2Status(hasBk ? 'Tjek om dine valg stemmer med de figurer der er refereret her' : 'Kunne ikke beregne brandklasse endnu.');
        }
      } catch (e) {
        showStep2InlineBrandklasse(false);
        setStep2Status('Kunne ikke beregne brandklasse/forslag. Tjek input og at backend kører.');
        try { updateStep1BrandklasseCard(); } catch(_) {}
      }
    }
    
    async function updateStep2Display() {
      // Step 2: Brandklasse + outputs
      const bkValue = latestEvaluation?.brandklasse?.value;
      const bkDesc = (latestEvaluation?.brandklasse?.description ?? '').trim();
      const kravOut = latestEvaluation?.bilag_outputs?.krav ?? latestEvaluation?.bilag_outputs?.Krav;
      const kravText = Array.isArray(kravOut) ? kravOut.join('; ') : (kravOut ?? '');
      const hasBk = (bkValue !== null && bkValue !== undefined);

      const bkDisplayValue = hasBk ? String(bkValue) : '-';

      // Inline brandklasse feedback (center card)
      const inlineVal = document.getElementById('step2-bk-inline-value');
      const inlineDesc = document.getElementById('step2-bk-inline-desc');
      if (inlineVal) inlineVal.textContent = bkDisplayValue;
      const showDesc = hasBk;
      // Avoid redundancy like "1" + "Brandklasse 1".
      const descLooksRedundant = (bkValue !== null && bkValue !== undefined) && /^brandklasse\s*\d+\s*$/i.test(bkDesc);
      if (inlineDesc) inlineDesc.textContent = (showDesc && !descLooksRedundant) ? bkDesc : '';
      showStep2InlineBrandklasse(hasBk);

      // Enable continue when brandklasse exists
      const btnContinue = document.getElementById('btn-continue-step2');
      if (btnContinue) btnContinue.disabled = !hasBk;

      // Render additional outputs
      const outputs = latestEvaluation?.bilag_outputs || {};
      const outputsWrap = document.getElementById('step2-outputs');
      if (outputsWrap) outputsWrap.style.display = hasBk ? '' : 'none';

      const formatBool = (v) => {
        if (v === true || v === 'true' || v === 1 || v === '1') return 'Ja';
        if (v === false || v === 'false' || v === 0 || v === '0') return 'Nej';
        if (v === null || v === undefined || String(v).trim() === '') return '-';
        return String(v);
      };
      const setText = (id, value) => {
        const el = document.getElementById(id);
        if (el) el.textContent = value;
      };

      const prae = outputs['Prae-accepteret_Godkendt'] ?? outputs['præ-accepteret_godkendt'] ?? outputs['Prae-accepteret_godkendt'];
      const raadKrav = outputs['brandrådgiver_krav'] ?? outputs['brandradgiver_krav'];
      const raadCert = outputs['brandrådgiver_certificeringsniveau'] ?? outputs['brandradgiver_certificeringsniveau'];
      const krav = outputs['Krav'] ?? outputs['krav'];
      const pickVigtig = () => {
        const explicit = [
          outputs['Vigtig_information'],
          outputs['vigtig_information'],
          outputs['Vigtig information'],
          outputs['vigtig information'],
          outputs['important_information'],
          outputs['Important_information'],
          outputs['Important information'],
          outputs['important information'],
        ];
        for (const v of explicit) {
          if (v !== undefined && v !== null && String(v).trim() !== '') return v;
        }
        // Fallback: look for any output key that suggests important info.
        const keys = Object.keys(outputs);
        const candidates = keys.filter(k => /vigtig|important/i.test(k));
        for (const k of candidates) {
          const v = outputs[k];
          if (v !== undefined && v !== null && String(v).trim() !== '') return v;
        }
        return undefined;
      };
      const vigtig = pickVigtig();

      const pickFigurTekst = () => {
        const explicit = [
          outputs['figur_tekst'],
          outputs['Figur_tekst'],
          outputs['Figurtekst'],
          outputs['figurtekst'],
          outputs['Figur tekst'],
          outputs['figur tekst'],
          outputs['figure_text'],
          outputs['Figure_text'],
          outputs['Figure text'],
          outputs['figure text'],
        ];
        for (const v of explicit) {
          if (v !== undefined && v !== null && (Array.isArray(v) || String(v).trim() !== '')) return v;
        }
        const keys = Object.keys(outputs);
        const candidates = keys.filter(k => /(figur|figure).*(tekst|text)|(tekst|text).*(figur|figure)/i.test(k));
        for (const k of candidates) {
          const v = outputs[k];
          if (v !== undefined && v !== null && (Array.isArray(v) || String(v).trim() !== '')) return v;
        }
        return undefined;
      };

      const parseFigureTextBlocks = (v) => {
        if (v === null || v === undefined) return [];

        const normalizeText = (raw) => {
          let s = String(raw ?? '');
          // Normalize linebreaks and handle the common “double-escaped” form where the text
          // contains literal backslash-n sequences (e.g. "...\\n\\n...").
          s = s.replace(/\r\n/g, '\n');
          s = s.replace(/\\n/g, '\n');
          s = s.replace(/\\t/g, '\t');

          // Some decision-table cells were saved with an extra pair of quotes.
          // Example value starts with '"På Figur ...' and ends with '..."'.
          s = s.trim();
          if (s.length >= 2 && s.startsWith('"') && s.endsWith('"')) {
            s = s.slice(1, -1).trim();
          }
          return s;
        };

        if (Array.isArray(v)) {
          const arr = v.map(x => normalizeText(x).trim());
          while (arr.length && arr[0] === '') arr.shift();
          while (arr.length && arr[arr.length - 1] === '') arr.pop();
          return arr;
        }
        const s = normalizeText(v);
        const blocks = s.split(/\n\s*\n+/g).map(b => String(b).trim());
        while (blocks.length && blocks[0] === '') blocks.shift();
        while (blocks.length && blocks[blocks.length - 1] === '') blocks.pop();
        return blocks;
      };
      const figurTekstRaw = pickFigurTekst();
      const pickFigurRef = () => {
        const explicit = [
          ['figur_reference', outputs['figur_reference']],
          ['Figurer', outputs['Figurer']],
          ['figurReference', outputs['figurReference']],
          ['figur-referencer', outputs['figur-referencer']],
          ['Figur_reference', outputs['Figur_reference']],
          ['figurreferencer', outputs['figurreferencer']],
        ];
        for (const [k, v] of explicit) {
          if (v !== undefined && v !== null && String(v).trim() !== '') return { key: k, value: v };
        }

        // Fallback: look for any output key that suggests figures.
        const keys = Object.keys(outputs);
        const figureKeys = keys.filter(k => /figur|figure/i.test(k));
        for (const k of figureKeys) {
          const v = outputs[k];
          if (v !== undefined && v !== null && String(v).trim() !== '') return { key: k, value: v };
        }

        // As a last attempt, some backends might return this at top-level.
        const topLevel = latestEvaluation?.figur_reference ?? latestEvaluation?.figurReference;
        if (topLevel !== undefined && topLevel !== null && String(topLevel).trim() !== '') return { key: 'latestEvaluation.*', value: topLevel };
        return { key: '', value: undefined };
      };
      const { key: figurKey, value: figurRef } = pickFigurRef();

      setText('step2-out-prae', formatBool(prae));
      setText('step2-out-brandraadgiver', formatBool(raadKrav));
      setText('step2-out-cert', (raadCert === null || raadCert === undefined || String(raadCert).trim() === '') ? '-' : String(raadCert));
      setText('step2-out-krav', (krav === null || krav === undefined || String(krav).trim() === '') ? '-' : (Array.isArray(krav) ? krav.join('; ') : String(krav)));

      const importantCard = document.getElementById('step2-out-important');
      const importantText = document.getElementById('step2-out-important-text');
      // IMPORTANT: Use only Vigtig_information (bilag_outputs). Do not fall back to bilagsinformation.
      const viktigTextRaw = vigtig;
      const vigtigText = (viktigTextRaw === null || viktigTextRaw === undefined) ? '' : String(viktigTextRaw).trim();
      // Show important info in the figures header (instead of the static "Figur-reference" title)
      const figTitleEl = document.getElementById('step2-fig-title');
      const figSubtitleEl = document.getElementById('step2-fig-subtitle');
      if (figTitleEl) {
        if (vigtigText) {
          figTitleEl.style.display = '';
          figTitleEl.textContent = vigtigText;
        } else {
          figTitleEl.style.display = 'none';
          figTitleEl.textContent = '';
        }
      }
      if (figSubtitleEl) {
        figSubtitleEl.textContent = '';
        figSubtitleEl.style.display = 'none';
      }

      // Keep legacy card hidden to avoid duplicated information.
      if (importantCard) importantCard.style.display = 'none';
      if (importantText) importantText.textContent = vigtigText;

      const figuresCard = document.getElementById('step2-out-figures');
      const figuresCarousel = document.getElementById('step2-figure-carousel');
      const figuresDebug = document.getElementById('step2-figures-debug');
      const parseRefs = (v) => {
        if (v === null || v === undefined) return [];
        if (Array.isArray(v)) return v.map(x => String(x).trim()).filter(Boolean);
        const s = String(v).trim();
        if (!s) return [];
        // Accept common separators: comma/semicolon/newline and also Danish "og" / "&".
        // Examples: "1.3.1 og 1.3.2" or "1.3.1, 1.3.2".
        return s
          .replace(/\s+og\s+/gi, ',')
          .replace(/\s+and\s+/gi, ',')
          .replace(/\s*&\s*/g, ',')
          .split(/[,;\n]/g)
          .map(x => x.trim())
          .filter(Boolean);
      };
      const refs = parseRefs(figurRef);
      if (figuresCard) figuresCard.style.display = hasBk ? '' : 'none';
      if (figuresDebug) {
        const allFigureKeys = Object.keys(outputs).filter(k => /figur|figure/i.test(k));
        if (!hasBk) {
          figuresDebug.style.display = 'none';
        } else if (refs.length) {
          figuresDebug.style.display = 'none';
        } else {
          const raw = (figurRef === undefined) ? '(ingen)' : String(figurRef);
          figuresDebug.style.display = '';
          figuresDebug.textContent =
            `Ingen figur-reference fundet i output.\n` +
            `Fundne figur-nøgler: ${allFigureKeys.length ? allFigureKeys.join(', ') : '(ingen)'}\n` +
            `Brugt nøgle: ${figurKey || '(ingen)'}\n` +
            `Rå værdi: ${raw}`;
        }
      }
      if (!hasBk) {
        step2FigureRefs = [];
        step2FigureIndex = 0;
        step2FigureTextBlocks = [];
        if (figuresCarousel) figuresCarousel.style.display = 'none';
      } else if (!refs.length) {
        step2FigureRefs = [];
        step2FigureIndex = 0;
        step2FigureTextBlocks = [];
        if (figuresCarousel) figuresCarousel.style.display = 'none';
      } else {
        // Keep index stable when possible.
        const prevRef = (Array.isArray(step2FigureRefs) && step2FigureRefs.length)
          ? String(step2FigureRefs[step2FigureIndex] ?? '')
          : '';
        step2FigureRefs = refs;
        step2FigureTextBlocks = parseFigureTextBlocks(figurTekstRaw);
        if (prevRef) {
          const found = step2FigureRefs.findIndex(r => String(r) === prevRef);
          step2FigureIndex = found >= 0 ? found : 0;
        } else {
          step2FigureIndex = clamp(step2FigureIndex, 0, step2FigureRefs.length - 1);
        }
        await renderStep2Figure();
      }
    }

    async function updateStep3Display() {
      // Step 3: Requirements based on bilag + brandklasse
      if (!latestEvaluation) {
        const setTextIf = (id, value) => {
          const el = document.getElementById(id);
          if (el) el.textContent = value;
        };

        setTextIf('display-ak', '-');
        setTextIf('display-rk', '-');
        setTextIf('display-bk', '-');
        setTextIf('display-bilag', '-');

        // Legacy nodes (may not exist)
        setTextIf('result-anvendelse-3', '-');
        setTextIf('result-anvendelse-desc-3', '');
        setTextIf('result-risiko-3', '-');
        setTextIf('result-risiko-desc-3', '');
        setTextIf('result-brand-3', '-');
        setTextIf('result-brand-desc-3', '');

        const container = document.getElementById('requirements-container');
        if (container) {
          container.innerHTML = `
            <div style="text-align: center; padding: 48px; color: #999;">
              <div style="font-size: 48px; margin-bottom: 16px;">📋</div>
              <div>Krav vises når brandklassen er bestemt</div>
            </div>
          `;
        }
        return;
      }
      const ak = latestEvaluation.anvendelseskategori?.value ?? '-';
      const rk = latestEvaluation.risikoklasse?.value ?? '-';
      const bk = latestEvaluation.brandklasse?.value ?? '-';
      const bilag = getBilagValueFromEvaluation(latestEvaluation) || '-';

      const setTextIf = (id, value) => {
        const el = document.getElementById(id);
        if (el) el.textContent = value;
      };

      setTextIf('display-ak', ak);
      setTextIf('display-rk', rk);
      setTextIf('display-bk', bk);
      setTextIf('display-bilag', bilag);

      // Legacy nodes (may not exist if Step 3 right panel changes)
      setTextIf('result-anvendelse-3', ak);
      setTextIf('result-anvendelse-desc-3', latestEvaluation.anvendelseskategori?.description ?? '');
      setTextIf('result-risiko-3', rk);
      setTextIf('result-risiko-desc-3', latestEvaluation.risikoklasse?.description ?? '');
      setTextIf('result-brand-3', bk);
      setTextIf('result-brand-desc-3', latestEvaluation.brandklasse?.description ?? '');

      await generateRequirements(bilag, bk, latestEvaluation);
    }

    async function loadBilagTemplate(bilag) {
      const container = document.getElementById('bilag-template-container');
      if (!container) return;
      if (!bilag || bilag === '-') {
        container.textContent = 'Relevant bilag er ikke bestemt endnu. Gå tilbage og udfyld grunddata.';
        return;
      }
      try {
        const resp = await fetch(`${API_BASE}/bilag/${bilag}.html`, { cache: 'no-store' });
        if (!resp.ok) throw new Error('bilag template not found');
        const html = await resp.text();
        container.innerHTML = html;
        try { bindBilagTemplate(container, String(bilag)); } catch(_) {}
      } catch (e) {
        container.innerHTML = `<div class="muted">Ingen skabelon fundet for bilag ${formatBilagDisplayId(bilag)}. Opret en fil <code>frontend/bilag/${bilag}.html</code>.</div>`;
      }
    }

    function inferBilag1BranchFromBygningstype(){
      const raw = (document.getElementById('fld_bygningstype')?.value || '').toLowerCase();
      // Simple heuristic: treat common multi-unit types as rækkehus, else default to enfamiliehus.
      if (raw.includes('række') || raw.includes('raekke') || raw.includes('kæde') || raw.includes('kaede') || raw.includes('dobbel') || raw.includes('gruppe')) return 'raekkehus';
      return 'enfamiliehus';
    }

    function bindBilagTemplate(container, bilagId){
      // 1) Bind bilag inputs into per-section bilagExtras state
      const inputs = Array.from(container.querySelectorAll('[data-bilag-key]'));
      inputs.forEach(el => {
        const key = el.getAttribute('data-bilag-key');
        if (!key) return;

        // Prefill from existing extras (if any)
        const existing = getActiveBilagExtras()[key];
        if (existing !== undefined) {
          if (el.tagName === 'SELECT') el.value = String(!!existing);
          else if (el.type === 'checkbox') el.checked = !!existing;
          else el.value = String(existing);
        }

        const onChange = ()=>{
          let value;
          if (el.tagName === 'SELECT') value = (String(el.value) === 'true');
          else if (el.type === 'checkbox') value = !!el.checked;
          else value = el.value;
          setActiveBilagExtra(key, value);
          // If the user isn't editing JSON manually, keep JSON pane in sync
          try {
            if (!syncingFromJson && !jsonManualEdit) {
              const merged = { ...canonicalizeInputData(buildJsonFromForm()), ...getActiveBilagExtras() };
              jsonTextarea.value = JSON.stringify(merged, null, 2);
            }
          } catch(_) {}
        };
        el.addEventListener('change', onChange);
        el.addEventListener('input', onChange);
      });

      // 2) Bilag 1: simple “one question at a time” flow with automatic branching
      if (String(bilagId) !== '1') return;
      const branch = inferBilag1BranchFromBygningstype();

      // Hide all questions not matching the branch (if branch-specific)
      const questions = Array.from(container.querySelectorAll('.bilag-question'));
      const filtered = questions.filter(q => {
        const only = q.getAttribute('data-only');
        if (!only) return true;
        return only === branch;
      });
      questions.forEach(q => q.style.display = 'none');

      let step = 0;
      const showStep = (n)=>{
        step = Math.max(0, Math.min(n, filtered.length - 1));
        filtered.forEach((q, i)=>{ q.style.display = (i === step) ? '' : 'none'; });
        const btnPrev = container.querySelector('[data-bilag-nav="prev"]');
        const btnNext = container.querySelector('[data-bilag-nav="next"]');
        if (btnPrev) btnPrev.disabled = (step === 0);
        if (btnNext) btnNext.disabled = (step >= filtered.length - 1);
        const prog = container.querySelector('[data-bilag-progress]');
        if (prog) prog.textContent = `${step + 1}/${Math.max(filtered.length, 1)}`;
      };

      const btnPrev = container.querySelector('[data-bilag-nav="prev"]');
      const btnNext = container.querySelector('[data-bilag-nav="next"]');
      if (btnPrev) btnPrev.addEventListener('click', ()=> showStep(step - 1));
      if (btnNext) btnNext.addEventListener('click', ()=> showStep(step + 1));
      showStep(0);
    }
    
    async function generateRequirements(bilag, brandklasse, evaluation) {
      const container = document.getElementById('requirements-container');
      if (!container) return;
      const activeSectionIdx = getActiveSectionIndex();

      // Coalesce/cancel: Step 3 can be triggered multiple times (navigation, loads, tab switches).
      // Only the latest invocation should complete.
      window.__kravGenerateCtl = window.__kravGenerateCtl || { token: 0, abort: null };
      const ctl = window.__kravGenerateCtl;
      const myToken = ++ctl.token;
      try { ctl.abort && ctl.abort.abort(); } catch(_) {}
      const abortController = new AbortController();
      ctl.abort = abortController;
      const isStale = () => (window.__kravGenerateCtl && window.__kravGenerateCtl.token !== myToken);
      const yieldUi = async () => {
        await new Promise(r => setTimeout(r, 0));
        if (isStale()) throw new DOMException('Stale render', 'AbortError');
      };

      // Ensure bilag is always a plain string/number token (never an object)
      try {
        if (bilag && typeof bilag === 'object') {
          bilag = getBilagValueFromEvaluation({ relevant_bilag: bilag }) || '-';
        }
        bilag = (bilag === null || bilag === undefined) ? '-' : String(bilag).trim();
      } catch (_) {}
      
      if (!bilag || bilag === '-' || !brandklasse || brandklasse === '-') {
        container.innerHTML = `
          <div style="text-align: center; padding: 48px; color: #999;">
            <div style="font-size: 48px; margin-bottom: 16px;">📋</div>
            <div>Krav vises når brandklassen er bestemt</div>
          </div>
        `;
        return;
      }

      container.innerHTML = `
        <div style="text-align: center; padding: 48px; color: #999;">
          <div style="font-size: 48px; margin-bottom: 16px;">📋</div>
          <div>Indlæser krav…</div>
        </div>
      `;
      await yieldUi();
      
      // Call backend API to get requirements (Krav)
      try {
        // Build input data from current form/JSON
        const inputData = { ...canonicalizeInputData(buildJsonFromForm()), ...getActiveBilagExtras() };
        inputData.Relevant_bilag = bilag;
        inputData.brandklasse = brandklasse;
        
        const response = await fetch(`${API_BASE}/evaluate-krav`, {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify(inputData),
          signal: abortController.signal
        });
        
        if (!response.ok) {
          throw new Error('API request failed');
        }
        
        const result = await response.json();
        if (isStale()) return;
        
        if (!result.success || !result.krav || result.krav.length === 0) {
          container.innerHTML = `
            <div style="text-align: center; padding: 48px; color: #999;">
              <div style="font-size: 48px; margin-bottom: 16px;">📋</div>
              <div>Ingen matchende krav fundet for ${formatBilagLabel(bilag)} - Brandklasse ${brandklasse}</div>
              ${result.error ? `<div style="margin-top: 12px; color: #e74c3c;">${result.error}</div>` : ''}
            </div>
          `;
          return;
        }
        
        const requirements = Array.isArray(result.krav) ? result.krav : [];

        if (isStale()) return;

        // Persist the exact matched krav rows for validation overview (per section + latestEvaluation)
        try {
          const idx = getActiveSectionIndex();
          sectionsState.kravResults = sectionsState.kravResults || [];
          sectionsState.kravResults[idx] = requirements;
          latestEvaluation = latestEvaluation || {};
          latestEvaluation.krav = requirements;
        } catch (_) {}

        // -------------------------
        // Helpers
        // -------------------------
        const decodeGorulesString = (value) => {
          if (value === null || value === undefined) return '';
          let s = String(value);

          // GoRules often stores strings with extra surrounding quotes, e.g. "\n\n-foo".
          s = s.trim();
          if (s.length >= 2 && s.startsWith('"') && s.endsWith('"')) {
            s = s.slice(1, -1);
          }

          // Decode common double-escaped sequences (when the model contains "\\n" literally)
          s = s
            .replace(/\\r\\n/g, '\n')
            .replace(/\\n/g, '\n')
            .replace(/\\r/g, '\n')
            .replace(/\\t/g, '\t')
            .replace(/\\"/g, '"')
            .replace(/\\\\/g, '\\');

          return s;
        };

        const norm = (v) => decodeGorulesString(v).trim();

        const multilineHtml = (raw) => {
          const s = norm(raw);
          if (!s) return '';
          // Escape, then convert newlines to <br> (double newline becomes blank line)
          return escapeHtml(s)
            .replace(/\r\n/g, '\n')
            .replace(/\n\n+/g, '<br><br>')
            .replace(/\n/g, '<br>');
        };
        const parseRefs = (raw) => {
          const s = norm(raw);
          if (!s) return [];
          return s
            .replace(/\s+og\s+/gi, ',')
            .replace(/\s+and\s+/gi, ',')
            .replace(/\s*&\s*/g, ',')
            .split(/[,;\n]/g)
            .map(x => x.trim())
            .filter(Boolean);
        };
        const parseChecklistItems = (raw) => {
          const s = norm(raw);
          if (!s) return [];
          const text = s.replace(/\r\n/g, '\n');

          // First try: double-newline delimiter (\n\n)
          if (/\n\s*\n/.test(text)) {
            return text
              .split(/\n\s*\n/)
              .map(x => x.trim())
              .filter(Boolean);
          }

          // Fallback: Bullet-per-line with dash
          if (/\n\s*-\s+/.test(text)) {
            return text
              .split(/\n+/)
              .map(l => l.trim())
              .filter(Boolean)
              .map(l => l.replace(/^\s*-\s*/, '').trim())
              .filter(Boolean);
          }

          // Single item (but also split on explicit " - " if user wrote multiple in one line)
          const one = text.trim();
          if (!one) return [];
          if (/\s-\s/.test(one) && !/^\s*-\s/.test(one)) {
            const parts = one.split(/\s-\s/).map(x => x.trim()).filter(Boolean);
            return parts.length ? parts : [one];
          }
          return [one];
        };

        // -------------------------
        // Viewer (right panel)
        // -------------------------
        window.__kravViewerState = window.__kravViewerState || { open: false, kind: null, refs: [], index: 0, source: null };
        const viewerState = window.__kravViewerState;
        const viewerTitleEl = document.getElementById('krav-viewer-title');
        const viewerBodyEl = document.getElementById('krav-viewer-body');
        const viewerSlotsEl = document.getElementById('krav-viewer-slots');
        const viewerPlaceholderEl = document.getElementById('krav-viewer-placeholder');
        const viewerCarouselEl = document.getElementById('krav-viewer-carousel');
        const viewerPrevEl = document.getElementById('krav-viewer-prev');
        const viewerNextEl = document.getElementById('krav-viewer-next');
        const viewerImgEl = document.getElementById('krav-viewer-img');
        const viewerRefEl = document.getElementById('krav-viewer-ref');
        const viewerCountEl = document.getElementById('krav-viewer-count');
        const viewerCaptionEl = document.getElementById('krav-viewer-caption');
        const viewerMissingEl = document.getElementById('krav-viewer-missing');

        const setViewerOpen = (open) => {
          viewerState.open = !!open;
          if (viewerBodyEl) viewerBodyEl.classList.toggle('open', viewerState.open);
          const btnMin = document.getElementById('krav-viewer-minimize');
          if (btnMin) btnMin.textContent = viewerState.open ? 'Minimér' : 'Vis';
        };

        // New asset structure: assets/<bilag-folder>/{figures,tables}/...
        // We map bilag "1" -> "bilag1" and bilag "1.1" -> "bilag11".
        const bilagFolder = (()=>{
          const b = normalizeBilagId(bilag);
          if (!b) return '';
          const digits = b.replace(/\D/g, '');
          return digits ? `bilag${digits}` : '';
        })();

        const buildAssetCandidates = (ref, kind) => {
          const r = String(ref || '').trim();
          if (!r) return [];
          const looksLikePath = r.includes('/') || r.includes('\\');
          const hasExt = /\.(png|jpg|jpeg|svg|webp|gif)$/i.test(r);
          if (looksLikePath) {
            const cleaned = r.replace(/\\/g, '/').replace(/^\/+/, '');
            return [`${API_BASE}/assets/${cleaned}`];
          }
          if (hasExt) return [`${API_BASE}/assets/${r.replace(/^\/+/, '')}`];

          const exts = ['png','jpg','jpeg','svg','webp'];
          const bilagBases = bilagFolder
            ? ((kind === 'table')
                ? [`${API_BASE}/assets/${bilagFolder}/tables/${r}`, `${API_BASE}/assets/${bilagFolder}/figures/${r}`]
                : [`${API_BASE}/assets/${bilagFolder}/figures/${r}`])
            : [];

          // Fallback to legacy global folders for backwards compatibility
          const legacyBases = (kind === 'table')
            ? [`${API_BASE}/assets/tables/${r}`, `${API_BASE}/assets/figures/${r}`, `${API_BASE}/assets/${r}`]
            : [`${API_BASE}/assets/figures/${r}`, `${API_BASE}/assets/${r}`];

          const bases = [...bilagBases, ...legacyBases];
          const out = [];
          for (const b of bases) for (const e of exts) out.push(`${b}.${e}`);
          return out;
        };

        async function loadFigureCaptions(){
          window.__figureCaptionsCache = window.__figureCaptionsCache || { loaded: new Set(), dataByUrl: {} };
          const cache = window.__figureCaptionsCache;

          const urls = [];
          if (bilagFolder) urls.push(`${API_BASE}/assets/${bilagFolder}/figures/captions.json`);
          urls.push(`${API_BASE}/assets/figures/captions.json`);

          for (const url of urls) {
            if (cache.loaded.has(url)) {
              const existing = cache.dataByUrl[url];
              if (existing) return existing;
              continue;
            }
            cache.loaded.add(url);
            try {
              const resp = await fetch(url, { cache: 'no-store' });
              if (!resp.ok) { cache.dataByUrl[url] = null; continue; }
              const data = await resp.json();
              cache.dataByUrl[url] = data || {};
              return cache.dataByUrl[url] || {};
            } catch(_) {
              cache.dataByUrl[url] = null;
            }
          }
          return {};
        }

        async function renderViewer(){
          if (!viewerTitleEl || !viewerBodyEl) return;
          viewerTitleEl.textContent = 'RELEVANTE FIGURER / TABELLER';

          // Legacy single-carousel viewer is disabled; we render per-button anchored slots instead.
          if (viewerCarouselEl) viewerCarouselEl.style.display = 'none';

          const hasSlots = !!(viewerSlotsEl && viewerSlotsEl.querySelector('.krav-slot'));
          if (viewerPlaceholderEl) viewerPlaceholderEl.style.display = (viewerState.open && hasSlots) ? 'none' : '';
        }

        if (!window.__kravViewerBound) {
          window.__kravViewerBound = true;
          const btnMin = document.getElementById('krav-viewer-minimize');
          if (btnMin) btnMin.addEventListener('click', ()=>{ setViewerOpen(!viewerState.open); renderViewer(); });
          if (viewerPrevEl) viewerPrevEl.addEventListener('click', ()=>{ viewerState.index = Math.max(0, viewerState.index - 1); renderViewer(); });
          if (viewerNextEl) viewerNextEl.addEventListener('click', ()=>{ viewerState.index = Math.min(Math.max(viewerState.refs.length - 1, 0), viewerState.index + 1); renderViewer(); });
        }

        // Keep viewer minimized until the user asks to see figures/tables
        setViewerOpen(viewerState.open);
        await renderViewer();

        // -------------------------
        // Checklist completion state (persist per section)
        // -------------------------
        sectionsState.kravChecks = sectionsState.kravChecks || [];
        sectionsState.kravExcluded = sectionsState.kravExcluded || [];
        sectionsState.kravNotes = sectionsState.kravNotes || [];
        const sectionIdx = getActiveSectionIndex();
        sectionsState.kravChecks[sectionIdx] = sectionsState.kravChecks[sectionIdx] || {};
        sectionsState.kravExcluded[sectionIdx] = sectionsState.kravExcluded[sectionIdx] || {};
        sectionsState.kravNotes[sectionIdx] = sectionsState.kravNotes[sectionIdx] || {};
        const okState = sectionsState.kravChecks[sectionIdx];
        const excludedState = sectionsState.kravExcluded[sectionIdx];
        const noteState = sectionsState.kravNotes[sectionIdx];
        const makeCheckKey = (kravId, text) => `${String(kravId || '').trim()}::${String(text || '').trim()}`;

        const getLinkedDocsForKey = (key) => {
          const out = [];
          try {
            const bySec = sectionsState?.kravCategoryDocs && typeof sectionsState.kravCategoryDocs === 'object'
              ? (sectionsState.kravCategoryDocs[String(sectionIdx)] || sectionsState.kravCategoryDocs[sectionIdx] || {})
              : {};
            for (const list of Object.values(bySec || {})) {
              if (!Array.isArray(list)) continue;
              for (const d of list) {
                const cov = Array.isArray(d?.coversChecklistKeys) ? d.coversChecklistKeys : [];
                if (!cov.map(x => String(x || '').trim()).includes(String(key || '').trim())) continue;
                out.push(d);
              }
            }
          } catch(_) {}
          return out;
        };

        const isDocumented = (key) => {
          const note = String(noteState?.[key] || '').trim();
          if (note) return true;
          const docs = getLinkedDocsForKey(key);
          return docs.length > 0;
        };

        const updateSingleDocStatus = (key) => {
          try {
            const k = String(key || '').trim();
            if (!k) return;
            const documented = isDocumented(k);

            const btn = container.querySelector(`.krav-doc-btn[data-krav-key="${CSS.escape(k)}"]`);
            if (btn) {
              btn.textContent = documented ? 'Dokumenteret' : 'Mangler dokumentation';
              btn.classList.toggle('has-text', documented);
            }

            const info = container.querySelector(`.krav-doc-bilag[data-krav-key="${CSS.escape(k)}"]`);
            if (info) {
              const linked = getLinkedDocsForKey(k);
              if (!linked.length) {
                info.style.display = 'none';
                info.textContent = '';
              } else {
                const names = linked
                  .map(d => String(d?.caption || d?.name || '').trim())
                  .filter(Boolean);
                const shown = names.slice(0, 3);
                const suffix = names.length > 3 ? ` (+${names.length - 3})` : '';
                info.style.display = '';
                info.textContent = 'Bilag tilknyttet: ' + (shown.join(', ') || `${linked.length} stk.`) + suffix;
              }
            }
          } catch(_) {}
        };

        const refreshDocStatuses = () => {
          try {
            const btns = Array.from(container.querySelectorAll('.krav-doc-btn[data-krav-key]'));
            for (const b of btns) {
              const k = String(b.getAttribute('data-krav-key') || '').trim();
              if (!k) continue;
              updateSingleDocStatus(k);
            }
          } catch(_) {}
        };

        // -------------------------
        // Preserve original row order (do NOT collapse on Krav_id)
        // -------------------------
        const rows = requirements.map((r, i) => {
          const kravId = norm(r?.Krav_id) || `__row_${i}`;
          const title = norm(r?.Krav_Titel) || 'Krav';
          const undertitle = norm(r?.Krav_Undertitel);
          const underundertitle = norm(r?.Krav_UnderUndertitel);
          const minititle = norm(r?.Krav_MiniTitel);
          const paragrafTitle = norm(r?.Krav_Paragraf_Titel);
          const paragrafUnderTitle = norm(r?.Krav_Paragraf_UnderTitel);
          const paragrafUnderUnderTitle = norm(
            r?.Krav_ParagrafUnderUnderTitel ??
            r?.Krav_Paragraf_UnderUnderTitel ??
            r?.Krav_Paragraf_UnderUndertitel
          );
          const beskrivelse = norm(r?.Krav_Beskrivelse);
          const dim = norm(r?.Krav_Korrekt_Dimensionering);
          const bullets = parseChecklistItems(norm(r?.Krav_Tjekliste));
          const figures = parseRefs(r?.Krav_Figurer);
          const tables = parseRefs(r?.Krav_Tabel || r?.Krav_Tabeller);
          return {
            kravId,
            title,
            undertitle,
            underundertitle,
            minititle,
            paragrafTitle,
            paragrafUnderTitle,
            paragrafUnderUnderTitle,
            beskrivelse,
            dim,
            bullets,
            figures,
            tables,
          };
        });

        const byTitle = new Map();
        const titleOrder = [];
        for (const row of rows) {
          const t = row.title || 'Krav';
          if (!byTitle.has(t)) { byTitle.set(t, []); titleOrder.push(t); }
          byTitle.get(t).push(row);
        }

        // Persist Krav-page category order so trin 4 (bilag) and exports match
        try {
          const idx = getActiveSectionIndex();
          sectionsState.kravCategoryOrder = sectionsState.kravCategoryOrder && typeof sectionsState.kravCategoryOrder === 'object'
            ? sectionsState.kravCategoryOrder
            : {};
          sectionsState.kravCategoryOrder[String(idx)] = titleOrder.slice();
        } catch (_) {}

        // -------------------------
        // Render
        // -------------------------
        container.innerHTML = '';
        const frag = document.createDocumentFragment();

        const createParaIcon = (text) => {
          const s = norm(text);
          if (!s) return null;
          const span = document.createElement('span');
          span.className = 'info-icon para-icon';
          span.textContent = '§';
          span.setAttribute('data-tip', s);
          span.setAttribute('tabindex', '0');
          return span;
        };

        const makeSegmentActionsRow = () => {
          const row = document.createElement('div');
          row.className = 'krav-segment-actions';
          return row;
        };

        // -------------------------
        // Right-panel anchored viewers (one slot per "Se figur" / "Se tabel" button)
        // -------------------------
        window.__kravInlineViewers = window.__kravInlineViewers || new Map();

        const closeInlineViewer = (key) => {
          const v = window.__kravInlineViewers.get(key);
          if (v?.slotEl && v.slotEl.parentNode) v.slotEl.parentNode.removeChild(v.slotEl);
          window.__kravInlineViewers.delete(key);
          renderViewer();
        };

        const closeAllInlineViewers = () => {
          try {
            for (const key of Array.from(window.__kravInlineViewers.keys())) closeInlineViewer(key);
          } catch(_) {}
        };

        // Requirements rerender destroys old buttons; close any old slots.
        closeAllInlineViewers();

        const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
        const rangesOverlap = (aTop, aH, bTop, bH) => (aTop < (bTop + bH)) && (bTop < (aTop + aH));

        const ensureSlotsHeight = () => {
          if (!viewerSlotsEl) return;
          try {
            const reqH = container?.getBoundingClientRect?.().height;
            if (reqH && isFinite(reqH)) viewerSlotsEl.style.minHeight = `${Math.max(140, Math.ceil(reqH))}px`;
          } catch(_) {}
        };

        const computeSlotTop = (anchorEl) => {
          if (!viewerSlotsEl || !anchorEl) return 0;
          const anchorDocTop = anchorEl.getBoundingClientRect().top + window.scrollY;
          const slotsDocTop = viewerSlotsEl.getBoundingClientRect().top + window.scrollY;
          return Math.max(0, anchorDocTop - slotsDocTop);
        };

        const layoutInlineViewers = () => {
          if (!viewerSlotsEl) return;
          ensureSlotsHeight();

          const slotsH = viewerSlotsEl.getBoundingClientRect().height;
          for (const v of window.__kravInlineViewers.values()) {
            if (!v?.slotEl || !v.anchorEl) continue;
            const desired = computeSlotTop(v.anchorEl);
            const h = v.slotEl.offsetHeight || 220;
            const top = clamp(desired, 0, Math.max(0, Math.floor(slotsH - h)));
            v.top = top;
            v.slotEl.style.top = `${top}px`;
          }

          // If two slots overlap, close the older one.
          const viewers = Array.from(window.__kravInlineViewers.values())
            .filter(v => v?.slotEl)
            .sort((a,b)=> (a.openedAt || 0) - (b.openedAt || 0));

          for (let i = 0; i < viewers.length; i++) {
            const a = viewers[i];
            if (!a?.slotEl) continue;
            const aTop = a.top || 0;
            const aH = a.slotEl.offsetHeight || 220;
            for (let j = i + 1; j < viewers.length; j++) {
              const b = viewers[j];
              if (!b?.slotEl) continue;
              const bTop = b.top || 0;
              const bH = b.slotEl.offsetHeight || 220;
              if (rangesOverlap(aTop, aH, bTop, bH)) {
                closeInlineViewer(a.key);
                break;
              }
            }
          }

          // Update placeholder visibility
          renderViewer();
        };

        // -------------------------
        // Expanded / fullscreen lightbox viewer
        // -------------------------
        window.__kravLightbox = window.__kravLightbox || { open: false, kind: null, refs: [], index: 0 };
        const lbState = window.__kravLightbox;
        const lbOverlayEl = document.getElementById('image-lightbox');
        const lbImgEl = document.getElementById('lightbox-img');
        const lbPrevEl = document.getElementById('lightbox-prev');
        const lbNextEl = document.getElementById('lightbox-next');
        const lbCloseEl = document.getElementById('lightbox-close');
        const lbCountEl = document.getElementById('lightbox-count');
        const lbCaptionEl = document.getElementById('lightbox-caption');
        const lbMissingEl = document.getElementById('lightbox-missing');

        const setLightboxOpen = (open) => {
          lbState.open = !!open;
          if (!lbOverlayEl) return;
          lbOverlayEl.classList.toggle('open', lbState.open);
          lbOverlayEl.setAttribute('aria-hidden', lbState.open ? 'false' : 'true');
          if (!lbState.open && lbImgEl) lbImgEl.removeAttribute('src');
        };

        const renderLightbox = async () => {
          if (!lbOverlayEl || !lbImgEl) return;
          const kind = lbState.kind;
          const refs = Array.isArray(lbState.refs) ? lbState.refs : [];
          lbState.index = Math.max(0, Math.min(lbState.index, Math.max(refs.length - 1, 0)));
          const ref = refs[lbState.index] || '';

          if (lbCountEl) lbCountEl.textContent = refs.length > 1 ? `${lbState.index + 1}/${refs.length}` : '';
          if (lbPrevEl) lbPrevEl.disabled = (lbState.index <= 0);
          if (lbNextEl) lbNextEl.disabled = (lbState.index >= refs.length - 1);
          if (lbMissingEl) { lbMissingEl.style.display = 'none'; lbMissingEl.textContent = ''; }

          if (lbCaptionEl) {
            if (kind !== 'figure') {
              lbCaptionEl.style.display = 'none';
              lbCaptionEl.textContent = '';
            } else {
              const captions = await loadFigureCaptions();
              const cap = captions && captions[String(ref)] ? String(captions[String(ref)]) : '';
              if (cap.trim()) { lbCaptionEl.style.display = ''; lbCaptionEl.textContent = cap; }
              else { lbCaptionEl.style.display = 'none'; lbCaptionEl.textContent = ''; }
            }
          }

          const candidates = buildAssetCandidates(ref, kind);
          let candidateIndex = 0;
          const tryNext = ()=>{
            candidateIndex++;
            if (candidateIndex >= candidates.length) {
              lbImgEl.removeAttribute('src');
              if (lbMissingEl) {
                lbMissingEl.style.display = '';
                lbMissingEl.textContent = `Kunne ikke finde fil for "${ref}".`;
              }
              return;
            }
            lbImgEl.src = candidates[candidateIndex];
          };

          lbImgEl.onerror = tryNext;
          lbImgEl.onload = ()=>{ if (lbMissingEl) lbMissingEl.style.display = 'none'; };
          if (candidates.length) lbImgEl.src = candidates[0];
          else {
            lbImgEl.removeAttribute('src');
            if (lbMissingEl) { lbMissingEl.style.display = ''; lbMissingEl.textContent = 'Ingen reference angivet.'; }
          }
        };

        if (!window.__kravLightboxBound) {
          window.__kravLightboxBound = true;
          if (lbCloseEl) lbCloseEl.addEventListener('click', ()=> setLightboxOpen(false));
          if (lbOverlayEl) lbOverlayEl.addEventListener('click', (e)=>{
            if (e.target === lbOverlayEl) setLightboxOpen(false);
          });
          window.addEventListener('keydown', (e)=>{
            if (!lbState.open) return;
            if (e.key === 'Escape') setLightboxOpen(false);
            if (e.key === 'ArrowLeft') { lbState.index = Math.max(0, lbState.index - 1); renderLightbox(); }
            if (e.key === 'ArrowRight') { lbState.index = Math.min(Math.max(lbState.refs.length - 1, 0), lbState.index + 1); renderLightbox(); }
          });
          if (lbPrevEl) lbPrevEl.addEventListener('click', ()=>{ lbState.index = Math.max(0, lbState.index - 1); renderLightbox(); });
          if (lbNextEl) lbNextEl.addEventListener('click', ()=>{ lbState.index = Math.min(Math.max(lbState.refs.length - 1, 0), lbState.index + 1); renderLightbox(); });
        }

        const openLightboxFor = async (viewer) => {
          lbState.kind = viewer?.kind || 'figure';
          lbState.refs = Array.from(new Set((viewer?.refs || []).map(x => String(x).trim()).filter(Boolean)));
          lbState.index = Math.max(0, Math.min(viewer?.index || 0, Math.max(lbState.refs.length - 1, 0)));
          setLightboxOpen(true);
          await renderLightbox();
        };

        const renderInlineViewer = async (viewer) => {
          if (!viewer?.slotEl) return;
          const slotEl = viewer.slotEl;

          const imgEl = slotEl.querySelector('[data-kvs-img]');
          const countEl = slotEl.querySelector('[data-kvs-count]');
          const captionEl = slotEl.querySelector('[data-kvs-caption]');
          const missingEl = slotEl.querySelector('[data-kvs-missing]');
          const btnPrev = slotEl.querySelector('[data-kvs-prev]');
          const btnNext = slotEl.querySelector('[data-kvs-next]');
          const btnExpand = slotEl.querySelector('[data-kvs-expand]');
          const btnAttach = slotEl.querySelector('[data-kvs-attach]');

          const kind = viewer.kind;
          viewer.index = Math.max(0, Math.min(viewer.index, Math.max((viewer.refs.length - 1), 0)));
          const ref = viewer.refs[viewer.index] || '';

          viewer.__currentRef = ref;
          try {
            if (btnAttach) {
              const enabled = (kind === 'figure') && !!String(ref || '').trim() && !!String(viewer?.categoryLabel || '').trim();
              btnAttach.style.display = enabled ? '' : 'none';
              btnAttach.disabled = !enabled;
            }
          } catch(_) {}

          if (countEl) countEl.textContent = viewer.refs.length > 1 ? `${viewer.index + 1}/${viewer.refs.length}` : '';
          if (btnPrev) btnPrev.disabled = (viewer.index <= 0);
          if (btnNext) btnNext.disabled = (viewer.index >= viewer.refs.length - 1);
          if (missingEl) { missingEl.style.display = 'none'; missingEl.textContent = ''; }

          // Captions only for figures
          if (captionEl) {
            if (kind !== 'figure') {
              captionEl.style.display = 'none';
              captionEl.textContent = '';
            } else {
              const captions = await loadFigureCaptions();
              const cap = captions && captions[String(ref)] ? String(captions[String(ref)]) : '';
              if (cap.trim()) { captionEl.style.display = ''; captionEl.textContent = cap; }
              else { captionEl.style.display = 'none'; captionEl.textContent = ''; }
            }
          }

          const candidates = buildAssetCandidates(ref, kind);
          let candidateIndex = 0;
          const tryNext = ()=>{
            candidateIndex++;
            if (candidateIndex >= candidates.length) {
              if (imgEl) imgEl.removeAttribute('src');
              if (missingEl) {
                missingEl.style.display = '';
                missingEl.textContent = `Kunne ikke finde fil for "${ref}".\nForventede fx: ${candidates.slice(0, 4).join(', ')}${candidates.length > 4 ? '…' : ''}`;
              }
              setTimeout(layoutInlineViewers, 0);
              return;
            }
            if (imgEl) imgEl.src = candidates[candidateIndex];
          };

          if (imgEl) {
            imgEl.onerror = tryNext;
            imgEl.onload = ()=>{
              try { viewer.__currentUrl = String(imgEl.currentSrc || imgEl.src || ''); } catch(_) {}
              if (missingEl) missingEl.style.display = 'none';
              setTimeout(layoutInlineViewers, 0);
            };
            if (candidates.length) imgEl.src = candidates[0];
            else {
              imgEl.removeAttribute('src');
              if (missingEl) { missingEl.style.display = ''; missingEl.textContent = `Ingen reference angivet.`; }
              setTimeout(layoutInlineViewers, 0);
            }
          }

          if (btnExpand) {
            btnExpand.onclick = ()=>{ openLightboxFor(viewer); };
          }
        };

        const guessExtFromUrl = (url) => {
          const u = String(url || '').split('?')[0].split('#')[0];
          const m = u.match(/\.([a-z0-9]+)$/i);
          return m ? String(m[1]).toLowerCase() : '';
        };

        const normalizeBaseName = (s) => {
          let t = String(s || '').trim();
          if (!t) return 'figur';
          t = t.replace(/\.[a-z0-9]+$/i, '');
          t = t.replace(/[^a-z0-9æøå _-]+/gi, ' ').trim();
          t = t.replace(/\s+/g, '_');
          return t || 'figur';
        };

        const blobToPngFile = async (blob, baseName, fallbackExt) => {
          const safeBase = normalizeBaseName(baseName);
          const url = URL.createObjectURL(blob);
          try {
            const img = await new Promise((resolve, reject) => {
              try {
                const im = new Image();
                im.onload = () => resolve(im);
                im.onerror = () => reject(new Error('Billede kunne ikke indlæses'));
                im.src = url;
              } catch (e) { reject(e); }
            });

            const canvas = document.createElement('canvas');
            canvas.width = Math.max(1, img.naturalWidth || img.width || 1);
            canvas.height = Math.max(1, img.naturalHeight || img.height || 1);
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            const outBlob = await new Promise((resolve) => {
              try {
                canvas.toBlob((b) => resolve(b), 'image/png');
              } catch(_) { resolve(null); }
            });

            if (outBlob && String(outBlob.type || '').toLowerCase().includes('png')) {
              try {
                return new File([outBlob], `${safeBase}.png`, { type: 'image/png' });
              } catch(_) {
                outBlob.name = `${safeBase}.png`;
                return outBlob;
              }
            }

            // Conversion failed; keep original blob.
            const ext = String(fallbackExt || '').trim().toLowerCase() || (String(blob?.type || '').includes('/') ? String(blob.type).split('/')[1] : 'img');
            const name = `${safeBase}.${ext}`;
            try {
              return new File([blob], name, { type: String(blob?.type || '') });
            } catch(_) {
              blob.name = name;
              return blob;
            }
          } finally {
            try { URL.revokeObjectURL(url); } catch(_) {}
          }
        };

        const openInlineViewer = async ({ kind, refs, source, anchorEl, categoryLabel, onDocsUpdated }) => {
          if (!viewerSlotsEl) return;
          const key = `${String(kind)}::${String(source || '')}`;
          const existing = window.__kravInlineViewers.get(key);
          if (existing && existing.slotEl && viewerSlotsEl.contains(existing.slotEl)) {
            closeInlineViewer(key);
            return;
          }

          setViewerOpen(true);
          ensureSlotsHeight();

          const slot = document.createElement('div');
          slot.className = 'krav-slot';
          slot.innerHTML = `
            <div class="krav-slot-actions">
              <button class="krav-slot-expand" type="button" aria-label="Udvid" data-kvs-expand>⤢</button>
              <button class="krav-slot-close" type="button" aria-label="Luk">×</button>
            </div>
            <div class="krav-carousel">
              <button class="figure-nav-btn" type="button" aria-label="Forrige" data-kvs-prev>‹</button>
              <div class="krav-stage">
                <div class="krav-frame">
                  <img data-kvs-img alt="" />
                </div>
                <div class="krav-viewer-meta">
                  <div>
                    <span class="count" data-kvs-count></span>
                  </div>
                  <div class="krav-viewer-caption" data-kvs-caption style="display:none;"></div>
                  <div class="krav-viewer-missing" data-kvs-missing style="display:none;"></div>
                  <div style="margin-top: 8px;">
                    <button class="btn-secondary" type="button" data-kvs-attach style="padding: 6px 10px;">Brug denne figur i dokumentation</button>
                  </div>
                </div>
              </div>
              <button class="figure-nav-btn" type="button" aria-label="Næste" data-kvs-next>›</button>
            </div>
          `;
          viewerSlotsEl.appendChild(slot);

          const viewer = {
            key,
            kind,
            refs: Array.from(new Set((refs || []).map(x => String(x).trim()).filter(Boolean))),
            index: 0,
            source: source || null,
            categoryLabel: String(categoryLabel || '').trim() || null,
            onDocsUpdated: (typeof onDocsUpdated === 'function') ? onDocsUpdated : null,
            anchorEl,
            slotEl: slot,
            openedAt: Date.now(),
            top: 0,
            __currentRef: '',
            __currentUrl: '',
          };
          window.__kravInlineViewers.set(key, viewer);

          const btnPrev = slot.querySelector('[data-kvs-prev]');
          const btnNext = slot.querySelector('[data-kvs-next]');
          const btnClose = slot.querySelector('.krav-slot-close');
          const btnAttach = slot.querySelector('[data-kvs-attach]');
          if (btnPrev) btnPrev.addEventListener('click', ()=>{ viewer.index = Math.max(0, viewer.index - 1); renderInlineViewer(viewer); });
          if (btnNext) btnNext.addEventListener('click', ()=>{ viewer.index = Math.min(Math.max(viewer.refs.length - 1, 0), viewer.index + 1); renderInlineViewer(viewer); });
          if (btnClose) btnClose.addEventListener('click', ()=> closeInlineViewer(key));
          if (btnAttach) btnAttach.addEventListener('click', async (e) => {
            e.stopPropagation();
            try {
              if (viewer.kind !== 'figure') return;
              const cat = String(viewer.categoryLabel || '').trim();
              if (!cat) return;

              const url = String(viewer.__currentUrl || '').trim();
              const ref = String(viewer.__currentRef || '').trim();
              if (!url || !ref) {
                alert('Kunne ikke finde den aktuelle figur. Prøv at åbne figuren igen.');
                return;
              }

              btnAttach.disabled = true;
              const resp = await fetch(url, { cache: 'no-store' });
              if (!resp.ok) throw new Error('Kunne ikke hente figuren');
              const blob = await resp.blob();

              const base = normalizeBaseName(ref);
              const ext = guessExtFromUrl(url);
              // Convert to PNG to ensure it can be embedded reliably in PDF exports.
              const file = await blobToPngFile(blob, base || (ext ? `figur_${ext}` : 'figur'), ext);

              const sectionIdx = getActiveSectionIndex();
              addKravCategoryDocsFromFiles(sectionIdx, cat, [file]);

              try { if (viewer.onDocsUpdated) viewer.onDocsUpdated(); } catch(_) {}
            } catch (err) {
              console.error(err);
              alert('Kunne ikke tilføje figuren som bilag. Tjek Console (F12) for fejl.');
            } finally {
              try { btnAttach.disabled = false; } catch(_) {}
            }
          });

          // Initial position & render
          viewer.top = computeSlotTop(anchorEl);
          slot.style.top = `${viewer.top}px`;
          await renderInlineViewer(viewer);
          layoutInlineViewers();
        };

        const createViewerButton = (kind, refs, source, anchorEl, options) => {
          const items = Array.from(new Set((refs || []).map(x => String(x).trim()).filter(Boolean)));
          if (!items.length) return null;
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'krav-pill';
          const label = (kind === 'table')
            ? (items.length === 1 ? 'Se tabel' : 'Se tabeller')
            : (items.length === 1 ? 'Se figur' : 'Se figurer');
          btn.textContent = label;
          btn.addEventListener('click', ()=>{
            openInlineViewer({
              kind,
              refs: items,
              source: source || null,
              anchorEl: anchorEl || btn,
              categoryLabel: options?.categoryLabel,
              onDocsUpdated: options?.onDocsUpdated,
            });
          });
          return btn;
        };

        for (const title of titleOrder) {
          if (isStale()) return;
          const titleRows = byTitle.get(title) || [];

          const block = document.createElement('div');
          block.className = 'krav-title-block';

          const header = document.createElement('div');
          header.className = 'krav-title-header';
          const left = document.createElement('div');
          left.className = 'krav-title-left';
          const titleEl = document.createElement('div');
          titleEl.className = 'krav-title';
          titleEl.textContent = title;
          const titlePara = titleRows.map(r => r.paragrafTitle).find(x => norm(x));
          const titleParaIcon = createParaIcon(titlePara);
          if (titleParaIcon) titleEl.appendChild(titleParaIcon);
          left.appendChild(titleEl);
          header.appendChild(left);
          
          const titleActions = document.createElement('div');
          titleActions.className = 'krav-heading-actions';
          header.appendChild(titleActions);
          
          block.appendChild(header);

          const body = document.createElement('div');
          body.className = 'krav-block-body';

          // -------------------------
          // Step 3: Upload documentation per krav-gruppe (title)
          // -------------------------
          const docsCategoryLabel = String(title || '').trim();
          const docsFileInput = document.createElement('input');
          docsFileInput.type = 'file';
          docsFileInput.multiple = true;
          docsFileInput.style.display = 'none';

          const docsHeaderBtn = document.createElement('button');
          docsHeaderBtn.type = 'button';
          docsHeaderBtn.className = 'btn-secondary';
          docsHeaderBtn.style.padding = '8px 12px';
          docsHeaderBtn.textContent = 'Tilføj bilag';
          docsHeaderBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            try { docsFileInput.click(); } catch(_) {}
          });

          // Put controls into the title header actions (visible even when user hasn't expanded anything)
          try {
            const checkAllBtn = document.createElement('button');
            checkAllBtn.type = 'button';
            checkAllBtn.className = 'krav-check-all-btn';
            checkAllBtn.textContent = '✓ Tjek alle';
            checkAllBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              // Mark all checklist items in this kravgruppe as overholdt (skip excluded).
              try {
                for (const it of checklistItemsForTitle) {
                  const k = String(it?.key || '').trim();
                  if (!k) continue;
                  if (excludedState[k]) continue;
                  okState[k] = true;
                }
              } catch(_) {}

              // Update visible checkboxes inside this block.
              try {
                body.querySelectorAll('input[data-krav-ok="true"]').forEach(cb => {
                  const k = String(cb.getAttribute('data-krav-key') || '').trim();
                  if (!k) return;
                  if (excludedState[k]) return;
                  cb.checked = true;
                });
              } catch(_) {}
            });

            titleActions.appendChild(checkAllBtn);
            titleActions.appendChild(docsHeaderBtn);
          } catch(_) {}

          const docsBlock = document.createElement('div');
          docsBlock.className = 'cat-docs';
          docsBlock.setAttribute('data-category-label', docsCategoryLabel);

          const docsBlockHeader = document.createElement('div');
          docsBlockHeader.className = 'cat-docs-header';

          const docsHeaderText = document.createElement('div');
          const docsTitle = document.createElement('div');
          docsTitle.className = 'cat-docs-title';
          docsTitle.textContent = 'Dokumentation til denne kravgruppe';
          const docsSub = document.createElement('div');
          docsSub.className = 'cat-docs-sub';
          docsSub.textContent = 'Tilføj relevante bilag, samt billedtekst og evt. en kort forklaring. Det kommer med i dokumentationen i trin 4.';
          docsHeaderText.appendChild(docsTitle);
          docsHeaderText.appendChild(docsSub);

          docsBlockHeader.appendChild(docsHeaderText);

          const docsList = document.createElement('div');
          docsList.className = 'cat-docs-list';

          // Build a stable list of checklist items for this kravgruppe (title).
          // Each item is identified by the same key format as sectionsState.kravChecks.
          const checklistItemsForTitle = (() => {
            const out = [];
            const seen = new Set();
            for (const r of (titleRows || [])) {
              const kravId = String(r?.kravId || '').trim();
              const bullets = Array.isArray(r?.bullets) ? r.bullets : [];
              for (const b of bullets) {
                const text = String(b || '').trim();
                if (!kravId || !text) continue;
                const k = makeCheckKey(kravId, text);
                if (seen.has(k)) continue;
                seen.add(k);
                out.push({ key: k, kravId, text });
              }
            }
            return out;
          })();

          const renderDocs = () => {
            const docs = getKravCategoryDocs(activeSectionIdx, docsCategoryLabel);
            const n = Array.isArray(docs) ? docs.length : 0;
            docsList.innerHTML = '';
            if (!n) {
              const empty = document.createElement('div');
              empty.className = 'cat-doc-empty';
              empty.textContent = 'Ingen dokumentation tilføjet til denne kravgruppe endnu.';
              docsList.appendChild(empty);
              return;
            }

            for (const d of docs) {
              const item = document.createElement('div');
              item.className = 'cat-doc-item';
              item.setAttribute('data-doc-id', String(d?.id || ''));

              // Default to compact rows; user can expand by clicking the text.
              if (typeof d?.uiCollapsed !== 'boolean') {
                updateKravCategoryDocField(activeSectionIdx, docsCategoryLabel, String(d?.id || ''), 'uiCollapsed', true);
              }
              item.classList.toggle('is-collapsed', Boolean(d?.uiCollapsed));

              const top = document.createElement('div');
              top.className = 'cat-doc-item-top';

              const nameBtn = document.createElement('button');
              nameBtn.type = 'button';
              nameBtn.className = 'cat-doc-name-btn';
              nameBtn.title = 'Klik for at udvide og redigere bilaget';
              nameBtn.setAttribute('aria-label', 'Udvid bilag');

              const updateRowText = () => {
                // Keep the compact row very small: only show the filename.
                nameBtn.textContent = String(d?.name || 'fil').trim();
              };
              updateRowText();

              nameBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const nowCollapsed = !item.classList.contains('is-collapsed');
                item.classList.toggle('is-collapsed', nowCollapsed);
                updateKravCategoryDocField(activeSectionIdx, docsCategoryLabel, String(d?.id || ''), 'uiCollapsed', nowCollapsed);
              });

              const rmBtn = document.createElement('button');
              rmBtn.type = 'button';
              rmBtn.className = 'cat-doc-remove';
              rmBtn.textContent = '×';
              rmBtn.setAttribute('aria-label', 'Fjern bilag');
              rmBtn.title = 'Fjern bilag';
              rmBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                removeKravCategoryDoc(activeSectionIdx, docsCategoryLabel, String(d?.id || ''));
                renderDocs();
              });

              top.appendChild(nameBtn);
              top.appendChild(rmBtn);

              const fields = document.createElement('div');
              fields.className = 'cat-doc-fields';

              const capLabel = document.createElement('label');
              capLabel.className = 'cat-doc-field';
              const capLbl = document.createElement('div');
              capLbl.className = 'cat-doc-field-label';
              capLbl.textContent = 'Billedtekst';
              const capInput = document.createElement('input');
              capInput.type = 'text';
              capInput.className = 'cat-doc-input';
              capInput.setAttribute('spellcheck', 'false');
              capInput.setAttribute('autocorrect', 'off');
              capInput.setAttribute('autocapitalize', 'off');
              capInput.placeholder = 'fx Figur 1: Placering af brandvæg';
              capInput.value = String(d?.caption || '');
              capInput.addEventListener('input', () => {
                updateKravCategoryDocField(activeSectionIdx, docsCategoryLabel, String(d?.id || ''), 'caption', capInput.value);
                try { updateRowText(); } catch(_) {}
              });
              capLabel.appendChild(capLbl);
              capLabel.appendChild(capInput);

              const descLabel = document.createElement('label');
              descLabel.className = 'cat-doc-field';
              const descLbl = document.createElement('div');
              descLbl.className = 'cat-doc-field-label';
              descLbl.textContent = 'Kort forklaring (valgfri)';
              const descArea = document.createElement('textarea');
              descArea.className = 'cat-doc-textarea';
              descArea.setAttribute('spellcheck', 'false');
              descArea.setAttribute('autocorrect', 'off');
              descArea.setAttribute('autocapitalize', 'off');
              descArea.rows = 2;
              descArea.placeholder = 'Hvad viser dokumentet/figuren – og hvorfor er det relevant?';
              descArea.value = String(d?.description || '');
              descArea.addEventListener('input', () => {
                updateKravCategoryDocField(activeSectionIdx, docsCategoryLabel, String(d?.id || ''), 'description', descArea.value);
                try { updateRowText(); } catch(_) {}
              });
              descLabel.appendChild(descLbl);
              descLabel.appendChild(descArea);

              fields.appendChild(capLabel);
              fields.appendChild(descLabel);

              item.appendChild(top);
              item.appendChild(fields);

              // Per-bilag mapping: which checklist items this bilag documents.
              // Render as a compact <details> with checkboxes.
              if (checklistItemsForTitle.length) {
                const details = document.createElement('details');
                details.style.marginTop = '10px';

                const selected = new Set(Array.isArray(d?.coversChecklistKeys) ? d.coversChecklistKeys.map(x => String(x || '').trim()).filter(Boolean) : []);

                const summary = document.createElement('summary');
                summary.style.cursor = 'pointer';
                summary.style.userSelect = 'none';
                const updateSummaryText = () => {
                  summary.textContent = `Dokumenterer tjeklistepunkter (${selected.size} valgt)`;
                };
                updateSummaryText();

                const box = document.createElement('div');
                box.style.marginTop = '8px';
                box.style.paddingLeft = '6px';

                const hint = document.createElement('div');
                hint.className = 'muted';
                hint.style.fontSize = '12px';
                hint.style.marginBottom = '8px';
                hint.textContent = 'Markér hvilke tjeklistepunkter dette bilag dokumenterer. Bruges i afsnit 5 i eksport.';
                box.appendChild(hint);

                const listWrap = document.createElement('div');
                listWrap.style.display = 'grid';
                listWrap.style.gap = '6px';

                for (const it of checklistItemsForTitle) {
                  const row = document.createElement('label');
                  row.style.display = 'flex';
                  row.style.alignItems = 'flex-start';
                  row.style.gap = '10px';

                  const cb = document.createElement('input');
                  cb.type = 'checkbox';
                  cb.checked = selected.has(it.key);
                  cb.addEventListener('change', () => {
                    if (cb.checked) selected.add(it.key);
                    else selected.delete(it.key);
                    setKravCategoryDocCoverageKeys(activeSectionIdx, docsCategoryLabel, String(d?.id || ''), Array.from(selected));
                    updateSummaryText();
                    updateSingleDocStatus(it.key);
                  });

                  const text = document.createElement('div');
                  text.style.flex = '1';
                  const prefix = it.kravId ? (`${it.kravId}: `) : '';
                  text.innerHTML = multilineHtml(prefix + String(it.text || ''));

                  row.appendChild(cb);
                  row.appendChild(text);
                  listWrap.appendChild(row);
                }

                box.appendChild(listWrap);
                details.appendChild(summary);
                details.appendChild(box);
                item.appendChild(details);
              }

              docsList.appendChild(item);
            }

            // Mapping may have changed via checkboxes; keep per-item status buttons in sync.
            try { refreshDocStatuses(); } catch(_) {}
          };

          docsFileInput.addEventListener('change', async () => {
            try {
              const files = docsFileInput.files;
              if (files && files.length > 0) {
                const arr = Array.from(files);
                const pdfs = arr.filter(f => f && ((String(f.type || '').toLowerCase() === 'application/pdf') || /\.pdf$/i.test(String(f.name || ''))));
                let finalFiles = arr;
                if (pdfs.length > 0) {
                  const ok = confirm('PDF-bilag bliver konverteret til billede (side 1) for at kunne indgå i eksport. Fortsæt?');
                  if (ok) {
                    finalFiles = [];
                    for (const f of arr) {
                      if (f && ((String(f.type || '').toLowerCase() === 'application/pdf') || /\.pdf$/i.test(String(f.name || '')))) {
                        try {
                          const img = await pdfFileToPngFile(f, { pageNumber: 1, scale: 2 });
                          finalFiles.push(img);
                        } catch(err) {
                          finalFiles.push(f);
                        }
                      } else {
                        finalFiles.push(f);
                      }
                    }
                  }
                }

                addKravCategoryDocsFromFiles(activeSectionIdx, docsCategoryLabel, finalFiles);
              }
            } catch(_) {}
            try { docsFileInput.value = ''; } catch(_) {}
            renderDocs();
          });

          docsBlock.appendChild(docsBlockHeader);
          docsBlock.appendChild(docsList);
          docsBlock.appendChild(docsFileInput);
          renderDocs();

          body.appendChild(docsBlock);

          let lastUnder = null;
          let lastUnderHeadingEl = null;
          let lastUnderUnderHeadingEl = null;
          let lastMiniHeadingEl = null;
          let currentKravId = null;
          let currentGroupWrap = null;
          let currentGroupBody = null;
          let checklistOffsetInGroup = 0;
          let lastUnderUnderInGroup = null;
          let lastMiniInGroup = null;
          let dimAnchorInGroup = null;

          const ensureHeadingActions = (headingEl) => {
            if (!headingEl) return null;
            let wrap = headingEl.querySelector(':scope > .krav-heading-actions');
            if (!wrap) {
              wrap = document.createElement('span');
              wrap.className = 'krav-heading-actions';
              headingEl.appendChild(wrap);
            }
            return wrap;
          };

          const attachViewerButtons = (headingEl, row) => {
            if (!headingEl || !row) return;
            const wrap = ensureHeadingActions(headingEl);
            if (!wrap) return;

            const figures = Array.isArray(row.figures) ? row.figures : [];
            const tables = Array.isArray(row.tables) ? row.tables : [];
            const anchorKey = (row.underundertitle || row.undertitle || row.title || '').trim();

            if (figures.length && !wrap.querySelector('[data-krav-action="figure"]')) {
              const btn = createViewerButton('figure', figures, `${row.kravId}::${anchorKey}::figure`, null, { categoryLabel: docsCategoryLabel, onDocsUpdated: renderDocs });
              if (btn) { btn.setAttribute('data-krav-action', 'figure'); wrap.appendChild(btn); }
            }
            if (tables.length && !wrap.querySelector('[data-krav-action="table"]')) {
              const btn = createViewerButton('table', tables, `${row.kravId}::${anchorKey}::table`, null, { categoryLabel: null, onDocsUpdated: null });
              if (btn) { btn.setAttribute('data-krav-action', 'table'); wrap.appendChild(btn); }
            }
          };

          for (const row of titleRows) {
            const under = row.undertitle || '';
            if (under !== lastUnder && under) {
              const uEl = document.createElement('div');
              uEl.className = 'krav-subtitle';
              uEl.textContent = under;
              const pIcon = createParaIcon(row.paragrafUnderTitle);
              if (pIcon) uEl.appendChild(pIcon);
              body.appendChild(uEl);
              lastUnder = under;
              lastUnderHeadingEl = uEl;
              lastUnderUnderHeadingEl = null;
              // force new Krav group after a new undertitle section
              currentKravId = null;
              currentGroupWrap = null;
              currentGroupBody = null;
              lastUnderUnderInGroup = null;
            }

            // Create a new group when kravId changes
            const kravId = row.kravId || '';
            if (kravId !== currentKravId) {
              currentKravId = kravId;
              checklistOffsetInGroup = 0;

              currentGroupWrap = document.createElement('div');
              currentGroupWrap.className = 'krav-group';

              const gHeader = document.createElement('div');
              gHeader.className = 'krav-group-header';
              const gMeta = document.createElement('div');
              gMeta.className = 'krav-group-meta';
              const badge = document.createElement('div');
              badge.className = 'krav-id-badge';
              badge.textContent = kravId;
              // Note: appended after validation badge (below) to keep krav-id discreet.
              
              // Add validation badge showing granular validation status
              // Count ACTUAL points from the krav content, not just what's in validationData
              const kravValidation = getKravValidationRecord(kravId);
              
              // Find all rows with this kravId to count actual content
              const kravRows = titleRows.filter(r => r.kravId === kravId);
              let actualTotalCount = 0;
              let actualBeskrivelseCount = 0;
              let actualChecklistCount = 0;
              let actualDimCount = 0;
              
              // Count actual beskrivelse, bullets, dim from rows
              kravRows.forEach(r => {
                if (r.beskrivelse) actualBeskrivelseCount++;
                if (r.bullets && r.bullets.length > 0) actualChecklistCount += r.bullets.length;
                if (r.dim) actualDimCount++;
              });
              
              actualTotalCount = actualBeskrivelseCount + actualChecklistCount + actualDimCount;
              
              // Count validated items (checklist counted by *actual* bullets so indices/order can't drift)
              const validatedChecklist = (() => {
                if (actualChecklistCount <= 0) return 0;
                if (kravIsFullyValidated(kravValidation)) return actualChecklistCount;
                let c = 0;
                let flatIdx = 0;
                kravRows.forEach(r => {
                  if (r.bullets && r.bullets.length > 0) {
                    r.bullets.forEach(b => {
                      if (kravChecklistTextValidated(kravValidation, b, flatIdx)) c++;
                      flatIdx++;
                    });
                  }
                });
                // Safety: never exceed actual
                if (c > actualChecklistCount) c = actualChecklistCount;
                return c;
              })();

              const validatedBeskrivelseCount = (actualBeskrivelseCount > 0 && kravBeskrivelseValidated(kravValidation)) ? actualBeskrivelseCount : 0;
              const validatedDimCount = (actualDimCount > 0 && kravDimensioneringValidated(kravValidation)) ? actualDimCount : 0;
              let validatedCount = validatedBeskrivelseCount + validatedChecklist + validatedDimCount;
              // Hard safety: never let validated exceed actual (can happen with legacy/stale validation.json)
              if (validatedCount > actualTotalCount) validatedCount = actualTotalCount;
              
              const isFullyValidated = actualTotalCount > 0 && validatedCount === actualTotalCount;
              const isPartiallyValidated = validatedCount > 0 && validatedCount < actualTotalCount;
              const isNotValidated = validatedCount === 0;
              
              const valBadge = document.createElement('span');
              valBadge.className = 'validation-badge';
              
              // Build detailed status text
              let statusParts = [];
              if (actualBeskrivelseCount > 0) {
                statusParts.push(`Beskrivelse: ${kravBeskrivelseValidated(kravValidation) ? '✓' : '✗'}`);
              }
              if (actualChecklistCount > 0) {
                statusParts.push(`Tjekliste: ${validatedChecklist}/${actualChecklistCount}`);
              }
              if (actualDimCount > 0) {
                statusParts.push(`Uddybende forklaring: ${kravDimensioneringValidated(kravValidation) ? '✓' : '✗'}`);
              }
              
              let badgeColor, badgeText, badgeTooltip;
              if (isFullyValidated) {
                badgeColor = 'background: var(--c-bg-2); color: var(--c-accent); border: 1px solid var(--c-accent);';
                badgeText = '✓ Fuldt valideret';
                badgeTooltip = `Alle ${actualTotalCount} punkter er valideret\n${statusParts.join(' | ')}`;
              } else if (isPartiallyValidated) {
                badgeColor = 'background: var(--c-bg-2); color: var(--c-primary); border: 1px solid var(--c-primary);';
                badgeText = `⚠ Delvist (${validatedCount}/${actualTotalCount})`;
                badgeTooltip = `Oversigt over hvad der er valideret:\n\n${statusParts.join('\n')}`;
              } else if (actualTotalCount > 0) {
                badgeColor = 'background: var(--c-surface-muted); color: var(--c-primary); border: 1px solid var(--c-primary);';
                badgeText = '⚠ Ikke valideret';
                badgeTooltip = `Oversigt over hvad der er valideret:\n\n${statusParts.join('\n')}`;
              } else {
                badgeColor = 'background: var(--c-surface-muted); color: var(--c-text-muted); border: 1px solid var(--c-border);';
                badgeText = '– Ingen validering';
                badgeTooltip = 'Dette krav har ingen validerbare punkter';
              }
              
              valBadge.style.cssText = `
                display: inline-flex; 
                align-items: center; 
                gap: 4px; 
                padding: 3px 8px; 
                border-radius: 12px; 
                font-size: 11px; 
                font-weight: 600; 
                margin-left: 8px;
                cursor: help;
                white-space: pre-line;
                ${badgeColor}
              `;
              valBadge.innerHTML = badgeText;
              valBadge.setAttribute('data-tip', badgeTooltip);
              gMeta.appendChild(valBadge);
              gMeta.appendChild(badge);
              
              gHeader.appendChild(gMeta);
              const gActions = document.createElement('div');
              gActions.className = 'krav-actions';
              gHeader.appendChild(gActions);
              currentGroupWrap.appendChild(gHeader);

              currentGroupBody = document.createElement('div');
              currentGroupWrap.appendChild(currentGroupBody);
              body.appendChild(currentGroupWrap);

              // reset group-local heading state
              lastUnderUnderInGroup = null;
              lastMiniInGroup = null;
              dimAnchorInGroup = null;
              lastUnderUnderHeadingEl = null;
              lastMiniHeadingEl = null;
            }

            if (!currentGroupBody) continue;

            // Under-undertitel + mini (inserted inside the Krav_id group so it can appear between checklist segments)
            const underUnder = row.underundertitle || '';
            const mini = row.minititle || '';

            if (underUnder !== lastUnderUnderInGroup && underUnder) {
              const uuEl = document.createElement('div');
              uuEl.className = 'krav-subsubtitle';
              uuEl.textContent = underUnder;
              const pIcon = createParaIcon(row.paragrafUnderUnderTitle);
              if (pIcon) uuEl.appendChild(pIcon);
              currentGroupBody.appendChild(uuEl);
              lastUnderUnderInGroup = underUnder;
              lastMiniInGroup = null;
              dimAnchorInGroup = uuEl;
              lastUnderUnderHeadingEl = uuEl;
              lastMiniHeadingEl = null;
            } else if (underUnder !== lastUnderUnderInGroup) {
              lastUnderUnderInGroup = underUnder;
              lastMiniInGroup = null;
              dimAnchorInGroup = null;
              lastUnderUnderHeadingEl = null;
              lastMiniHeadingEl = null;
            }

            if (mini !== lastMiniInGroup && mini) {
              const mEl = document.createElement('div');
              mEl.className = 'krav-mini';
              mEl.textContent = mini;
              currentGroupBody.appendChild(mEl);
              lastMiniInGroup = mini;
              if (!dimAnchorInGroup) dimAnchorInGroup = mEl;
              lastMiniHeadingEl = mEl;
            } else if (mini !== lastMiniInGroup) {
              lastMiniInGroup = mini;
              if (!mini) dimAnchorInGroup = null;
              if (!mini) lastMiniHeadingEl = null;
            }

            // Optional description (placed immediately above this row's checklist)
            if (row.beskrivelse) {
              const d = document.createElement('div');
              d.className = 'krav-desc';
              
              // Check validation status for beskrivelse
              const kravValidation = getKravValidationRecord(row.kravId);
              const isValidated = kravBeskrivelseValidated(kravValidation);
              
              const validationBadge = document.createElement('span');
              validationBadge.style.cssText = `
                display: inline-flex;
                align-items: center;
                gap: 4px;
                padding: 2px 8px;
                border-radius: 12px;
                font-size: 11px;
                font-weight: 600;
                margin-left: 8px;
                ${isValidated 
                  ? 'background: var(--c-bg-2); color: var(--c-accent); border: 1px solid var(--c-accent);' 
                  : 'background: var(--c-surface-muted); color: var(--c-primary); border: 1px solid var(--c-primary);'}
              `;
              validationBadge.innerHTML = isValidated ? '✓' : '✗ Ikke valideret';
              validationBadge.setAttribute('title', isValidated 
                ? 'Beskrivelsen er valideret af brandrådgiver' 
                : 'Beskrivelsen er ikke valideret');
              
              d.innerHTML = `<div class="text">${multilineHtml(row.beskrivelse)}</div>`;
              d.insertBefore(validationBadge, d.firstChild);
              currentGroupBody.appendChild(d);
            }

            // Segment actions: keep spacing tight.
            // Place '?' and viewer buttons on the SAME LINE as the nearest heading (right-aligned),
            // so we don't create an extra "actions" line above the checklist.
            const figures = Array.isArray(row.figures) ? row.figures : [];
            const tables = Array.isArray(row.tables) ? row.tables : [];
            const hasViewerButtons = (figures.length || tables.length);
            const hasDim = !!norm(row.dim);

            const makeDimIcon = () => {
              const q = document.createElement('span');
              q.className = 'q-icon q-icon-big';
              q.textContent = '?';
              q.setAttribute('data-dim', decodeGorulesString(row.dim));
              q.setAttribute('data-dim-title', row.kravId);
              q.setAttribute('tabindex', '0');
              return q;
            };

            if (hasViewerButtons || hasDim) {
              const anchorEl = lastMiniHeadingEl || lastUnderUnderHeadingEl || lastUnderHeadingEl || null;
              const wrap = ensureHeadingActions(anchorEl);
              if (wrap) {
                if (hasDim && !wrap.querySelector('.q-icon')) {
                  wrap.appendChild(makeDimIcon());
                }

                const anchorKey = (row.minititle || row.underundertitle || row.undertitle || row.title || '').trim();

                if (figures.length && !wrap.querySelector('[data-krav-action="figure"]')) {
                  const btn = createViewerButton('figure', figures, `${row.kravId}::${anchorKey}::figure`, null);
                  if (btn) { btn.setAttribute('data-krav-action', 'figure'); wrap.appendChild(btn); }
                }
                if (tables.length && !wrap.querySelector('[data-krav-action="table"]')) {
                  const btn = createViewerButton('table', tables, `${row.kravId}::${anchorKey}::table`, null);
                  if (btn) { btn.setAttribute('data-krav-action', 'table'); wrap.appendChild(btn); }
                }
              }
            }

            // Checklist items
            if (row.bullets && row.bullets.length) {
              const ul = document.createElement('ul');
              ul.className = 'krav-checklist';
              
              // Get validation status for this krav
              const kravValidation = getKravValidationRecord(row.kravId);

              const splitKravIdPrefix = (rawText) => {
                const s = String(rawText || '').trim();
                const m = s.match(/^\s*(K-\d+(?:-\d+){1,4})\s*:\s*(.*)$/i);
                if (m) return { id: String(m[1] || '').trim(), text: String(m[2] || '').trim() };
                return { id: '', text: s };
              };
              
              for (let idx = 0; idx < row.bullets.length; idx++) {
                const b = row.bullets[idx];
                const li = document.createElement('li');
                li.className = 'krav-check';
                const topRow = document.createElement('div');
                topRow.className = 'krav-check-top';
                const leftC = document.createElement('div');
                leftC.className = 'krav-check-left';
                const rightC = document.createElement('div');
                rightC.className = 'krav-check-right';
                const key = makeCheckKey(row.kravId, b);

                const okCb = document.createElement('input');
                okCb.type = 'checkbox';
                okCb.className = 'krav-ok-cb';
                okCb.setAttribute('data-krav-ok', 'true');
                okCb.setAttribute('data-krav-key', key);
                okCb.checked = !!okState[key];
                okCb.title = 'Overholdt';

                const docBtn = document.createElement('button');
                docBtn.type = 'button';
                docBtn.className = 'krav-doc-btn';
                docBtn.setAttribute('data-krav-key', key);
                docBtn.textContent = isDocumented(key) ? 'Dokumenteret' : 'Mangler dokumentation';
                docBtn.classList.toggle('has-text', isDocumented(key));
                rightC.appendChild(docBtn);

                const exclBtn = document.createElement('button');
                exclBtn.type = 'button';
                exclBtn.className = 'krav-exclude-btn';
                exclBtn.textContent = '×';
                exclBtn.setAttribute('aria-label', 'Ikke relevant');
                exclBtn.title = 'Hvis kravet ikke er relevant for dit projekt, kan det fravælges her.';
                li.appendChild(exclBtn);

                let docPanel = null;
                const ensureDocPanel = () => {
                  if (docPanel) return docPanel;
                  docPanel = document.createElement('div');
                  docPanel.className = 'krav-doc-panel';
                  docPanel.setAttribute('data-doc-key', key);

                  const docLabel = document.createElement('label');
                  docLabel.textContent = 'Dokumentation (valgfri)';

                  const docArea = document.createElement('textarea');
                  docArea.setAttribute('spellcheck', 'false');
                  docArea.setAttribute('autocorrect', 'off');
                  docArea.setAttribute('autocapitalize', 'off');
                  docArea.placeholder = 'Skriv kort hvordan kravet er håndteret (hvis bilag ikke er nødvendige).';
                  docArea.value = String(noteState[key] || '');
                  docArea.addEventListener('input', () => {
                    noteState[key] = String(docArea.value || '');
                    updateSingleDocStatus(key);
                  });

                  const bilagInfo = document.createElement('div');
                  bilagInfo.className = 'krav-doc-bilag';
                  bilagInfo.setAttribute('data-krav-key', key);

                  docPanel.appendChild(docLabel);
                  docPanel.appendChild(docArea);
                  docPanel.appendChild(bilagInfo);
                  docPanel.__textarea = docArea;
                  li.appendChild(docPanel);
                  updateSingleDocStatus(key);
                  return docPanel;
                };

                docBtn.addEventListener('click', (e) => {
                  e.stopPropagation();
                  if (!!excludedState[key]) return; // excluded
                  const panel = ensureDocPanel();
                  panel.classList.toggle('open');
                  if (panel.classList.contains('open')) {
                    try { panel.__textarea && panel.__textarea.focus(); } catch(_) {}
                  }
                });

                const applyExcludedUi = (excluded) => {
                  if (excluded) {
                    li.classList.add('excluded');
                    try { docBtn.disabled = true; } catch(_) {}
                    try { okCb.disabled = true; } catch(_) {}
                    try { okCb.checked = false; okState[key] = false; } catch(_) {}
                    try { docPanel && docPanel.classList.remove('open'); } catch(_) {}
                  } else {
                    li.classList.remove('excluded');
                    try { docBtn.disabled = false; } catch(_) {}
                    try { okCb.disabled = false; } catch(_) {}
                  }
                };

                const applyOkUi = (ok) => {
                  li.classList.toggle('ok', !!ok);
                };
                applyExcludedUi(!!excludedState[key]);
                applyOkUi(!!okState[key]);

                okCb.addEventListener('change', () => {
                  okState[key] = !!okCb.checked;
                  applyOkUi(!!okState[key]);
                });

                exclBtn.addEventListener('click', (e) => {
                  e.stopPropagation();
                  excludedState[key] = !excludedState[key];
                  applyExcludedUi(!!excludedState[key]);
                });
                const txt = document.createElement('div');
                txt.className = 'krav-check-text';
                const split = splitKravIdPrefix(b);
                txt.innerHTML = multilineHtml(split.text || b);
                if (split.id) {
                  const idEl = document.createElement('span');
                  idEl.className = 'krav-item-id';
                  idEl.textContent = split.id;
                  txt.appendChild(idEl);
                }
                
                // Add validation badge for this checklist item
                const globalIdx = checklistOffsetInGroup + idx;
                const isValidated = kravChecklistTextValidated(kravValidation, b, globalIdx);
                const validationBadge = document.createElement('span');
                validationBadge.style.cssText = `
                  display: inline-flex;
                  align-items: center;
                  gap: 4px;
                  padding: 2px 8px;
                  border-radius: 12px;
                  font-size: 11px;
                  font-weight: 600;
                  margin-left: 8px;
                  ${isValidated 
                    ? 'background: var(--c-bg-2); color: var(--c-accent); border: 1px solid var(--c-accent);' 
                    : 'background: var(--c-surface-muted); color: var(--c-primary); border: 1px solid var(--c-primary);'}
                `;
                validationBadge.innerHTML = isValidated ? '✓' : '✗';
                validationBadge.setAttribute('title', isValidated 
                  ? 'Dette punkt er valideret af brandrådgiver' 
                  : 'Dette punkt er ikke valideret');
                
                leftC.appendChild(okCb);
                leftC.appendChild(txt);
                leftC.appendChild(validationBadge);
                topRow.appendChild(leftC);
                topRow.appendChild(rightC);
                li.appendChild(topRow);
                ul.appendChild(li);
              }
              checklistOffsetInGroup += row.bullets.length;
              currentGroupBody.appendChild(ul);
            }
          }

          block.appendChild(body);
          frag.appendChild(block);

          await yieldUi();
        }

        container.appendChild(frag);
        
        // Mark requirements as viewed for progress tracking
        const idx = getActiveSectionIndex();
        sectionsState.progress[idx] = { ...(sectionsState.progress[idx]||{}), requirementsViewed: true };
        renderSectionTabs();
        
      } catch (error) {
        if (error && error.name === 'AbortError') {
          return;
        }
        container.innerHTML = `
          <div style="text-align: center; padding: 48px; color: var(--neutral-400);">
            <div style="font-size: 48px; margin-bottom: 16px;">⚠️</div>
            <div>Kunne ikke indlæse krav fra backend API</div>
            <div style="margin-top: 12px; color: var(--c-error); font-size: 13px;">${error.message}</div>
          </div>
        `;
      }
    }

    // ========== LEGACY: Old requirements.json loader (kept for reference) ==========
    async function generateRequirementsLegacy(bilag, brandklasse, evaluation) {
      window.__requirementsCache = window.__requirementsCache || { data: null, loaded: false, error: null };
      async function loadRequirements(){
        const cache = window.__requirementsCache;
        if (cache.loaded && cache.data) return cache.data;
        try {
          const resp = await fetch('requirements.json');
          if (!resp.ok) throw new Error('Kan ikke hente requirements.json');
          const data = await resp.json();
          cache.data = data; cache.loaded = true; cache.error = null;
          return data;
        } catch (e){
          cache.error = e.message; cache.loaded = true; cache.data = null;
          return null;
        }
      }

      const reqData = await loadRequirements();
      if (!reqData){
        container.innerHTML = `
          <div style="text-align: center; padding: 48px; color: var(--neutral-400);">
            <div style="font-size: 48px; margin-bottom: 16px;">⚠️</div>
            <div>Kunne ikke indlæse krav (requirements.json). Prøv at genindlæse siden.</div>
          </div>
        `;
        return;
      }

      // Support both numeric keys and descriptive keys like Bilag1/BK1
      const bilagKeyNumeric = reqData[String(bilag)] || reqData[bilag];
      const bilagKeyDescriptive = reqData[`Bilag${bilag}`];
      const bkKeyNumeric = String(brandklasse);
      const bkKeyDescriptive = `BK${brandklasse}`;
      let requirements = null;
      if (bilagKeyDescriptive && (bilagKeyDescriptive[bkKeyDescriptive] || bilagKeyDescriptive[bkKeyNumeric])){
        requirements = bilagKeyDescriptive[bkKeyDescriptive] || bilagKeyDescriptive[bkKeyNumeric];
      } else if (bilagKeyNumeric && (bilagKeyNumeric[bkKeyNumeric] || bilagKeyNumeric[bkKeyDescriptive])){
        requirements = bilagKeyNumeric[bkKeyNumeric] || bilagKeyNumeric[bkKeyDescriptive];
      }

      // Merge in any Bilag-level common requirements, if provided, so you can define shared items once
      // Supported keys: "common", "Common", "AlleBK"
      const commonSets = [];
      const pushCommon = (obj) => {
        if (!obj || typeof obj !== 'object') return;
        const keys = ["common", "Common", "AlleBK"];
        for (const k of keys){
          if (Array.isArray(obj[k])) commonSets.push(obj[k]);
        }
      };
      pushCommon(bilagKeyDescriptive);
      pushCommon(bilagKeyNumeric);
      if (requirements && commonSets.length){
        // Prepend common categories so they appear first
        requirements = [...commonSets.flat(), ...requirements];
      }
      
      if (!requirements) {
        container.innerHTML = `
          <div style="text-align: center; padding: 48px; color: var(--neutral-400);">
            <div style="font-size: 48px; margin-bottom: 16px;">🚧</div>
            <div>Krav for ${formatBilagLabel(bilag)} - Brandklasse ${brandklasse} er ikke implementeret endnu</div>
          </div>
        `;
        return;
      }
      
      // Build HTML for requirements
      let html = '';
      requirements.forEach((category, idx) => {
        const categoryId = `req-cat-${idx}`;
        const openClass = (prevOpen[idx] === true || (idx === 0 && (!prevOpen.length))) ? 'open' : '';
        
        let itemsHtml = '';
        let checkedCount = 0;
        let totalCheckable = 0;

        // Gate state store (persisted per category label)
        const gateStoreKey = (category.category || '').toLowerCase().replace(/\s+/g,'_');
        const getGateState = (flag) => {
          try {
            const raw = sessionStorage.getItem('reqGateState') || '{}';
            const obj = JSON.parse(raw);
            return !!(obj[flag]);
          } catch(_) { return false; }
        };
        const setGateState = (flag, val) => {
          try {
            const raw = sessionStorage.getItem('reqGateState') || '{}';
            const obj = JSON.parse(raw);
            obj[flag] = !!val;
            sessionStorage.setItem('reqGateState', JSON.stringify(obj));
          } catch(_) {}
        };
        
        // Helper: evaluate condition string or function
        const evalCondition = (cond, val) => {
          if (typeof cond === 'function') return cond(val);
          if (typeof cond === 'string'){
            // very small safe evaluator for patterns like "val <= 600", "val > 3"
            // Only allow operators: <=, >=, <, >, ==, != and numeric RHS
            const m = cond.trim().match(/^val\s*(<=|>=|<|>|==|!=)\s*(-?\d+(?:\.\d+)?)$/);
            if (!m) return false;
            const op = m[1]; const rhs = Number(m[2]);
            // Normalize left value to number when possible
            const left = (typeof val === 'number') ? val : (typeof val === 'string' ? Number(val) : Number(val?.value ?? val));
            switch(op){
              case '<=': return left <= rhs;
              case '>=': return left >= rhs;
              case '<': return left < rhs;
              case '>': return left > rhs;
              case '==': return left === rhs;
              case '!=': return left !== rhs;
              default: return false;
            }
          }
          return false;
        };

        // Helper: robustly resolve a field value, preferring evaluated outputs.
        const resolveFieldValue = (field) => {
          // Prefer evaluation.field.value, then evaluation.field, then currentInput[field]
          let v = undefined;
          if (evaluation && evaluation[field] !== undefined) {
            const ef = evaluation[field];
            v = (ef && typeof ef === 'object' && 'value' in ef) ? ef.value : ef;
          }
          if (v === undefined || v === null) v = currentInput[field];
          // Normalize common string formats like "RK1", "AK4", "1", "4"
          if (typeof v === 'string') {
            const digits = v.match(/\d+/);
            if (digits) return Number(digits[0]);
            const asNum = Number(v);
            if (!Number.isNaN(asNum)) return asNum;
          }
          // If object with value
          if (v && typeof v === 'object' && 'value' in v) return v.value;
          return v;
        };

        const currentInput = (typeof buildJsonFromForm === 'function') ? buildJsonFromForm() : {};
        // Detect gate flags and current states (supports multiple gates per category)
        const gateItems = category.items.filter(it => it.status === 'gate' && it.flag);
        const gateStates = {};
        gateItems.forEach(g => { gateStates[g.flag] = getGateState(g.flag); });

        category.items.forEach((item, iIdx) => {
          // Inline rendering for gate items respecting original order and gating dependencies
          if (item.status === 'gate' && item.flag) {
            const flag = item.flag;
            const enabled = !!gateStates[flag];
            // Apply gating to gate items themselves (supports requiresFlag/requiresAny/requiresAll)
            let gatedOff = false;
            if (item.requiresFlag) {
              if (Array.isArray(item.requiresFlag)) {
                gatedOff = !item.requiresFlag.every(f => gateStates[f]);
              } else {
                gatedOff = !gateStates[item.requiresFlag];
              }
            } else if (Array.isArray(item.requiresAny)) {
              gatedOff = !item.requiresAny.some(f => gateStates[f]);
            } else if (Array.isArray(item.requiresAll)) {
              gatedOff = !item.requiresAll.every(f => gateStates[f]);
            }
            if (gatedOff) { return; }

            if (!enabled) {
              itemsHtml += `
                <div class="req-item">
                  <div class="req-status-icon" style="color:var(--brand-slate);">❓</div>
                  <div class="req-content" style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
                    <div>
                      <div class="req-title" id="gate-title-${categoryId}-${flag}">${item.title}</div>
                      <div class="req-description">${item.description || ''}</div>
                    </div>
                    <div style="margin-top:0; display:flex; align-items:center; gap:16px;">
                      <button id="gate-yes-${categoryId}-${flag}" class="btn-primary" style="padding:8px 16px; font-size:14px;">${item.labelOn || 'Ja'}</button>
                      <button id="gate-no-${categoryId}-${flag}" class="btn-secondary" style="padding:8px 16px; font-size:14px;">${item.labelOff || 'Nej'}</button>
                    </div>
                  </div>
                </div>
              `;
            }
            return;
          }
          let statusIcon = 'ℹ️';
          let statusClass = '';
          let valueBadge = '';

          // Conditional gating: support requiresFlag (string), requiresAny (array), requiresAll (array)
          let gatedOff = false;
          if (item.requiresFlag) {
            if (Array.isArray(item.requiresFlag)) {
              // Backward-compat: treat array as requiresAll
              gatedOff = !item.requiresFlag.every(f => gateStates[f]);
            } else {
              gatedOff = !gateStates[item.requiresFlag];
            }
          } else if (Array.isArray(item.requiresAny)) {
            gatedOff = !item.requiresAny.some(f => gateStates[f]);
          } else if (Array.isArray(item.requiresAll)) {
            gatedOff = !item.requiresAll.every(f => gateStates[f]);
          }
          if (gatedOff) { return; }
          
          if (item.status === 'check' && item.checkField && item.checkCondition) {
            totalCheckable++;
            // Prefer evaluated outputs and normalize to numeric when applicable
            const fieldValue = resolveFieldValue(item.checkField);
            if (fieldValue !== undefined && evalCondition(item.checkCondition, fieldValue)) {
              statusIcon = '✓';
              statusClass = 'style="color: var(--status-ok-border);"';
              checkedCount++;
            } else {
              statusIcon = '⚠';
              statusClass = 'style="color: var(--status-warn-text);"';
            }
            // Show current input value when relevant
            const showVal = item.showValue === true || item.showValue === 'auto';
            const displayKey = item.displayField || item.checkField;
            const displayVal = resolveFieldValue(displayKey);
            if (showVal && displayVal !== undefined && displayVal !== null) {
              const prefix = item.valuePrefix || '';
              const suffix = item.valueSuffix || '';
              valueBadge = `<span style="margin-left:8px; font-size:12px; background:var(--badge-info-bg); color:var(--badge-info-text); padding:2px 6px; border-radius:10px;">${prefix}${displayVal}${suffix}</span>`;
            }
          } else if (item.status === 'advarsel') {
            // Warning items are highlighted but not checkable and do not affect counts
            statusIcon = '⚠';
            statusClass = 'style="color: var(--status-warn-text);"';
            const contentId = `req-content-${categoryId}-${idx}-${iIdx}`;
            itemsHtml += `
              <div class="req-item" style="background:var(--status-warn-bg); border:1px solid var(--status-warn-border); padding:12px; border-radius:8px;">
                <div class="req-status-icon" ${statusClass}>${statusIcon}</div>
                <div class="req-content" id="${contentId}">
                  <div class="req-title">${item.title}</div>
                  <div class="req-description">${item.description || ''}</div>
                  <div class="req-reference">${item.reference || ''}</div>
                </div>
              </div>
            `;
            return;
          } else if (item.status === 'info') {
            // Info items can be marked as fulfilled by the user
            totalCheckable++;
            // Optional value badge (shown next to title on the left)
            const displayKey = item.displayField;
            const displayVal = displayKey ? resolveFieldValue(displayKey) : undefined;
            if (displayVal !== undefined && displayVal !== null) {
              const prefix = item.valuePrefix || '';
              const suffix = item.valueSuffix || '';
              valueBadge = `<span style="margin-left:8px; font-size:12px; background:var(--badge-neutral-bg); color:var(--badge-neutral-text); padding:2px 6px; border-radius:10px;">${prefix}${displayVal}${suffix}</span>`;
            }
            // Persist per session
            const infoKey = `${bilag}|${brandklasse}|${category.category}|${item.title}|${item.reference || ''}`;
            let infoStore = {};
            try { infoStore = JSON.parse(sessionStorage.getItem('reqInfoFulfilled') || '{}'); } catch(_) {}
            const infoChecked = !!infoStore[infoKey];
            if (infoChecked) {
              checkedCount++;
              statusClass = 'style="color: var(--status-ok-border);"';
            }
            // Choose icon based on checked state
            statusIcon = infoChecked ? '✓' : 'ℹ️';

            // Build a larger, right-aligned control for Overholdt
            const controlStyles = infoChecked
              ? 'padding:8px 14px; font-size:14px; color:var(--status-ok-text); border:1px solid var(--status-ok-border); border-radius:9999px; background:var(--status-ok-bg); display:inline-flex; align-items:center; gap:8px;'
              : 'padding:8px 14px; font-size:14px; color:var(--status-ok-text); border:1px solid var(--status-ok-border); border-radius:9999px; background:var(--c-bg-2); display:inline-flex; align-items:center; gap:8px;';
            const actionControl = `
              <label style="${controlStyles}">
                <input type="checkbox" style="width:18px; height:18px;" data-info-key="${encodeURIComponent(infoKey)}" ${infoChecked ? 'checked' : ''} />
                <span>Overholdt</span>
              </label>
            `;

            // Compose the item with right-aligned control
            const contentId = `req-content-${categoryId}-${idx}-${iIdx}`;
            const strikeStyle = (typeof sessionStorage !== 'undefined') ? 'text-decoration-color:#22c55e;' : '';
            itemsHtml += `
              <div class="req-item">
                <div class="req-status-icon" ${statusClass}>${statusIcon}</div>
                <div class="req-content" id="${contentId}" style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
                  <div>
                    <div class="req-title" style="${strikeStyle}">${item.title} ${valueBadge}</div>
                    <div class="req-description">${item.description}</div>
                    <div class="req-reference">${item.reference}</div>
                  </div>
                  ${actionControl}
                </div>
              </div>
            `;
            return;
          }
          
          const contentId = `req-content-${categoryId}-${idx}-${iIdx}`;
          const strikeStyle = (item.status === 'info' && (typeof sessionStorage !== 'undefined')) ? 'text-decoration-color:#22c55e;' : '';
          itemsHtml += `
            <div class="req-item">
              <div class="req-status-icon" ${statusClass}>${statusIcon}</div>
              <div class="req-content" id="${contentId}">
                <div class="req-title" style="${strikeStyle}">${item.title} ${valueBadge}</div>
                <div class="req-description">${item.description}</div>
                <div class="req-reference">${item.reference}</div>
              </div>
            </div>
          `;
        });
        
        let statusBadge = '';
        if (totalCheckable > 0) {
          if (checkedCount === 0) {
            statusBadge = `<span class="status-badge" style="background: var(--status-bad-bg); color: var(--status-bad-text);">${checkedCount}/${totalCheckable} opfyldt</span>`;
          } else if (checkedCount === totalCheckable) {
            statusBadge = `<span class="status-badge" style="background: var(--status-ok-bg); color: var(--status-ok-text);">${checkedCount}/${totalCheckable} opfyldt</span>`;
          } else {
            statusBadge = `<span class="status-badge" style="background: var(--status-warn-bg); color: var(--status-warn-text);">${checkedCount}/${totalCheckable} opfyldt</span>`;
          }
        }
        
        const categoryLabel = String(category.category || '').trim();
        const docsForCategory = categoryLabel ? getKravCategoryDocs(activeSectionIdx, categoryLabel) : [];
        const docsCount = Array.isArray(docsForCategory) ? docsForCategory.length : 0;
        const docsBadge = docsCount > 0
          ? `<span class="status-badge" style="background:var(--badge-info-bg); color:var(--badge-info-text);">📎 ${docsCount}</span>`
          : '';

        const docsListHtml = (docsCount > 0)
          ? docsForCategory.map(d => {
              const name = escapeHtml(d?.name || 'fil');
              const caption = escapeHtml(d?.caption || '');
              const description = escapeHtml(d?.description || '');
              const id = escapeHtml(d?.id || '');
              return `
                <div class="cat-doc-item" data-doc-id="${id}">
                  <div class="cat-doc-item-top">
                    <div class="cat-doc-name">${name}</div>
                    <button type="button" class="btn-secondary cat-doc-remove-btn" data-doc-id="${id}" data-category-label="${escapeHtml(categoryLabel)}" style="padding:6px 10px;">Fjern</button>
                  </div>
                  <div class="cat-doc-fields">
                    <label class="cat-doc-field">
                      <div class="cat-doc-field-label">Billedtekst</div>
                      <input type="text" class="cat-doc-input" spellcheck="false" autocorrect="off" autocapitalize="off" data-doc-field="caption" data-doc-id="${id}" data-category-label="${escapeHtml(categoryLabel)}" value="${caption}" placeholder="fx Figur 1: Placering af brandvæg" />
                    </label>
                    <label class="cat-doc-field">
                      <div class="cat-doc-field-label">Kort forklaring (valgfri)</div>
                      <textarea class="cat-doc-textarea" spellcheck="false" autocorrect="off" autocapitalize="off" data-doc-field="description" data-doc-id="${id}" data-category-label="${escapeHtml(categoryLabel)}" rows="2" placeholder="Hvad viser dokumentet/figuren – og hvorfor er det relevant?">${description}</textarea>
                    </label>
                  </div>
                </div>
              `;
            }).join('')
          : `<div class="cat-doc-empty">Ingen dokumentation tilføjet til denne kravgruppe endnu.</div>`;

        const docsBlockHtml = categoryLabel ? `
          <div class="cat-docs" data-category-label="${escapeHtml(categoryLabel)}">
            <div class="cat-docs-header">
              <div>
                <div class="cat-docs-title">Dokumentation til denne kravgruppe</div>
                <div class="cat-docs-sub">Tilføj relevante bilag, samt billedtekst og evt. en kort forklaring. Det kommer med i dokumentationen i trin 4.</div>
              </div>
              <div class="cat-docs-actions">
                <input class="cat-doc-file" type="file" multiple data-category-label="${escapeHtml(categoryLabel)}" style="display:none" />
                <button type="button" class="btn-secondary cat-doc-upload-btn" data-category-label="${escapeHtml(categoryLabel)}" style="padding:8px 12px;">Tilføj bilag</button>
              </div>
            </div>
            <div class="cat-docs-list">${docsListHtml}</div>
          </div>
        ` : '';

        html += `
          <div class="req-category ${openClass}">
            <div class="req-category-header">
              <span class="icon">${category.category.split(' ')[0]}</span>
              <span>${category.category.substring(category.category.indexOf(' ') + 1)}</span>
              ${statusBadge}
              ${docsBadge}
            </div>
            <div class="req-category-content">
              ${docsBlockHtml}
              ${itemsHtml}
            </div>
          </div>
        `;

        // Wire gate interactions for all gate items
        setTimeout(() => {
          gateItems.forEach(gateItem => {
            const flag = gateItem.flag;
            const yesBtn = document.getElementById(`gate-yes-${categoryId}-${flag}`);
            const noBtn = document.getElementById(`gate-no-${categoryId}-${flag}`);
            const titleEl = document.getElementById(`gate-title-${categoryId}-${flag}`);
            if (yesBtn) {
              yesBtn.addEventListener('click', () => {
                setGateState(flag, true);
                generateRequirements(bilag, brandklasse, evaluation);
              });
            }
            if (noBtn) {
              noBtn.addEventListener('click', () => {
                setGateState(flag, false);
                if (titleEl) {
                  titleEl.style.textDecoration = 'line-through';
                  titleEl.style.color = '#22c55e';
                }
              });
            }
          });
        }, 0);
      });
      
      container.innerHTML = html;
      // Wire info checkbox handlers (post-render)
      container.querySelectorAll('input[data-info-key]').forEach(cb => {
        cb.addEventListener('change', (e) => {
          const k = decodeURIComponent(e.target.getAttribute('data-info-key'));
          let store = {};
          try { store = JSON.parse(sessionStorage.getItem('reqInfoFulfilled') || '{}'); } catch(_) {}
          store[k] = !!e.target.checked;
          try { sessionStorage.setItem('reqInfoFulfilled', JSON.stringify(store)); } catch(_) {}
          // Re-generate to refresh counts and visuals
          generateRequirements(bilag, brandklasse, evaluation);
        });
      });

      // Make accordion toggle only when clicking the header
      container.querySelectorAll('.req-category').forEach(cat => {
        const header = cat.querySelector('.req-category-header');
        if (header) {
          header.addEventListener('click', (e) => {
            e.stopPropagation();
            cat.classList.toggle('open');
          });
        }
      });

      // Step 3: per-category documentation uploads (delegated handlers; bind once)
      if (!container.__kravCategoryDocsBound) {
        container.__kravCategoryDocsBound = true;

        container.addEventListener('click', (e) => {
          const btn = e.target?.closest?.('.cat-doc-upload-btn');
          if (btn) {
            const label = btn.getAttribute('data-category-label') || '';
            const input = container.querySelector(`input.cat-doc-file[data-category-label="${CSS.escape(label)}"]`);
            if (input) input.click();
            return;
          }

          const rm = e.target?.closest?.('.cat-doc-remove-btn');
          if (rm) {
            const label = rm.getAttribute('data-category-label') || '';
            const docId = rm.getAttribute('data-doc-id') || '';
            removeKravCategoryDoc(getActiveSectionIndex(), label, docId);
            try {
              const sIdx = getActiveSectionIndex();
              const eval3 = sectionsState.evaluations[sIdx] || latestEvaluation;
              const bilagNow = getBilagValueFromEvaluation(eval3) || bilag;
              const bkNow = (eval3 && eval3.brandklasse?.value) ? eval3.brandklasse.value : brandklasse;
              generateRequirements(bilagNow, bkNow, eval3);
            } catch(_) {}
            return;
          }
        });

        container.addEventListener('change', async (e) => {
          const input = e.target?.closest?.('input.cat-doc-file');
          if (!input) return;
          const label = input.getAttribute('data-category-label') || '';
          const files = input.files;
          if (files && files.length > 0) {
            try {
              const arr = Array.from(files);
              const pdfs = arr.filter(f => f && ((String(f.type || '').toLowerCase() === 'application/pdf') || /\.pdf$/i.test(String(f.name || ''))));
              let finalFiles = arr;
              if (pdfs.length > 0) {
                const ok = confirm('PDF-bilag bliver konverteret til billede (side 1) for at kunne indgå i eksport. Fortsæt?');
                if (ok) {
                  finalFiles = [];
                  for (const f of arr) {
                    if (f && ((String(f.type || '').toLowerCase() === 'application/pdf') || /\.pdf$/i.test(String(f.name || '')))) {
                      try {
                        const img = await pdfFileToPngFile(f, { pageNumber: 1, scale: 2 });
                        finalFiles.push(img);
                      } catch(err) {
                        finalFiles.push(f);
                      }
                    } else {
                      finalFiles.push(f);
                    }
                  }
                }
              }

              addKravCategoryDocsFromFiles(getActiveSectionIndex(), label, finalFiles);
            } catch(_) {
              addKravCategoryDocsFromFiles(getActiveSectionIndex(), label, files);
            }
          }
          // reset input so selecting the same file again still triggers change
          try { input.value = ''; } catch(_) {}

          try {
            const sIdx = getActiveSectionIndex();
            const eval3 = sectionsState.evaluations[sIdx] || latestEvaluation;
            const bilagNow = getBilagValueFromEvaluation(eval3) || bilag;
            const bkNow = (eval3 && eval3.brandklasse?.value) ? eval3.brandklasse.value : brandklasse;
            generateRequirements(bilagNow, bkNow, eval3);
          } catch(_) {}
        });

        container.addEventListener('input', (e) => {
          const el = e.target;
          if (!el) return;
          const field = el.getAttribute('data-doc-field');
          if (field !== 'caption' && field !== 'description') return;
          const label = el.getAttribute('data-category-label') || '';
          const docId = el.getAttribute('data-doc-id') || '';
          updateKravCategoryDocField(getActiveSectionIndex(), label, docId, field, el.value);
        });
      }
    }

    // Accordion toggling
    document.querySelectorAll('.acc-header').forEach(h=>{
      h.addEventListener('click', ()=>{
        const item = h.parentElement; item.classList.toggle('open');
      });
    });

    // Upload handling
    const uploadArea = document.getElementById('upload-area');
    const fileInput = document.getElementById('file-input');
    const jsonTextarea = document.getElementById('json-textarea');
    const bygningstypeSelect = document.getElementById('fld_bygningstype');

    // Track fields the user has manually edited so we don't overwrite their choices.
    const userTouchedFields = new Set();
    const autoFilledFields = new Map(); // controlId -> last auto-filled value

    function markUserTouched(controlId){
      if (!controlId) return;
      userTouchedFields.add(String(controlId));
    }

    function getControl(controlId){
      try { return document.getElementById(controlId); } catch(_) { return null; }
    }

    function setControlValue(controlId, value){
      const el = getControl(controlId);
      if (!el) return false;
      try {
        if (el.tagName === 'SELECT') {
          const desired = String(value);
          // Only set if option exists (avoid leaving select in invalid state).
          const hasOpt = Array.from(el.options || []).some(o => String(o.value) === desired);
          if (!hasOpt) return false;
          el.value = desired;
        } else if (el.type === 'checkbox') {
          el.checked = !!value;
        } else {
          el.value = (value === null || value === undefined) ? '' : String(value);
        }
        autoFilledFields.set(controlId, (el.type === 'checkbox') ? String(!!el.checked) : String(el.value));
        // Trigger listeners that rely on change.
        try { el.dispatchEvent(new Event('change', { bubbles:true })); } catch(_) {}
        return true;
      } catch(_) {
        return false;
      }
    }

    function canAutofill(controlId){
      const id = String(controlId);
      if (!id) return false;
      if (!getControl(id)) return false;
      // If user has touched, never overwrite.
      if (userTouchedFields.has(id)) return false;
      return true;
    }

    function normalizeBygningstypeForDefaults(v){
      return String(v ?? '').trim().toLowerCase()
        .normalize('NFD')
        .replace(/\p{Diacritic}/gu, '')
        .replace(/æ/g, 'ae')
        .replace(/ø/g, 'oe')
        .replace(/å/g, 'aa')
        .replace(/\s+/g, ' ')
        .trim();
    }

    // Easy-to-edit defaults per bygningstype.
    // Write keys in a human-friendly form; we normalize them automatically.
    // Values are input keys (without fld_ prefix) -> desired value.
    const RAW_BYGNINGSTYPE_DEFAULTS = {
      // Example requested:
      'enfamiliehus': {
        overnatning: true,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 500,
      },

      'dobbelthus': {
        overnatning: true,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 500,
      },

      'rækkehus': {
        overnatning: true,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 500,
      },

      'kædehus': {
        overnatning: true,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 500,
      },

      'gruppehus': {
        overnatning: true,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 500,
      },

      'sommerhus': {
        overnatning: true,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 500,
      },

      'campinghytte': {
        overnatning: true,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 500,
      },

      'feriebolig': {
        overnatning: true,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 500,
      },

      'én bolig til helårsbeboelse': {
        overnatning: true,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 500,
      },
      'garage': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },

      'carport': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },

      'udhus': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },

      'skur': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 800,
      },

      'vaerksted': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 800,
      },
      'mindre bygning med kortvarigt personophold': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },

      'hoensehus': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },

      'drivhus': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },

      'overdaekket terrasse': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },

      'mindre bygning med kortvarigt personophold (sekundaer bebyggelse)': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },
      'butik': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },

      'klinik': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        brandbelastning_BA: 400,
      },
      'pavillonbyggerier': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        area_BA: 150,
        area_total: 150,
        antal_personer_BA: 50,
        direkte_udgange: true,
      },

      'forsamlings- og opholdsbygninger': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        area_BA: 150,
        area_total: 150,
        antal_personer_BA: 50,
        direkte_udgange: true,
      },

      'midlertidige undervisnings- og institutionsbygninger': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        area_BA: 150,
        area_total: 150,
        antal_personer_BA: 50,
        direkte_udgange: true,
      },

      'undervisnings- og aktivitetsbygninger': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        area_BA: 150,
        area_total: 150,
        antal_personer_BA: 50,
        direkte_udgange: true,
      },

      'kultur- og formidlingsbygninger': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        area_BA: 150,
        area_total: 150,
        antal_personer_BA: 50,
        direkte_udgange: true,
      },

      'servicebygninger med personophold': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        area_BA: 150,
        area_total: 150,
        antal_personer_BA: 50,
        direkte_udgange: true,
      },

      'café- og kioskbygninger med siddepladser': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        area_BA: 150,
        area_total: 150,
        antal_personer_BA: 50,
        direkte_udgange: true,
      },

      'sundheds- og socialbygninger': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        area_BA: 150,
        area_total: 150,
        antal_personer_BA: 50,
        direkte_udgange: true,
      },

      'forenings- og fritidsbygninger': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        area_BA: 150,
        area_total: 150,
        antal_personer_BA: 50,
        direkte_udgange: true,
      },
      'varmestue': {
        overnatning: false,
        kendskab_flugtveje: true,
        selvhjulpen: true,
        area_BA: 150,
        area_total: 150,
        antal_personer_BA: 50,
        direkte_udgange: true,
      }





      // Add more types here, e.g.
      // 'sommerhus': { overnatning: true, kendskab_flugtveje: true, selvhjulpen: true },
      // 'campinghytte': { overnatning: true, kendskab_flugtveje: true, selvhjulpen: true },
    };

    const BYGNINGSTYPE_DEFAULTS = Object.fromEntries(
      Object.entries(RAW_BYGNINGSTYPE_DEFAULTS)
        .map(([k, v]) => [normalizeBygningstypeForDefaults(k), v])
    );

    function applyDefaultsForBygningstype(){
      const raw = String(bygningstypeSelect?.value ?? '').trim();
      if (!raw) return;
      const key = normalizeBygningstypeForDefaults(raw);
      const defaults = BYGNINGSTYPE_DEFAULTS[key];
      if (!defaults) return;

      Object.entries(defaults).forEach(([fieldKey, val]) => {
        const controlId = `fld_${fieldKey}`;
        if (!canAutofill(controlId)) return;

        // Booleans are represented as select values "true"/"false".
        if (typeof val === 'boolean') {
          setControlValue(controlId, val ? 'true' : 'false');
        } else {
          setControlValue(controlId, val);
        }
      });
    }

    // Auto-sum: antal_etager_BA = over + under (but allow manual override).
    function applyAutoSumEtager(){
      const overId = 'fld_antal_etager_over_terraen_BA';
      const underId = 'fld_antal_etager_under_terraen_BA';
      const totalId = 'fld_antal_etager_BA';

      const over = asNum(overId);
      const under = asNum(underId);
      if (over === null && under === null) return;
      const sum = Number(over ?? 0) + Number(under ?? 0);

      const totalEl = getControl(totalId);
      if (!totalEl) return;

      const totalTouched = userTouchedFields.has(totalId);
      const current = asNum(totalId);
      const lastAuto = autoFilledFields.get(totalId);
      const currentStr = (totalEl.value ?? '').toString();

      // Fill if user hasn't touched total, OR if total still equals the last auto-filled value.
      const allow = (!totalTouched) || (lastAuto !== undefined && String(lastAuto) === currentStr);
      if (!allow) return;

      setControlValue(totalId, String(sum));
    }

    // Auto-fill standard heights:
    // - etage_hoejde_BA = 3.2m * (etager over terræn - 1)
    //   (gulvhøjde måles ved bunden af øverste etage: 1 etage => 0.0m, 2 etager => 3.2m, 3 etager => 6.4m)
    // - etage_dybde_BA = 3.2m * (etager under terræn)
    // Users can still override.
    function applyAutoEtageHoedeDybde(){
      const overId = 'fld_antal_etager_over_terraen_BA';
      const underId = 'fld_antal_etager_under_terraen_BA';
      const hoejdeId = 'fld_etage_hoejde_BA';
      const dybdeId = 'fld_etage_dybde_BA';

      const over = asNum(overId);
      const under = asNum(underId);

      const setIfAllowed = (targetId, nextValNum) => {
        const el = getControl(targetId);
        if (!el) return;
        const touched = userTouchedFields.has(targetId);
        const lastAuto = autoFilledFields.get(targetId);
        const currentStr = (el.value ?? '').toString();
        const allow = (!touched) || (lastAuto !== undefined && String(lastAuto) === currentStr);
        if (!allow) return;
        const nextStr = (nextValNum === null || nextValNum === undefined || !Number.isFinite(Number(nextValNum)))
          ? ''
          : String(Number(nextValNum).toFixed(1));
        setControlValue(targetId, nextStr);
      };

      if (over !== null) {
        const overFloors = Number(over);
        const effective = Number.isFinite(overFloors) ? Math.max(0, overFloors - 1) : null;
        setIfAllowed(hoejdeId, (effective === null) ? null : (effective * 3.2));
      }
      if (under !== null) setIfAllowed(dybdeId, Number(under) * 3.2);
    }

    // If overnatning is true, assume all personer overnatter by default.
    // Still allow manual override of antal_overnattende.
    function applyAutoOvernattendeFromPersoner(){
      const overnatningEl = getControl('fld_overnatning');
      if (!overnatningEl) return;
      const overnatningVal = String(overnatningEl.value ?? '').toLowerCase();
      const isOvernatning = (overnatningVal === 'true');
      if (!isOvernatning) return;

      const personer = asNum('fld_antal_personer_BA');
      if (personer === null) return;

      const targetId = 'fld_antal_overnattende';
      const targetEl = getControl(targetId);
      if (!targetEl) return;

      const touched = userTouchedFields.has(targetId);
      const lastAuto = autoFilledFields.get(targetId);
      const currentStr = (targetEl.value ?? '').toString();
      const allow = (!touched) || (lastAuto !== undefined && String(lastAuto) === currentStr);
      if (!allow) return;

      setControlValue(targetId, String(personer));
    }

    // If overnatning is false, assume 0 overnattende.
    // This runs on overnatning-change so it doesn't fight the user if they override afterwards.
    function applyAutoOvernattendeZeroWhenNoOvernatning(){
      const overnatningEl = getControl('fld_overnatning');
      if (!overnatningEl) return;
      const overnatningVal = String(overnatningEl.value ?? '').toLowerCase();
      const isNoOvernatning = (overnatningVal === 'false');
      if (!isNoOvernatning) return;
      const targetId = 'fld_antal_overnattende';
      const targetEl = getControl(targetId);
      if (!targetEl) return;
      setControlValue(targetId, '0');
    }

    // Fast-track controls
    const btnUploadJson = document.getElementById('btn-upload-json');
    const btnDownloadTemplate = document.getElementById('btn-download-template');
    const btnCopyCurrent = document.getElementById('btn-copy-current');
    const jsonAdvanced = document.getElementById('json-advanced');

    if (btnUploadJson) btnUploadJson.addEventListener('click', ()=> fileInput.click());

    // NOTE: The advanced JSON pane is intentionally not user-toggleable.

    function buildJsonTemplate(){
      // Include all known inputs + bilag extras. Use null/"" to signal "unknown".
      return {
        antal_etager_over_terraen_BA: null,
        antal_etager_under_terraen_BA: null,
        etage_hoejde_BA: null,
        etage_dybde_BA: null,
        etage_hoejde: null,
        antal_etager_BA: null,
        brandbelastning_BA: null,
        area_BA: null,
        area_total: null,
        bygningstype: "",

        med_erhvervssammenbygning: null,
        med_tilbygning: null,

        antal_personer_BA: null,
        antal_overnattende: null,
        overnatning: null,
        kendskab_flugtveje: null,
        selvhjulpen: null,
        fritstaaende: null,
        direkte_udgange: null,
        direkte_udgange_soverum: null,
        bygningsafsnit_i_RK4: null,
        antal_BA: null,
        antal_fravigelser_fra_praeaccepterede: null
      };
    }

    if (btnDownloadTemplate) btnDownloadTemplate.addEventListener('click', ()=>{
      const template = buildJsonTemplate();
      const blob = new Blob([JSON.stringify(template, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'input_template.json';
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=> URL.revokeObjectURL(url), 250);
    });

    function buildCurrentInputPayload(){
      try {
        // Copy should include the full input "list" (all known keys), not just filled values.
        const template = buildJsonTemplate();
        const merged = { ...template, ...canonicalizeInputData(buildJsonFromForm()), ...getActiveBilagExtras() };
        return merged ?? {};
      } catch (_) {
        return {};
      }
    }

    async function copyTextToClipboard(text){
      try {
        if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
          await navigator.clipboard.writeText(text);
          return true;
        }
      } catch (_) {}
      try {
        const ta = document.createElement('textarea');
        ta.value = String(text ?? '');
        ta.setAttribute('readonly', '');
        ta.style.position = 'fixed';
        ta.style.left = '-9999px';
        ta.style.top = '0';
        document.body.appendChild(ta);
        ta.select();
        ta.setSelectionRange(0, ta.value.length);
        const ok = document.execCommand('copy');
        ta.remove();
        return !!ok;
      } catch (_) {
        return false;
      }
    }

    if (btnCopyCurrent) btnCopyCurrent.addEventListener('click', async ()=>{
      const payload = buildCurrentInputPayload();
      const text = JSON.stringify(payload, null, 2);
      const ok = await copyTextToClipboard(text);
      const old = btnCopyCurrent.textContent;
      btnCopyCurrent.textContent = ok ? '✓' : '!';
      setTimeout(()=>{ try { btnCopyCurrent.textContent = old; } catch(_) {} }, 900);
    });

    if (uploadArea) {
      uploadArea.addEventListener('click', ()=> fileInput.click());
      uploadArea.addEventListener('dragover', (e)=>{ e.preventDefault(); });
      uploadArea.addEventListener('drop', (e)=>{ e.preventDefault(); handleFiles(e.dataTransfer.files); });
    }
    fileInput.addEventListener('change', (e)=> handleFiles(e.target.files));

    // Mark manual touches for specific controls we auto-fill.
    ['fld_overnatning','fld_kendskab_flugtveje','fld_selvhjulpen','fld_antal_personer_BA','fld_antal_overnattende','fld_antal_etager_over_terraen_BA','fld_antal_etager_under_terraen_BA','fld_antal_etager_BA','fld_etage_hoejde_BA','fld_etage_dybde_BA']
      .forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        el.addEventListener('input', (e)=>{ if (e && e.isTrusted === false) return; markUserTouched(id); });
        el.addEventListener('change', (e)=>{ if (e && e.isTrusted === false) return; markUserTouched(id); });
      });

    // When bygningstype changes: apply defaults, then auto-evaluate.
    bygningstypeSelect.addEventListener('change', ()=>{
      try { applyDefaultsForBygningstype(); } catch(_) {}
      updateStatus();
      scheduleEvaluate();
    });

    // When over/under etager changes: update total automatically (unless user overrode).
    ['fld_antal_etager_over_terraen_BA','fld_antal_etager_under_terraen_BA']
      .forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        el.addEventListener('input', ()=>{ try { applyAutoSumEtager(); applyAutoEtageHoedeDybde(); } catch(_) {} });
        el.addEventListener('change', ()=>{ try { applyAutoSumEtager(); applyAutoEtageHoedeDybde(); } catch(_) {} });
      });

    // When overnatning changes:
    // - If true: mirror antal_personer_BA into antal_overnattende
    // - If false: set antal_overnattende to 0
    {
      const el = document.getElementById('fld_overnatning');
      if (el) {
        el.addEventListener('input', ()=>{ try { applyAutoOvernattendeFromPersoner(); applyAutoOvernattendeZeroWhenNoOvernatning(); } catch(_) {} });
        el.addEventListener('change', ()=>{ try { applyAutoOvernattendeFromPersoner(); applyAutoOvernattendeZeroWhenNoOvernatning(); } catch(_) {} });
      }
    }

    // When person count changes, mirror only if overnatning is true.
    {
      const el = document.getElementById('fld_antal_personer_BA');
      if (el) {
        el.addEventListener('input', ()=>{ try { applyAutoOvernattendeFromPersoner(); } catch(_) {} });
        el.addEventListener('change', ()=>{ try { applyAutoOvernattendeFromPersoner(); } catch(_) {} });
      }
    }

    function handleFiles(files){
      const file = files[0];
      if(file){ const reader = new FileReader(); reader.onload = (e)=>{ jsonTextarea.value = e.target.result; jsonManualEdit = true; try { const obj = JSON.parse(jsonTextarea.value); syncingFromJson = true; updateFormFromJson(obj); } catch(_) {} finally { syncingFromJson = false; } updateStatus(); scheduleEvaluate(); }; reader.readAsText(file); }
    }

    // Populate bygningstype options from Brandklasse_Bestemmelse.json (fallback to defaults)
    async function populateBygningstypeOptions(){
      // Udvidet fallbackliste så upload JSON som "Dobbelthuse" m.fl. altid findes
      const simpleByggerier = [
        "pavillonbyggerier",
        "forsamlings- og opholdsbygninger",
        "Midlertidige undervisnings- og institutionsbygninger",
        "undervisnings- og aktivitetsbygninger",
        "kultur- og formidlingsbygninger",
        "servicebygninger med personophold",
        "café- og kioskbygninger med siddepladser",
        "sundheds- og socialbygninger",
        "forenings- og fritidsbygninger",
        "Varmestue"
      ];

      const fallback = [
        "Enfamiliehus",
        "Dobbelthus",
        "Rækkehus",
        "Kædehus",
        "Gruppehus",
        "Sommerhus",
        "Campinghytte",
        "Feriebolig",
        "Én bolig til helårsbeboelse",
        ...simpleByggerier
      ];

      // Categorization for dropdown optgroups.
      // Keep this in frontend (not in Brandklasse_Bestemmelse.json), so you can tweak grouping freely.
      const normalizeBygningstypeKey = (v) => {
        const s = String(v ?? '').trim().toLowerCase();
        const noDiacritics = s.normalize('NFD').replace(/\p{Diacritic}/gu, '');
        return noDiacritics
          .replace(/æ/g, 'ae')
          .replace(/ø/g, 'oe')
          .replace(/å/g, 'aa')
          .replace(/\s+/g, ' ')
          .trim();
      };

      const groupOrder = ['Beboelse', 'Simple byggerier', 'Sekundær bebyggelse', 'Erhverv', 'Andre'];

      const simpleKeys = new Set(simpleByggerier.map(v => normalizeBygningstypeKey(v)));

      const simpleCanonicalByKey = new Map(
        simpleByggerier.map(v => [normalizeBygningstypeKey(v), v])
      );

      const prettySimpleLabel = (v) => {
        const s = String(v ?? '').trim();
        if (!s) return s;
        return s.charAt(0).toUpperCase() + s.slice(1);
      };

      const categoryOverrides = new Map([
        // Beboelse
        ['enfamiliehus', 'Beboelse'],
        ['dobbelthus', 'Beboelse'],
        ['raekkehus', 'Beboelse'],
        ['kaedehus', 'Beboelse'],
        ['gruppehus', 'Beboelse'],
        ['sommerhus', 'Beboelse'],
        ['campinghytte', 'Beboelse'],
        ['feriebolig', 'Beboelse'],
        ['en bolig til heelaarsbeboelse', 'Beboelse'],

        // Sekundær bebyggelse
        ['garage', 'Sekundær bebyggelse'],
        ['carport', 'Sekundær bebyggelse'],
        ['udhus', 'Sekundær bebyggelse'],
        ['skur', 'Sekundær bebyggelse'],
        ['vaerksted', 'Sekundær bebyggelse'],
        ['hoensehus', 'Sekundær bebyggelse'],
        ['drivhus', 'Sekundær bebyggelse'],
        ['overdaekket terrasse', 'Sekundær bebyggelse'],
        ['mindre bygning med kortvarigt personophold', 'Sekundær bebyggelse'],
        ['mindre bygning med kortvarigt personophold (sekundaer bebyggelse)', 'Sekundær bebyggelse'],

        // Erhverv
        ['butik', 'Erhverv'],
        ['klinik', 'Erhverv'],

        // Erhverv
        ['butik', 'Erhverv'],
        ['klinik', 'Erhverv'],

      ]);

      const categorizeBygningstype = (val) => {
        const raw = String(val ?? '').trim();
        if (!raw) return 'Andre';
        const s = normalizeBygningstypeKey(raw);
        if (!s || s === 'andet') return 'Andre';

        if (simpleKeys.has(s)) return 'Simple byggerier';

        const forced = categoryOverrides.get(s);
        if (forced) return forced;

        const hasAny = (keywords) => keywords.some(k => s.includes(k));

        if (hasAny(['enfamilie', 'dobbel', 'raekke', 'kaede', 'gruppe', 'sommer', 'ferie', 'camping', 'bolig', 'heelaar'])) return 'Beboelse';
        if (hasAny(['hoense', 'drivhus', 'udhus', 'skur', 'garage', 'carport', 'redskab', 'anneks', 'overdaekket', 'sekundaer'])) return 'Sekundær bebyggelse';
        if (hasAny(['erhverv', 'kontor', 'butik', 'industri', 'lager', 'vaerksted', 'stald', 'landbrug', 'produktion', 'klinik'])) return 'Erhverv';
        return 'Andre';
      };

      const renderOptions = (options, prev) => {
        bygningstypeSelect.innerHTML = '';
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = 'Vælg bygningstype…';
        placeholder.disabled = true;
        placeholder.selected = true;
        bygningstypeSelect.appendChild(placeholder);

        const groups = new Map(groupOrder.map(g => [g, []]));
        options.forEach(val => {
          const cat = categorizeBygningstype(val);
          if (!groups.has(cat)) groups.set(cat, []);
          groups.get(cat).push(val);
        });

        // Force the "Simple byggerier" group to contain exactly the canonical list in the desired order.
        // This keeps the dropdown stable and aligned with JSON input values.
        groups.set('Simple byggerier', simpleByggerier.slice());
        for (const [g, arr] of groups.entries()) {
          const without = arr.filter(v => v !== 'andet');
          const hasAndet = arr.includes('andet');
          groups.set(g, hasAndet ? without.concat(['andet']) : without);
        }

        for (const g of groupOrder) {
          const arr = groups.get(g) || [];
          if (!arr.length) continue;
          const og = document.createElement('optgroup');
          og.label = g;
          arr.forEach(val => {
            const opt = document.createElement('option');
            opt.value = val;
            opt.textContent = (g === 'Simple byggerier' || simpleKeys.has(normalizeBygningstypeKey(val)))
              ? prettySimpleLabel(val)
              : val;
            og.appendChild(opt);
          });
          bygningstypeSelect.appendChild(og);
        }

        if (prev && options.includes(prev)) bygningstypeSelect.value = prev;
      };

      const prev = String(bygningstypeSelect.value || '');

      try {
        const apiBase = (typeof API_BASE === 'string' && API_BASE.trim()) ? API_BASE.trim().replace(/\/+$/,'') : '';
        const urls = [
          apiBase ? `${apiBase}/Brandklasse_Bestemmelse.json` : null,
          '/Brandklasse_Bestemmelse.json',
          '../Brandklasse_Bestemmelse.json',
          './Brandklasse_Bestemmelse.json'
        ].filter(Boolean);

        let tree = null;
        let loadedFrom = null;
        for (const url of urls){
          try {
            const bust = `t=${Date.now()}`;
            const fetchUrl = url + (url.includes('?') ? '&' : '?') + bust;
            const resp = await fetch(fetchUrl, { cache: 'no-store' });
            if(resp.ok){ tree = await resp.json(); loadedFrom = url; break; }
          } catch(_) {}
        }
        if(!tree) throw new Error('Kan ikke hente Brandklasse_Bestemmelse.json');

        window.BRANDKLASSE_MODEL = tree;

        const values = [];
        const added = new Set();
        const addVal = (s)=>{
          if(typeof s !== 'string') return;
          let t = s.trim();
          if(!t) return;
          const key = normalizeBygningstypeKey(t);
          if (simpleCanonicalByKey.has(key)) t = simpleCanonicalByKey.get(key);
          if (added.has(t)) return;
          added.add(t);
          values.push(t);
        };

        const mergeUnique = (primary, extras) => {
          const out = primary.slice();
          const seen = new Set(out.map(x => String(x ?? '').trim()).filter(Boolean));
          for (const e of extras) {
            const t = String(e ?? '').trim();
            if (!t || seen.has(t)) continue;
            seen.add(t);
            out.push(t);
          }
          return out;
        };

        const addFromRuleValue = (val, depth = 0) => {
          if (depth > 4) return;
          if (val === null || val === undefined) return;
          if (Array.isArray(val)) {
            val.forEach(v => addFromRuleValue(v, depth + 1));
            return;
          }
          if (typeof val === 'string') {
            const s = val.trim();
            if (!s) return;
            const extracted = [];
            const re = /"([^"]+)"|'([^']+)'/g;
            let m;
            while ((m = re.exec(s)) !== null) extracted.push((m[1] ?? m[2] ?? '').trim());
            if (extracted.length) {
              extracted.forEach(x => addVal(x));
              return;
            }
            if (/[,;\n]/.test(s)) {
              s.split(/[,;\n]/g).map(x => x.trim()).filter(Boolean).forEach(x => addVal(x));
              return;
            }
            addVal(s);
            return;
          }
          if (typeof val === 'object') {
            if (Array.isArray(val.values)) { val.values.forEach(v => addFromRuleValue(v, depth + 1)); return; }
            if (Array.isArray(val.$in)) { val.$in.forEach(v => addFromRuleValue(v, depth + 1)); return; }
            if (Array.isArray(val.in)) { val.in.forEach(v => addFromRuleValue(v, depth + 1)); return; }
            Object.values(val).forEach(v => addFromRuleValue(v, depth + 1));
          }
        };

        const nodes = Array.isArray(tree.nodes) ? tree.nodes : [];
        nodes.forEach(node => {
          const content = node && node.content;
          const inputs = content && Array.isArray(content.inputs) ? content.inputs : [];
          const rules = content && Array.isArray(content.rules) ? content.rules : [];
          const bygIds = inputs.filter(inp => inp.field === 'bygningstype').map(inp => inp.id);
          if (!bygIds.length || !rules.length) return;
          rules.forEach(rule => {
            bygIds.forEach(id => addFromRuleValue(rule[id]));
          });
        });

        try {
          console.info('[Bygningstype] Loaded Brandklasse_Bestemmelse.json from', loadedFrom || '(unknown)', '- extracted', values.length, 'values');
          if (!values.length) console.warn('[Bygningstype] No values extracted from model; using fallback list.');
        } catch(_) {}

        const merged = values.length ? mergeUnique(values, fallback) : fallback.slice();
        renderOptions(merged, prev);
      } catch (err) {
        try { console.warn('[Bygningstype] Could not load model; using fallback list.', err); } catch(_) {}
        renderOptions(fallback.slice(), prev);
      }

      // Re-initialize custom selects after options are populated
      setTimeout(() => {
        if (typeof initCustomSelects === 'function') initCustomSelects();
      }, 100);
    }

    // Helpers to read form values
    const asBool = (id, fallback = null) => {
      const el = document.getElementById(id);
      if (!el) return fallback;
      const v = String(el.value);
      if (v === 'true') return true;
      if (v === 'false') return false;
      return null;
    };
    const asNum = (id, fallback = null) => {
      const el = document.getElementById(id);
      if (!el) return fallback;
      const v = el.value;
      const n = v === '' ? null : Number(v);
      return Number.isFinite(n) ? n : null;
    };
    const asStr = (id, fallback = '') => {
      const el = document.getElementById(id);
      if (!el) return fallback;
      return el.value || '';
    };

    // Bilag-specific inputs (asked in step 2 templates)
    function getActiveBilagExtras(){
      const idx = getActiveSectionIndex();
      return sectionsState.bilagExtras?.[idx] || {};
    }
    function setActiveBilagExtra(key, value){
      const idx = getActiveSectionIndex();
      sectionsState.bilagExtras = sectionsState.bilagExtras || {};
      sectionsState.bilagExtras[idx] = { ...(sectionsState.bilagExtras[idx] || {}), [key]: value };
    }

    // Keep the JSON shown/sent in a canonical shape.
    // This prevents legacy/alias keys (e.g. 'tilbygning', 'fritliggende_BA') from appearing in the right-side JSON.
    function canonicalizeInputData(obj){
      const src = (obj && typeof obj === 'object') ? obj : {};
      const pickNum = (key) => {
        const v = src[key];
        if (v === null || v === undefined || v === '') return null;
        const n = Number(v);
        return Number.isFinite(n) ? n : null;
      };
      const pickStr = (key) => {
        const v = src[key];
        return (v === null || v === undefined) ? '' : String(v);
      };
      const pickBool = (key, fallbackKey) => {
        const v = (src[key] !== undefined) ? src[key] : (fallbackKey ? src[fallbackKey] : undefined);
        if (v === undefined || v === null || v === '') return null;
        if (typeof v === 'boolean') return v;
        if (typeof v === 'string') {
          const vv = v.toLowerCase();
          if (vv === 'true') return true;
          if (vv === 'false') return false;
          return null;
        }
        return !!v;
      };

      // 'med_tilbygning' asked in bilag-step (step 2). Keep key only if present.
      const medTilbygning = (src['med_tilbygning'] !== undefined || src['tilbygning'] !== undefined)
        ? ((src['med_tilbygning'] !== undefined) ? pickBool('med_tilbygning') : pickBool('tilbygning'))
        : undefined;
      const fritstaaende = (src['fritstaaende'] !== undefined)
        ? pickBool('fritstaaende')
        : pickBool('fritliggende_BA');

      const out = {
        antal_etager_over_terraen_BA: pickNum('antal_etager_over_terraen_BA'),
        antal_etager_under_terraen_BA: pickNum('antal_etager_under_terraen_BA'),
        etage_hoejde_BA: pickNum('etage_hoejde_BA'),
        etage_dybde_BA: pickNum('etage_dybde_BA'),
        etage_hoejde: pickNum('etage_hoejde'),
        antal_etager_BA: pickNum('antal_etager_BA'),
        brandbelastning_BA: pickNum('brandbelastning_BA'),
        area_BA: pickNum('area_BA'),
        area_total: pickNum('area_total'),
        bygningstype: pickStr('bygningstype'),
        // 'med_erhvervssammenbygning' asked in bilag-step (step 2). Keep key only if present.
        med_erhvervssammenbygning: (src['med_erhvervssammenbygning'] !== undefined) ? pickBool('med_erhvervssammenbygning') : undefined,
        med_tilbygning: medTilbygning,
        antal_personer_BA: pickNum('antal_personer_BA'),
        antal_overnattende: pickNum('antal_overnattende'),
        overnatning: pickBool('overnatning'),
        kendskab_flugtveje: pickBool('kendskab_flugtveje'),
        selvhjulpen: pickBool('selvhjulpen'),
        fritstaaende: fritstaaende,
        direkte_udgange: pickBool('direkte_udgange'),
        direkte_udgange_soverum: pickBool('direkte_udgange_soverum'),
        bygningsafsnit_i_RK4: pickBool('bygningsafsnit_i_RK4'),
        antal_BA: pickNum('antal_BA'),
        antal_fravigelser_fra_praeaccepterede: pickNum('antal_fravigelser_fra_praeaccepterede')
      };

      // Remove undefined optional keys for a cleaner canonical JSON.
      Object.keys(out).forEach(k => { if (out[k] === undefined) delete out[k]; });
      return out;
    }

    function buildJsonFromForm(){
      const data = {
        antal_etager_over_terraen_BA: asNum('fld_antal_etager_over_terraen_BA'),
        antal_etager_under_terraen_BA: asNum('fld_antal_etager_under_terraen_BA'),
        etage_hoejde_BA: asNum('fld_etage_hoejde_BA'),
        etage_dybde_BA: asNum('fld_etage_dybde_BA'),
        etage_hoejde: asNum('fld_etage_hoejde'),
        antal_etager_BA: asNum('fld_antal_etager_BA'),
        brandbelastning_BA: asNum('fld_brandbelastning_BA'),
        area_BA: asNum('fld_area_BA'),
        area_total: asNum('fld_area_total'),
        bygningstype: asStr('fld_bygningstype'),
        antal_personer_BA: asNum('fld_antal_personer_BA'),
        antal_overnattende: asNum('fld_antal_overnattende'),
        overnatning: asBool('fld_overnatning'),
        kendskab_flugtveje: asBool('fld_kendskab_flugtveje'),
        selvhjulpen: asBool('fld_selvhjulpen'),
        fritstaaende: asBool('fld_fritliggende_BA'),
        direkte_udgange: asBool('fld_direkte_udgange'),
        direkte_udgange_soverum: asBool('fld_direkte_udgange_soverum'),
        bygningsafsnit_i_RK4: asBool('fld_bygningsafsnit_i_RK4'),
        antal_BA: sectionsState.count,
        antal_fravigelser_fra_praeaccepterede: asNum('fld_antal_fravigelser_fra_praeaccepterede')
      };
      return canonicalizeInputData(data);
    }

    function updateFormFromJson(obj){
      const hasNum = (v) => (v !== undefined && v !== null && v !== '');
      const hasStr = (v) => (v !== undefined && v !== null && String(v).trim() !== '');
      const hasBool = (v) => (typeof v === 'boolean' || v === 'true' || v === 'false');

      // Only apply values that are actually provided. This enables partial JSON uploads.
      const setNum = (id, key) => {
        const el = document.getElementById(id);
        if (!el) return;
        const v = obj[key];
        if (hasNum(v)) el.value = v;
      };
      const setBool = (id, key) => {
        const el = document.getElementById(id);
        if (!el) return;
        const v = obj[key];
        if (!hasBool(v)) return;
        const b = (typeof v === 'boolean') ? v : (String(v) === 'true');
        el.value = String(!!b);
      };
      const setStr = (id, key) => {
        const el = document.getElementById(id);
        if (!el) return;
        const v = obj[key];
        if (hasStr(v)) el.value = String(v);
      };

      // Numerics
      setNum('fld_antal_etager_over_terraen_BA','antal_etager_over_terraen_BA');
      setNum('fld_antal_etager_under_terraen_BA','antal_etager_under_terraen_BA');
      // etage_hoejde was historically reused for BA; keep a soft fallback when etage_hoejde_BA isn't provided
      if (obj['etage_hoejde'] !== undefined) setNum('fld_etage_hoejde','etage_hoejde');
      if (obj['etage_hoejde_BA'] !== undefined) setNum('fld_etage_hoejde_BA','etage_hoejde_BA');
      else if (obj['etage_hoejde'] !== undefined) setNum('fld_etage_hoejde_BA','etage_hoejde');
      setNum('fld_etage_dybde_BA','etage_dybde_BA');
      setNum('fld_antal_etager_BA','antal_etager_BA');
      setNum('fld_brandbelastning_BA','brandbelastning_BA');
      setNum('fld_area_BA','area_BA');
      setNum('fld_area_total','area_total');
      setNum('fld_antal_personer_BA','antal_personer_BA');
      setNum('fld_antal_overnattende','antal_overnattende');
      // antal_BA uses sectionsState.count instead of form field

      // Booleans
      setBool('fld_overnatning','overnatning');
      setBool('fld_kendskab_flugtveje','kendskab_flugtveje');
      setBool('fld_selvhjulpen','selvhjulpen');
      setBool('fld_direkte_udgange','direkte_udgange');
      setBool('fld_direkte_udgange_soverum','direkte_udgange_soverum');
      setBool('fld_bygningsafsnit_i_RK4','bygningsafsnit_i_RK4');

      // Numerics (nye felter)
      setNum('fld_antal_fravigelser_fra_praeaccepterede','antal_fravigelser_fra_praeaccepterede');

      // Bilag-specific keys (asked in step 2) - store as extras when loaded from JSON
      if (obj['med_tilbygning'] === true || obj['med_tilbygning'] === false) {
        setActiveBilagExtra('med_tilbygning', obj['med_tilbygning']);
        setBool('fld_med_tilbygning', 'med_tilbygning');
      } else if (obj['tilbygning'] === true || obj['tilbygning'] === false) {
        setActiveBilagExtra('med_tilbygning', obj['tilbygning']);
        // Backwards compatible key
        setBool('fld_med_tilbygning', 'tilbygning');
      }
      if (obj['med_erhvervssammenbygning'] === true || obj['med_erhvervssammenbygning'] === false) {
        setActiveBilagExtra('med_erhvervssammenbygning', obj['med_erhvervssammenbygning']);
        setBool('fld_med_erhvervssammenbygning', 'med_erhvervssammenbygning');
      }

      // Backwards/forwards compatible: fritstaaende (preferred) / fritliggende_BA
      if (document.getElementById('fld_fritliggende_BA')){
        // IMPORTANT: don't coerce null/undefined to false ("Nej"). Only set when a real boolean is provided.
        if (obj['fritstaaende'] === true || obj['fritstaaende'] === false) {
          document.getElementById('fld_fritliggende_BA').value = String(obj['fritstaaende']);
        } else if (obj['fritliggende_BA'] === true || obj['fritliggende_BA'] === false) {
          document.getElementById('fld_fritliggende_BA').value = String(obj['fritliggende_BA']);
        } else {
          try { document.getElementById('fld_fritliggende_BA').value = ''; } catch(_) {}
        }
      }

      // Strings
      if (obj['bygningstype'] !== undefined && obj['bygningstype'] !== null && String(obj['bygningstype']).trim() !== '' && document.getElementById('fld_bygningstype')){
        const sel = document.getElementById('fld_bygningstype');
        const val = String(obj['bygningstype']);
        // If option not present, keep current selection to avoid empty state
        const exists = Array.from(sel.options).some(o => o.value === val);
        sel.value = exists ? val : sel.value;
      }

      // If JSON load provided enough for brandklasse, trigger evaluation on Step 1.
      try {
        if (currentStep === 1) {
          // Always run /evaluate-complete after JSON load so we can compute BK or at least
          // show BK suggestions (even when totalareal is missing).
          scheduleBrandklasseEvaluate();
        }
      } catch(_) {}
      
      // Re-initialize custom selects after form values are updated
      setTimeout(() => {
        if (typeof initCustomSelects === 'function') initCustomSelects();
      }, 50);
    }

    // Auto-evaluate: prefer form data; use textarea when visible and non-empty
    let evalTimer = null;
    function scheduleEvaluate(){
      if(evalTimer) clearTimeout(evalTimer);
      // Keep JSON in sync with form unless we're currently syncing from JSON or user is editing JSON manually
      if(!syncingFromJson && !jsonManualEdit){
        const data = { ...canonicalizeInputData(buildJsonFromForm()), ...getActiveBilagExtras() };
        // Always include these keys in the JSON view (null = unknown) so they don't "pop in" later.
        if (data.med_tilbygning === undefined) data.med_tilbygning = null;
        if (data.med_erhvervssammenbygning === undefined) data.med_erhvervssammenbygning = null;
        jsonTextarea.value = JSON.stringify(data, null, 2);
      }
      evalTimer = setTimeout(evaluateNow, 300);
    }

    async function evaluateNow(){
      try {
        let data;
        // Prefer form unless user manually edited JSON
        const jsonPaneVisible = (() => {
          try {
            if (!jsonAdvanced) return false;
            return window.getComputedStyle(jsonAdvanced).display !== 'none';
          } catch (_) {
            return false;
          }
        })();
        const useTextarea = jsonPaneVisible && jsonManualEdit && jsonTextarea.value.trim().length > 0;
        if(useTextarea){
          try {
            const parsed = JSON.parse(jsonTextarea.value);
            data = canonicalizeInputData(parsed);
            // Keep textarea clean even if JSON was loaded/edited with legacy keys.
            // IMPORTANT: Always include bilag extras keys so they don't flicker in/out.
            const view = { ...getActiveBilagExtras(), ...data };
            if (view.med_tilbygning === undefined) view.med_tilbygning = null;
            if (view.med_erhvervssammenbygning === undefined) view.med_erhvervssammenbygning = null;
            jsonTextarea.value = JSON.stringify(view, null, 2);
          } catch(parseErr){
            // Invalid JSON; show dashes
            displayResults({});
            updateStatus();
            return;
          }
        } else {
          data = canonicalizeInputData(buildJsonFromForm());
          // Keep textarea consistent with scheduleEvaluate() (includes bilag extras and stable keys)
          const view = { ...data, ...getActiveBilagExtras() };
          if (view.med_tilbygning === undefined) view.med_tilbygning = null;
          if (view.med_erhvervssammenbygning === undefined) view.med_erhvervssammenbygning = null;
          jsonTextarea.value = JSON.stringify(view, null, 2);
        }
        // Persist inputs for the active section so tab switches retain state
        try { captureInputsToSection(getActiveSectionIndex()); } catch(_) {}
        // Step 1 uses basic evaluation (AK/RK/Bilag). Brandklasse is evaluated separately on Step 1.
        const response = await fetch(`${API_BASE}/evaluate-basic`, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(data)});
        if(!response.ok){
          // Not enough input or server error; show dashes
          displayResults({});
          updateStatus();
          return;
        }
        const result = await response.json();
        displayResults(result);
        const idx = getActiveSectionIndex();
        // Merge basic result into existing evaluation to avoid wiping brandklasse/bilag_outputs.
        const previous = sectionsState.evaluations[idx] ?? latestEvaluation ?? {};
        const merged = { ...previous, ...result };
        if (!('brandklasse' in result) && previous.brandklasse !== undefined) merged.brandklasse = previous.brandklasse;

        // IMPORTANT: /evaluate-basic should not wipe figure refs coming from /evaluate-complete.
        // Some backends may include an empty bilag_outputs object in the basic response.
        const prevOut = previous.bilag_outputs;
        const resOut = result.bilag_outputs;
        const isPlainObject = (v) => v !== null && v !== undefined && typeof v === 'object' && !Array.isArray(v);
        if (isPlainObject(prevOut) && isPlainObject(resOut)) {
          const resKeys = Object.keys(resOut);
          merged.bilag_outputs = resKeys.length === 0 ? prevOut : { ...prevOut, ...resOut };
        } else if (
          // If basic didn't include bilag_outputs (or included null/empty), keep previous.
          (!('bilag_outputs' in result) || resOut === null || (isPlainObject(resOut) && Object.keys(resOut).length === 0))
          && previous.bilag_outputs !== undefined
        ) {
          merged.bilag_outputs = previous.bilag_outputs;
        }
        latestEvaluation = merged;
        sectionsState.evaluations[idx] = merged;
        // Store input data for explanations
        sectionsState.inputData[idx] = data;
        sectionsState.progress[idx] = { ...(sectionsState.progress[idx]||{}), evaluated:true };
        renderSectionTabs();
        try { updateStep1BrandklasseCard(); } catch(_) {}
        updateStatus();
      } catch(err){
        // Network or other error; keep dashes
        displayResults({});
        updateStatus();
      }
    }

    // Store matched rule IDs for current evaluation
    let currentMatchedRules = {
      anvendelseskategori: null,
      risikoklasse: null,
      relevant_bilag: null,
      brandklasse: null
    };

    // Check if a specific rule path is validated
    function isRuleValidated(ruleId) {
      if (!ruleId || !validationData.decisionTables) {
        console.log(`[Validation] Rule ${ruleId} check: No ruleId or validation data`);
        return false;
      }
      const validated = validationData.decisionTables[ruleId]?.validated === true;
      console.log(`[Validation] Checking rule ${ruleId}: ${validated ? 'VALIDATED' : 'NOT VALIDATED'}`);
      return validated;
    }

    // Update validation status for all current results
    function updateResultValidationStatus() {
      console.log('[Validation] Updating result validation status...');
      console.log('[Validation] Current matched rules:', currentMatchedRules);
      console.log('[Validation] Validation data:', validationData);
      
      // Don't show topbar badge
      
      // Update individual result badges
      const fields = ['anvendelseskategori', 'risikoklasse', 'relevant_bilag', 'brandklasse'];
      
      for (const field of fields) {
        const ruleId = currentMatchedRules[field];
        if (ruleId) {
          const validated = isRuleValidated(ruleId);
          updateResultBadge(field, validated);
        } else {
          console.log(`[Validation] No rule ID for field: ${field}`);
        }
      }
    }

    // Update validation badge for a specific result
    function updateResultBadge(field, validated) {
      const mapping = {
        'anvendelseskategori': 'anvendelse',
        'risikoklasse': 'risiko',
        'relevant_bilag': 'bilag',
        'brandklasse': 'brandklasse'
      };
      const rowId = mapping[field];
      if (!rowId) return;
      
      const row = document.querySelector(`[data-result-row="${rowId}"]`);
      if (!row) {
        console.warn(`[Validation] Could not find row for field: ${field}, rowId: ${rowId}`);
        return;
      }
      
      // Remove existing badge
      const existingBadge = row.querySelector('.validation-badge');
      if (existingBadge) existingBadge.remove();
      
      // Check if there's actually a result value to validate
      const valueEl = row.querySelector('.result-value');
      if (!valueEl) return;
      
      const valueText = valueEl.textContent.trim();
      // Only show badge if there's an actual result (not "-" or empty)
      if (!valueText || valueText === '-') return;
      
      // Add new badge
      const badge = document.createElement('span');
      badge.className = 'validation-badge';
      badge.style.cssText = `
        display: inline-flex; 
        align-items: center; 
        gap: 4px; 
        padding: 3px 8px; 
        border-radius: 12px; 
        font-size: 11px; 
        font-weight: 600; 
        margin-left: 8px;
        ${validated 
          ? 'background: var(--c-bg-2); color: var(--c-accent); border: 1px solid var(--c-accent);' 
          : 'background: var(--c-surface-muted); color: var(--c-primary); border: 1px solid var(--c-primary);'}
      `;
      badge.className = 'validation-badge';
      badge.innerHTML = validated ? '✓' : '⚠ Ikke valideret';
      badge.setAttribute('data-tip', validated ? 'Denne regel er tjekket af en brandrådgiver' : 'Denne regel er ikke tjekket');
      
      valueEl.appendChild(badge);
    }

    function displayResults(result){
      const hasText = (v) => v !== null && v !== undefined && String(v).trim() !== '';

      // Collect the exact questions we actually show on the right.
      const displayedHighlightQuestions = [];
      const addHL = (arr)=>{
        if (!Array.isArray(arr)) return;
        arr.forEach(q => {
          if (q === null || q === undefined) return;
          if (typeof q === 'object') {
            // Prefer stable backend fields whenever present.
            if (q.field) {
              displayedHighlightQuestions.push({ field: q.field, question: q.question || null, kind: q.kind || null });
              return;
            }
            return;
          }
          // No fallback to question-text highlighting (ID-based only).
        });
      };

      const uniqStrings = (arr) => Array.from(new Set((Array.isArray(arr) ? arr : [])
        .map(v => String(v ?? '').trim())
        .filter(Boolean)));

      const pickMissing = (nodeHints, fallbackCandidates) => {
        const hints = (Array.isArray(nodeHints) ? nodeHints : []).map(h => String(h).toLowerCase());
        const missing = Array.isArray(result?.missing_inputs) ? result.missing_inputs : [];

        const fromMissing = missing
          .filter(mi => {
            const node = String(mi?.node_name ?? mi?.node ?? '').toLowerCase();
            return hints.some(h => node.includes(h));
          })
          .sort((a, b) => Number(b?.score ?? 0) - Number(a?.score ?? 0));

        // Display text: prefer human question strings.
        const displayFromMissing = fromMissing.map(mi => mi?.question).filter(Boolean);

        // Highlight: prefer stable backend fields (field -> fld_<field>).
        const highlightFromMissing = fromMissing
          .map(mi => (mi?.field ? { field: mi.field, question: mi?.question || null, kind: 'missing' } : null))
          .filter(Boolean);

        const candList = Array.isArray(fallbackCandidates) ? fallbackCandidates : [];
        const candDisplay = candList.flatMap(c => Array.isArray(c?.missing_questions) ? c.missing_questions : [])
          .map(v => String(v ?? '').trim())
          .filter(Boolean);
        const candFields = candList.flatMap(c => Array.isArray(c?.missing_fields) ? c.missing_fields : [])
          .map(v => String(v ?? '').trim())
          .filter(Boolean);
        const candHighlight = Array.from(new Set(candFields)).slice(0, 6).map(f => ({ field: f, kind: 'missing' }));

        const display = uniqStrings(displayFromMissing.length ? displayFromMissing : candDisplay).slice(0, 4);
        const highlight = (highlightFromMissing.length ? highlightFromMissing : candHighlight);
        return { display, highlight };
      };

      const pickCandidateValues = (list, prefix = '') => {
        if (!Array.isArray(list) || list.length === 0) return [];
        const values = uniqStrings(list.map(c => c?.value).filter(v => v !== null && v !== undefined));
        return values.map(v => `${prefix}${v}`);
      };

      const pickOptimizationTargets = (list, prefix = '') => {
        if (!Array.isArray(list) || list.length === 0) return [];
        const targets = uniqStrings(list.map(s => s?.target_value).filter(v => v !== null && v !== undefined));
        return targets.map(t => `${prefix}${t}`);
      };

      const parseRankNumber = (v) => {
        if (v === null || v === undefined) return null;
        const n = Number.parseInt(String(v).trim(), 10);
        return Number.isFinite(n) ? n : null;
      };

      const formatOptimizationDetailsHtml = (list, labelPrefix) => {
        if (!Array.isArray(list) || list.length === 0) return '';

        const sorted = list
          .filter(s => s && s.target_value !== null && s.target_value !== undefined)
          .slice()
          .sort((a, b) => {
            const an = parseRankNumber(a?.target_value);
            const bn = parseRankNumber(b?.target_value);
            if (an === null && bn === null) return String(a?.target_value).localeCompare(String(b?.target_value));
            if (an === null) return 1;
            if (bn === null) return -1;
            return an - bn;
          });

        const items = sorted.slice(0, 4);
        if (!items.length) return '';

        const title = '<div class="opt-help-title">Optimering:</div>';
        const rows = items.map((s) => {
          const target = s?.target_value;
          const targetStr = escapeHtml(String(target));
          const rankNum = parseRankNumber(target);
          const itemRankCls = (rankNum && rankNum >= 1 && rankNum <= 4) ? `rank-${rankNum}` : '';

          const parts = [];

          const missing = Array.isArray(s?.missing_questions) ? s.missing_questions : [];
          if (missing.length) {
            const missTxt = missing.slice(0, 4).map(x => escapeHtml(String(x))).join(', ');
            parts.push(`Udfyld: ${missTxt}`);
          }

          const req = Array.isArray(s?.required_fields) ? s.required_fields : [];
          const reqTxt = req
            .map(r => {
              const q = r?.question;
              const exp = r?.expected_value;
              if (!q) return '';
              if (exp === null || exp === undefined || String(exp).trim() === '') return escapeHtml(String(q));
              return `${escapeHtml(String(q))} = ${escapeHtml(String(exp))}`;
            })
            .filter(Boolean);
          if (reqTxt.length) parts.push(`Sæt: ${reqTxt.slice(0, 3).join('; ')}`);

          const nums = Array.isArray(s?.numeric_adjustments) ? s.numeric_adjustments : [];
          const numsTxt = nums
            .map(a => {
              const q = a?.question;
              const exp = a?.expected;
              const d = a?.delta_abs;
              if (!q || !exp) return '';
              const deltaTxt = (d !== null && d !== undefined && Number.isFinite(Number(d)))
                ? ` (afvigelse: ${escapeHtml(String(Number(d).toFixed(0)))})`
                : '';
              return `${escapeHtml(String(q))} ${escapeHtml(String(exp))}${deltaTxt}`;
            })
            .filter(Boolean);
          if (numsTxt.length) parts.push(`Justér: ${numsTxt.slice(0, 3).join('; ')}`);

          const detail = parts.length ? parts.join(' | ') : '';
          const rankName = `${escapeHtml(String(labelPrefix))}${targetStr}`;
          const suffix = detail ? `: ${detail}` : '';
          return (
            `<div class="opt-help-item ${itemRankCls}">` +
              `<div class="opt-help-text"><span class="opt-rank-name">${rankName}</span>${suffix}</div>` +
            '</div>'
          );
        }).join('');

        return `<div class="opt-help">${title}<div class="opt-help-list">${rows}</div></div>`;
      };

      const formatOptimizationDetails = (list, labelPrefix) => {
        if (!Array.isArray(list) || list.length === 0) return '';
        const lines = ['Optimering:'];
        list.slice(0, 3).forEach((s)=>{
          const target = s?.target_value;
          if (target === null || target === undefined) return;

          const parts = [];

          const missing = Array.isArray(s?.missing_questions) ? s.missing_questions : [];
          if (missing.length) parts.push(`Udfyld: ${missing.slice(0, 4).join(', ')}`);

          const req = Array.isArray(s?.required_fields) ? s.required_fields : [];
          const reqTxt = req
            .map(r => {
              const q = r?.question;
              const exp = r?.expected_value;
              if (!q) return '';
              if (exp === null || exp === undefined || String(exp).trim() === '') return `${q}`;
              return `${q} = ${exp}`;
            })
            .filter(Boolean);
          if (reqTxt.length) parts.push(`Sæt: ${reqTxt.slice(0, 3).join('; ')}`);

          const nums = Array.isArray(s?.numeric_adjustments) ? s.numeric_adjustments : [];
          const numsTxt = nums
            .map(a => {
              const q = a?.question;
              const exp = a?.expected;
              const d = a?.delta_abs;
              if (!q || !exp) return '';
              const deltaTxt = (d !== null && d !== undefined && Number.isFinite(Number(d)))
                ? ` (afvigelse: ${Number(d).toFixed(0)})`
                : '';
              return `${q} ${exp}${deltaTxt}`;
            })
            .filter(Boolean);
          if (numsTxt.length) parts.push(`Justér: ${numsTxt.slice(0, 3).join('; ')}`);

          const detail = parts.length ? ` ${parts.join(' | ')}` : '';
          lines.push(`• ${labelPrefix}${target}:${detail}`);
        });
        return lines.length > 1 ? lines.join('\n') : '';
      };

      const buildActionHelp = ({ ok, okText, candidates, missingQuestions, optimizationTargets }) => {
        const lines = [];
        if (ok) {
          if (okText) lines.push(okText);
          if (optimizationTargets && optimizationTargets.length) {
            lines.push(`Mulig optimering: ${optimizationTargets.slice(0, 3).join(', ')}`);
          }
          return lines.join('\n');
        }

        if (candidates && candidates.length) {
          lines.push(`Kan blive: ${candidates.slice(0, 6).join(' eller ')}`);
        }
        if (missingQuestions && missingQuestions.length) {
          lines.push('For at afgøre:');
          missingQuestions.forEach(q => lines.push(`• ${q}`));
        }
        if (!lines.length) lines.push('Værktøj er ikke udvidet til flere bilag end 1a og 1b på nuværende tidspunkt.');
        return lines.join('\n');
      };

      const formatCandidates = (list, kindLabel) => {
        if (!Array.isArray(list) || list.length === 0) return '';
        const parts = list.slice(0, 6).map((c)=>{
          const v = (c && c.value !== undefined && c.value !== null) ? String(c.value) : '';
          const missing = Array.isArray(c?.missing_questions) ? c.missing_questions
                        : (Array.isArray(c?.missing_fields) ? c.missing_fields : []);
          const missTxt = (missing && missing.length) ? ` (mangler: ${missing.join(', ')})` : '';
          return `${v}${missTxt}`.trim();
        }).filter((x)=>x && x !== '-');
        if (parts.length === 0) return '';
        const prefix = kindLabel ? `${kindLabel}: ` : '';
        return `${prefix}Mulige: ${parts.join(' eller ')}`;
      };

      const formatOptimizations = (list, label) => {
        if (!Array.isArray(list) || list.length === 0) return '';
        const parts = list.slice(0, 2).map((s)=>{
          const target = s?.target_value;
          if (target === null || target === undefined) return '';

          const missing = Array.isArray(s?.missing_questions) ? s.missing_questions : [];
          const req = Array.isArray(s?.required_fields) ? s.required_fields.map(r => r?.question).filter(Boolean) : [];
          const nums = Array.isArray(s?.numeric_adjustments)
            ? s.numeric_adjustments.map(a => {
                const q = a?.question;
                const exp = a?.expected;
                const cur = a?.current;
                const d = a?.delta_abs;
                if (!q || !exp) return '';
                const deltaTxt = (d !== null && d !== undefined && Number.isFinite(Number(d))) ? ` (afvigelse: ${Number(d).toFixed(0)})` : '';
                return `${q} ${exp}${deltaTxt}`;
              }).filter(Boolean)
            : [];

          const needs = [...missing, ...req, ...nums].filter(Boolean);
          const needsTxt = needs.length ? ` — hvis: ${needs.join(', ')}` : '';
          return `${label}${target}${needsTxt}`;
        }).filter(Boolean);

        return parts.length ? `Optimering: ${parts.join(' | ')}` : '';
      };

      // Store matched rule IDs
      console.log('[Display] Full result object:', JSON.stringify(result, null, 2));
      console.log('[Display] anvendelseskategori object:', result?.anvendelseskategori);
      console.log('[Display] anvendelseskategori.matched_rule_id:', result?.anvendelseskategori?.matched_rule_id);
      console.log('[Display] risikoklasse object:', result?.risikoklasse);
      console.log('[Display] risikoklasse.matched_rule_id:', result?.risikoklasse?.matched_rule_id);
      
      currentMatchedRules.anvendelseskategori = result?.anvendelseskategori?.matched_rule_id || null;
      currentMatchedRules.risikoklasse = result?.risikoklasse?.matched_rule_id || null;
      currentMatchedRules.relevant_bilag = result?.relevant_bilag?.matched_rule_id || null;
      currentMatchedRules.brandklasse = result?.brandklasse?.matched_rule_id || null;
      
      console.log('[Display] Stored matched rules:', currentMatchedRules);

      const akVal = hasText(result?.anvendelseskategori?.value) ? String(result.anvendelseskategori.value) : '-';
      const akCand = result?.candidates?.anvendelseskategori;
      const akMissing = (akVal === '-') ? pickMissing(['anvendelseskategori'], akCand) : { display: [], highlight: [] };
      const akDesc = buildActionHelp({
        ok: akVal !== '-',
        okText: '',
        candidates: pickCandidateValues(akCand, ''),
        missingQuestions: akMissing.display,
        optimizationTargets: []
      });
      addHL(akMissing.highlight);
      setResultRowValue('anvendelse', akVal, akDesc);
      setResultRowStatus('anvendelse', akVal !== '-');

      const rkVal = hasText(result?.risikoklasse?.value) ? String(result.risikoklasse.value) : '-';
      const rkCand = result?.candidates?.risikoklasse;
      const rkOptDetailHtml = formatOptimizationDetailsHtml(result?.suggestions?.risikoklasse, 'RK');
      let rkDesc = '';
      if (rkVal !== '-') {
        rkDesc = (rkOptDetailHtml || '');

        // If we show optimization, highlight the questions that appear in it.
        const optListRaw = Array.isArray(result?.suggestions?.risikoklasse) ? result.suggestions.risikoklasse : [];
        const optList = optListRaw
          .filter(s => s && s.target_value !== null && s.target_value !== undefined)
          .slice()
          .sort((a, b) => {
            const an = parseRankNumber(a?.target_value);
            const bn = parseRankNumber(b?.target_value);
            if (an === null && bn === null) return String(a?.target_value).localeCompare(String(b?.target_value));
            if (an === null) return 1;
            if (bn === null) return -1;
            return an - bn;
          });
        optList.slice(0, 4).forEach(s => {
          // Prefer fields over text.
          addHL(Array.isArray(s?.missing_fields) ? s.missing_fields.map(f => ({ field: f, kind: 'missing' })) : []);
          addHL(Array.isArray(s?.required_fields) ? s.required_fields.map(r => ({ ...r, kind: 'opt' })) : []);
          addHL(Array.isArray(s?.numeric_adjustments) ? s.numeric_adjustments.map(a => ({ ...a, kind: 'opt' })) : []);
        });
      } else {
        // RK depends on AK — don't show RK missing-field prompts until AK is known.
        if (akVal === '-') {
          rkDesc = 'Afventer: Anvendelseskategori';
        } else {
          const rkMissing = pickMissing(['risikoklasse'], rkCand);
          rkDesc = buildActionHelp({
            ok: false,
            okText: '',
            candidates: pickCandidateValues(rkCand, ''),
            missingQuestions: rkMissing.display,
            optimizationTargets: []
          });
          addHL(rkMissing.highlight);
        }
      }
      setResultRowValue('risiko', rkVal, rkDesc, { descHtml: (rkVal !== '-' && !!rkOptDetailHtml) });
      setResultRowStatus('risiko', rkVal !== '-');

      const bilagRaw = result?.relevant_bilag?.value ?? result?.relevant_bilag ?? result?.bilag;
      const bilagVal = hasText(bilagRaw) ? String(bilagRaw) : '-';
      const bilagTitleRaw = (result?.bilag_titel && typeof result.bilag_titel === 'object' && ('value' in result.bilag_titel))
        ? result.bilag_titel.value
        : result?.bilag_titel;
      const bilagInfoRaw = result?.bilagsinformation ?? result?.relevant_bilag?.description;
      const bilagDesc = hasText(bilagTitleRaw)
        ? String(bilagTitleRaw)
        : (hasText(bilagInfoRaw) ? String(bilagInfoRaw) : '');

      let bilagDescOut = bilagDesc;
      if (bilagVal === '-') {
        // Bilag depends on AK + RK — wait with prompts until both are known.
        const waiting = [];
        if (akVal === '-') waiting.push('Anvendelseskategori');
        if (rkVal === '-') waiting.push('Risikoklasse');
        if (waiting.length) {
          bilagDescOut = `Afventer: ${waiting.join(', ')}`;
        } else {
          const cand = result?.candidates?.relevant_bilag;
          const bilagMissing = pickMissing(['bilag', 'relevant bilag'], cand);
          bilagDescOut = buildActionHelp({
            ok: false,
            okText: '',
            candidates: pickCandidateValues(cand, ''),
            missingQuestions: bilagMissing.display,
            optimizationTargets: []
          });
          addHL(bilagMissing.highlight);
        }
      }

      setResultRowValue('bilag', (bilagVal === '-' ? '-' : formatBilagDisplayId(bilagVal)), bilagDescOut);
      setResultRowStatus('bilag', bilagVal !== '-');

      const headline = document.getElementById('headline-results');
      if (headline) headline.textContent = `Risikoklasse ${rkVal} – Bilag ${bilagVal === '-' ? '-' : formatBilagDisplayId(bilagVal)}`;
      
      // Update validation badges
      updateResultValidationStatus();

      // Show backend error/debug info if present
      const hasErrors = Array.isArray(result.errors) && result.errors.length > 0;
      const headlineEl = document.getElementById('headline-results');
      if (hasErrors && headlineEl) {
        console.warn('Evaluator errors:', result.errors, result.debug_ak, result.debug_rk, result.debug_bilag, result.debug_bk);
        const parent = headlineEl.parentElement;
        let banner = document.getElementById('eval-error-banner');
        if (!banner) {
          banner = document.createElement('div');
          banner.id = 'eval-error-banner';
          banner.style.background = 'var(--status-warn-bg)';
          banner.style.color = 'var(--status-warn-text)';
          banner.style.border = '1px solid var(--status-warn-border)';
          banner.style.borderRadius = '8px';
          banner.style.padding = '8px 12px';
          banner.style.marginTop = '8px';
          parent.appendChild(banner);
        }
        banner.textContent = `⚠️ Evaluering kunne ikke fuldføres: ${result.errors.join('; ')}`;
      } else {
        const banner = document.getElementById('eval-error-banner');
        if (banner) banner.remove();
      }

      // Mark requirements viewed for active section when in step 2
      if (currentStep === 2){
        const idx = getActiveSectionIndex();
        sectionsState.progress[idx] = { ...(sectionsState.progress[idx]||{}), requirementsViewed:true };
        renderSectionTabs();
      }

      // Store + apply highlights for AK/RK/Bilag only.
      latestDisplayedHighlightQuestionsBase = displayedHighlightQuestions;
      try { applyHighlightsFromDisplayedQuestions(displayedHighlightQuestions); } catch(_) {}
    }

    // Final overview: aggregate per-section titles and key results
    function renderFinalOverview(){
      const cont = document.getElementById('final-overview');
      if (!cont) return;
      cont.innerHTML = '';

      let completed = 0;
      let total = 0;

      for (let bIdx = 0; bIdx < buildingsState.count; bIdx++){
        const buildingLabel = `Bygning ${bIdx+1}`;
        const buildingNameRaw = String(buildingsState.titles[bIdx] || '').trim();
        const b = buildingsState.buildings[bIdx];
        if (!b) continue;

        const sectionCount = (b.count || 1);
        const isDefaultBuildingName = (name) => {
          const n = String(name || '').trim();
          if (!n) return true;
          if (n.toLowerCase() === buildingLabel.toLowerCase()) return true;
          return false;
        };

        // If the building title is missing/default, and there is only 1 section,
        // use the section title as a helpful building name for navigation.
        const firstSectionNameRaw = String(b.titles?.[0] || '').trim();
        const derivedBuildingName = (!isDefaultBuildingName(buildingNameRaw) ? buildingNameRaw : ((sectionCount === 1 && firstSectionNameRaw) ? firstSectionNameRaw : ''));
        const buildingHeaderTitle = derivedBuildingName ? `${buildingLabel} - ${derivedBuildingName}` : buildingLabel;

        // Building header
        const header = document.createElement('div');
        header.style.cssText = 'margin-top: 6px; padding: 10px 12px; font-weight: 800; color:var(--c-heading); background:var(--c-surface-subtle); border:1px solid var(--c-border-strong); border-radius: 10px;';
        header.textContent = buildingHeaderTitle;
        cont.appendChild(header);

        for (let i = 0; i < sectionCount; i++){
          const sectionNameRaw = String(b.titles?.[i] || '').trim();
          let sectionTitle = sectionNameRaw ? sectionNameRaw : `Bygningsafsnit ${i+1}`;

          // Avoid duplicate title like "Bygning 1 - Villa - Villa" when the building title is derived from the only section.
          if (derivedBuildingName && sectionTitle && sectionTitle.toLowerCase() === derivedBuildingName.toLowerCase()) {
            sectionTitle = `Bygningsafsnit ${i+1}`;
          }

          const title = derivedBuildingName
            ? `${buildingLabel} - ${derivedBuildingName} - ${sectionTitle}`
            : `${buildingLabel} - ${sectionTitle}`;
          const evalRes = b.evaluations[i];
          const ak = evalRes?.anvendelseskategori?.value ?? '-';
          const rk = evalRes?.risikoklasse?.value ?? '-';
          const bilagRaw = evalRes?.relevant_bilag?.value ?? evalRes?.relevant_bilag ?? '-';
          const bk = evalRes?.brandklasse?.value ?? '-';
          const bkNum = (() => {
            const n = parseInt(bk, 10);
            return Number.isFinite(n) ? n : null;
          })();
          const done = (b.progress[i]?.evaluated && b.progress[i]?.requirementsViewed);

          total++;
          if (done) completed++;

          const row = document.createElement('div');
          row.style.cssText = 'display:flex; align-items:stretch; gap:0; border:1px solid var(--c-border-strong); border-radius:12px; overflow:hidden; background:var(--c-surface);';
          const docActionHtml = (bkNum === 1 || bkNum === 2)
            ? (() => {
                const label = (bkNum === 1) ? 'Dokumentation (myndigheder)' : 'Dokumentation (dialog)';
                return `
                  <div style="width: 260px; padding:16px; border-left:1px solid var(--c-border-strong); background:var(--c-surface); display:flex; flex-direction:column; justify-content:center;">
                    <button type="button" class="btn-secondary" data-doc-action="1" aria-label="${label}" style="padding: 10px 12px; font-size: 13px; font-weight: 600;">
                      📄 ${label}
                    </button>
                  </div>
                `;
              })()
            : '';

          const bkInfoHtml = (bkNum === 1 || bkNum === 2)
            ? (() => {
                const t = (bkNum === 1)
                  ? 'BK1: Udkastet kan bruges som dokumentation til myndigheder (kommunalbestyrelsen).'
                  : 'BK2: Udkastet kan bruges som dialoggrundlag med brandrådgiver. Den endelige dokumentation udarbejdes af certificeret brandrådgiver.';
                const safeTitle = t.replace(/\"/g,'&quot;');
                return `<button type="button" data-bk-info="1" title="${safeTitle}" aria-label="Info om hvad dokumentationen kan bruges til" style="width:18px; height:18px; border-radius:999px; border:1px solid var(--c-border); background:var(--c-surface); color:var(--c-text-muted); font-size:12px; line-height:1; display:inline-flex; align-items:center; justify-content:center; padding:0; cursor:help;">i</button>`;
              })()
            : '';

          row.innerHTML = `
            <div style="flex:2; padding:16px; border-right:1px solid var(--c-border);">
              <div style="font-weight:700; font-size:16px; color:var(--c-text); margin-bottom:8px;">${title}</div>
              <div style="display:flex; gap:8px; align-items:center;">
                <span style="display:inline-flex; align-items:center; padding:4px 8px; background:${done ? 'var(--c-bg-2)' : 'var(--c-surface-muted)'}; color:${done ? 'var(--c-accent)' : 'var(--c-primary)'}; border:1px solid ${done ? 'var(--c-accent)' : 'var(--c-primary)'}; border-radius:6px; font-size:12px; font-weight:600;">
                  ${done ? '✓ Færdig' : '⚠ Mangler'}
                </span>
              </div>
            </div>
            <div style="flex:1; padding:16px; border-right:1px solid var(--c-border); background:var(--c-surface-muted);">
              <div style="font-size:11px; color:var(--c-text-muted); margin-bottom:4px; text-transform:uppercase; letter-spacing:0.5px;">Anvendelseskategori</div>
              <div style="font-weight:600; font-size:18px; color:var(--c-text);">${ak}</div>
            </div>
            <div style="flex:1; padding:16px; border-right:1px solid var(--c-border); background:var(--c-surface-muted);">
              <div style="font-size:11px; color:var(--c-text-muted); margin-bottom:4px; text-transform:uppercase; letter-spacing:0.5px;">Risikoklasse</div>
              <div style="font-weight:600; font-size:18px; color:var(--c-text);">${rk}</div>
            </div>
            <div style="flex:1; padding:16px; border-right:1px solid var(--c-border); background:var(--c-surface-muted);">
              <div style="font-size:11px; color:var(--c-text-muted); margin-bottom:4px; text-transform:uppercase; letter-spacing:0.5px;">Bilag</div>
              <div style="font-weight:600; font-size:18px; color:var(--c-text);">${bilagRaw}</div>
            </div>
            <div style="flex:1; padding:16px; background:var(--c-bg-2);">
              <div style="display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:4px;">
                <div style="font-size:11px; color:var(--c-text-muted); text-transform:uppercase; letter-spacing:0.5px;">Brandklasse</div>
                ${bkInfoHtml}
              </div>
              <div style="font-weight:700; font-size:24px; color:var(--c-primary);">${bk}</div>
            </div>
            ${docActionHtml}
          `;

          row.style.cursor = 'pointer';
          row.onclick = () => {
            setActiveBuildingIndex(bIdx);
            setActiveSectionIndex(i);
            goToStep(buildingsState.buildings[bIdx]?.lastStep?.[i] || 1);
          };

          // Wire documentation action (avoid triggering row navigation)
          try {
            const btn = row.querySelector('button[data-doc-action="1"]');
            if (btn) {
              btn.addEventListener('click', (ev) => {
                ev.preventDefault();
                ev.stopPropagation();
                setActiveBuildingIndex(bIdx);
                setActiveSectionIndex(i);
                openDocGeneratorOverlay({ buildingIndex: bIdx, sectionIndex: i, brandklasse: bkNum });
              });
            }
          } catch (_) {}

          // Info circle should not trigger navigation
          try {
            const infoBtn = row.querySelector('button[data-bk-info="1"]');
            if (infoBtn) {
              infoBtn.addEventListener('click', (ev) => {
                ev.preventDefault();
                ev.stopPropagation();
              });
            }
          } catch (_) {}

          cont.appendChild(row);
        }
      }

      // Update summary counts
      const sum = document.getElementById('final-summary');
      
      if (sum){
        if (completed === total && total > 0) {
          sum.innerHTML = `<strong>✓ Alle ${total} bygningsafsnit er færdige!</strong><br>Du kan nu eksportere dataene eller starte et nyt projekt.`;
          sum.style.background = 'var(--c-bg-2)';
          sum.style.color = 'var(--c-accent)';
        } else {
          sum.innerHTML = `<strong>${completed} af ${total} bygningsafsnit er færdige.</strong><br>Gå tilbage til de manglende afsnit for at færdiggøre projektet.`;
          sum.style.background = 'var(--c-surface-muted)';
          sum.style.color = 'var(--c-primary)';
        }
      }
      
      // Update header counts
      document.getElementById('summary-completed-count').textContent = completed;
      document.getElementById('summary-total-count').textContent = total;
      
      // Next-steps guide removed (tooltips live on per-section buttons instead)
    }
    
    function updateNextStepsGuide() {
      // (UI removed)
      return;
      
      // Collect all evaluations
      const allEvals = [];
      for (let bIdx = 0; bIdx < buildingsState.count; bIdx++) {
        const b = buildingsState.buildings[bIdx];
        if (!b) continue;
        const buildingTitle = buildingsState.titles[bIdx] || `Bygning ${bIdx+1}`;
        for (let i = 0; i < (b.count || 1); i++) {
          const evalRes = b.evaluations[i];
          if (evalRes && evalRes.brandklasse?.value) {
            allEvals.push({
              buildingIndex: bIdx,
              index: i,
              title: `${buildingTitle} — ${b.titles[i] || `Bygningsafsnit ${i+1}`}`,
              brandklasse: parseInt(evalRes.brandklasse.value) || null,
              anvendelseskategori: evalRes.anvendelseskategori?.value,
              risikoklasse: evalRes.risikoklasse?.value,
              relevant_bilag: evalRes.relevant_bilag?.value || evalRes.relevant_bilag,
              bygningstype: b.inputData?.[i]?.bygningstype || 'N/A',
              certificeringsniveau: evalRes.bilag_outputs?.brandrådgiver_certificeringsniveau || 
                                   evalRes.bilag_outputs?.['brandrådgiver_certificeringsniveau'] ||
                                   null
            });
          }
        }
      }
      
      if (allEvals.length === 0) {
        guideContainer.style.display = 'none';
        return;
      }
      
      // Find highest brandklasse (worst case) and corresponding certification level
      const highestBK = Math.max(...allEvals.map(e => e.brandklasse || 0));
      const highestBKSection = allEvals.find(e => e.brandklasse === highestBK);
      const bk1Sections = allEvals.filter(e => e.brandklasse === 1);
      
      guideContainer.style.display = 'block';
      
      if (highestBK === 1 || highestBK === 2) {
        const bilagText = bk1Sections[0]?.relevant_bilag ? `bilag ${formatBilagDisplayId(bk1Sections[0].relevant_bilag)}` : 'de præ-accepterede løsninger';
        const isBk1 = highestBK === 1;
        const docTone = isBk1 ? 'var(--c-accent)' : 'var(--c-primary)';
        guideContainer.innerHTML = `
          <div style="border: 2px solid ${docTone}; border-radius: 12px; overflow: hidden; background: var(--c-surface);">
            <div style="background: ${docTone}; color: var(--c-on-primary); padding: 20px 24px;">
              <h3 style="margin: 0 0 8px 0; font-size: 20px; font-weight: 700;">✅ Næste skridt: Dokumentation</h3>
              <p style="margin: 0; font-size: 15px; opacity: 0.95;">Dit projekt er indplaceret i <strong>Brandklasse ${highestBK}</strong></p>
            </div>
            
            <div style="padding: 28px;">
              <p style="margin: 0 0 16px 0; font-size: 15px; color: var(--c-text); line-height: 1.7;">
                ${isBk1
                  ? `Dit projekt er indplaceret i <strong>Brandklasse 1</strong> ud fra de præ-accepterede løsninger i henhold til <strong>${bilagText}</strong>. Næste skridt er at udfylde dokumentation for dit byggeri.`
                  : `Dit projekt er indplaceret i <strong>Brandklasse 2</strong>. Du kan generere et udkast, der kan bruges som dialoggrundlag med en brandrådgiver.`}
              </p>

              <p style="margin: 0; font-size: 14px; color: var(--c-text-muted); line-height: 1.6;">
                Brug knappen <strong>“Dokumentation”</strong> ud for hvert bygningsafsnit i oversigten ovenfor.
              </p>
            </div>
          </div>
        `;
      } else {
        // Brandklasse 2, 3, or 4 - need certified advisor
        // Use the actual certification level from the decision model
        const certLevel = highestBKSection?.certificeringsniveau || highestBK;
        const certRequirement = getCertificationRequirement(certLevel);
        guideContainer.innerHTML = `
          <div style="border: 2px solid var(--c-primary); border-radius: 12px; overflow: hidden; background: var(--c-surface);">
            <div style="background: var(--c-primary); color: var(--c-on-primary); padding: 20px 24px;">
              <h3 style="margin: 0 0 8px 0; font-size: 20px; font-weight: 700;">⚠️ Næste skridt: Kontakt brandrådgiver</h3>
              <p style="margin: 0; font-size: 15px; opacity: 0.95;">Dit projekt er indplaceret i <strong>Brandklasse ${highestBK}</strong></p>
            </div>
            
            <div style="padding: 28px;">
              <p style="margin: 0 0 20px 0; font-size: 15px; color: var(--c-text); line-height: 1.7;">
                Dit projekt er indplaceret i <strong>Brandklasse ${highestBK}</strong>, hvilket betyder at du skal kontakte en brandrådgiver 
                med den korrekte certificering for at udarbejde den nødvendige dokumentation.
              </p>
              
              <div style="background: var(--c-surface-muted); border: 2px solid var(--c-primary); border-radius: 10px; padding: 20px; margin-bottom: 24px;">
                <h4 style="margin: 0 0 12px 0; font-size: 16px; font-weight: 700; color: var(--c-primary);">Krævet certificering:</h4>
                <p style="margin: 0; font-size: 15px; color: var(--c-text); line-height: 1.6;">
                  <strong>${certRequirement}</strong>
                </p>
              </div>
              
              <p style="margin: 0; font-size: 14px; color: var(--c-text-muted); line-height: 1.6;">
                <strong>Bemærk:</strong> Værktøjet har givet dig en indledende klassificering, men den endelige vurdering og dokumentation 
                skal udarbejdes af en certificeret brandrådgiver. Kontakt en rådgiver med ovenstående certificering for at fortsætte dit projekt.
              </p>
            </div>
          </div>
        `;
      }
    }
    
    function getCertificationRequirement(certLevel) {
      // certLevel can be a number (2, 3, 4) or a string
      const level = parseInt(certLevel) || certLevel;
      
      if (level === 2 || level === '2') {
        return 'Brandrådgiver certificeret til Brandklasse 2 (BK2)';
      } else if (level === 3 || level === '3') {
        return 'Brandrådgiver certificeret til Brandklasse 3 (BK3) eller højere';
      } else if (level === 4 || level === '4') {
        return 'Brandrådgiver certificeret til Brandklasse 4 (BK4) - højeste certificeringsniveau';
      }
      // Fallback - should not happen if data is correct
      return 'Certificeret brandrådgiver';
    }

    function updateStatus(){
      const d = new Date();
      const hh = String(d.getHours()).padStart(2,'0');
      const mm = String(d.getMinutes()).padStart(2,'0');
      document.getElementById('status-line').textContent = `Sidst opdateret: ${hh}:${mm}`;
    }
    
    function openDocGeneratorOverlay(opts) {
      const overlay = document.getElementById('doc-generator-overlay');
      if (!overlay) return;

      const options = (opts && typeof opts === 'object') ? opts : {};

      const setOverlayModeTexts = (bkMode) => {
        const bk = Number.isFinite(Number(bkMode)) ? Number(bkMode) : 1;
        const kicker = document.getElementById('doc-generator-kicker');
        const title = document.getElementById('doc-generator-title');
        const subtitle = document.getElementById('doc-generator-subtitle');
        const intro = document.getElementById('doc-generator-intro');
        const previewBk = document.getElementById('doc-preview-bk');

        if (previewBk) previewBk.textContent = String(bk);

        if (bk === 2) {
          if (kicker) kicker.textContent = 'Brandklasse 2 Dokumentation';
          if (title) title.textContent = 'Generer dokumentationsudkast til dialog med brandrådgiver';
          if (subtitle) subtitle.textContent = 'Udfyld projektinformation nedenfor. Værktøjet genererer automatisk et udkast som dialoggrundlag.';
          if (intro) intro.textContent = 'Dette udkast kan bruges som dialoggrundlag med en brandrådgiver. Den endelige vurdering og dokumentation skal udarbejdes af en certificeret brandrådgiver.';
        } else {
          if (kicker) kicker.textContent = 'Brandklasse 1 Dokumentation';
          if (title) title.textContent = 'Generer dokumentation til kommunalbestyrelsen';
          if (subtitle) subtitle.textContent = 'Udfyld projektinformation nedenfor. Værktøjet genererer automatisk den tekniske information.';
          if (intro) intro.textContent = 'Der skal udarbejdes dokumentation for brandforhold, som redegør for, hvordan brandsikkerheden i enfamiliehuset påtænkes udført, og som dokumenterer, at byggeriet er i overensstemmelse med de præ-accepterede løsninger. For byggeri omfattet af brandklasse 1 skal dokumentationen for brandforhold omfatte alt relevant materiale for byggeriet. Dette inkluderer overordnede beskrivelser og forudsætninger, en redegørelse for valg af brandklasse samt oplysninger om og dokumentation for byggeriets indsatsmæssige forhold.';
        }
      };

      // Cross-field sync state (avoid left/right override loops)
      if (!overlay.__docSyncState) {
        overlay.__docSyncState = { syncingFromInputs: false, syncingFromDraft: false, draftSyncTimer: null };
      }

      const liveText = document.getElementById('doc-live-text');
      const refreshBtn = document.getElementById('doc-gen-refresh');
      const placeholderRoot = document.getElementById('doc-placeholder-fields');
      const placeholderSummary = document.getElementById('doc-placeholder-summary');

      const getProjectInfoFromInputs = () => ({
        projektnavn: (document.getElementById('doc-projektnavn')?.value || '').trim(),
        adresse: (document.getElementById('doc-adresse')?.value || '').trim(),
        bygherre: (document.getElementById('doc-bygherre')?.value || '').trim(),
        raadgiver: (document.getElementById('doc-raadgiver')?.value || '').trim(),
      });

      const normalizePlaceholderLabel = (label) => {
        return String(label || '')
          .replace(/\s+/g, ' ')
          .replace(/\u00A0/g, ' ')
          .trim();
      };

      const placeholderKey = (type, label) => {
        const t = String(type || '').trim().toUpperCase();
        const l = normalizePlaceholderLabel(label).toLowerCase();
        return `${t}:${l}`;
      };

      const extractDocPlaceholders = (text) => {
        const out = [];
        const s = String(text || '');
        const re = /\[(UDFYLD|VEDLÆG):\s*([\s\S]*?)\]/g;
        let m;
        while ((m = re.exec(s)) !== null) {
          const type = String(m[1] || '').trim().toUpperCase();
          const rawLabel = String(m[2] || '');
          const label = normalizePlaceholderLabel(rawLabel);
          const token = m[0];
          if (!label) continue;

          // Avoid duplicating the 4 header placeholders already covered by Projektinformation.
          const headerLabels = new Set([
            'projektnavn',
            'adresse/matrikel',
            'adresse og matrikel',
            'adresse',
            'bygherre',
            'rådgiver',
            'raadgiver'
          ]);
          if (type === 'UDFYLD' && headerLabels.has(label.toLowerCase())) continue;

          out.push({ type, label, token, key: placeholderKey(type, label) });
        }

        // De-duplicate by key (keep the first occurrence's token for replacement)
        const seen = new Set();
        const uniq = [];
        for (const p of out) {
          if (seen.has(p.key)) continue;
          seen.add(p.key);
          uniq.push(p);
        }
        return uniq;
      };

      const ensurePlaceholderState = () => {
        if (!overlay.__docPlaceholderState) {
          overlay.__docPlaceholderState = {
            values: {},
            attachments: {},
            placeholders: null,
            baseDraft: null,
            renderTimer: null,
            applyTimer: null
          };
        }
        return overlay.__docPlaceholderState;
      };

      const ACCEPT_ATTACHMENT_TYPES = '.pdf,.png,.jpg,.jpeg';

      const getAttachmentFilesFor = (key) => {
        const state = ensurePlaceholderState();
        const entry = state.attachments?.[key];
        if (!entry || !Array.isArray(entry.files)) return [];
        return entry.files;
      };

      const setAttachmentFilesFor = (key, files) => {
        const state = ensurePlaceholderState();
        state.attachments[key] = { files: Array.isArray(files) ? files : [] };
      };

      const formatVedlaegReplacementText = (placeholder, files) => {
        const p = placeholder;
        const list = Array.isArray(files) ? files : [];
        if (list.length === 0) return '';

        const isMulti = /brandplan|brandtegning|brandtegn/i.test(String(p?.label || ''));
        const formatOne = (f) => {
          const name = f?.file?.name || f?.name || '';
          const caption = String(f?.caption || '').trim();
          if (!name) return '';
          return caption ? `${name} — ${caption}` : name;
        };

        if (!isMulti) {
          const line = formatOne(list[0]);
          return line ? `Vedlagt: ${line}` : '';
        }

        const lines = list.map(formatOne).filter(Boolean);
        if (lines.length === 0) return '';
        return ['Vedlagte filer:', ...lines.map(l => `- ${l}`)].join('\n');
      };

      const updateVedlaegValueForPlaceholder = (placeholder) => {
        const state = ensurePlaceholderState();
        const files = getAttachmentFilesFor(placeholder.key);
        const text = formatVedlaegReplacementText(placeholder, files);
        if (text) state.values[placeholder.key] = text;
        else state.values[placeholder.key] = '';
      };

      const setBaseDraftIfPossible = (nextBaseDraft) => {
        const state = ensurePlaceholderState();
        const s = String(nextBaseDraft || '');
        if (!s.trim()) return;
        state.baseDraft = s;
        state.placeholders = extractDocPlaceholders(s);
      };

      const getStablePlaceholders = () => {
        const state = ensurePlaceholderState();
        if (Array.isArray(state.placeholders)) return state.placeholders;
        // Fallback: derive from current draft once.
        const derived = extractDocPlaceholders(liveText?.value || '');
        state.placeholders = derived;
        return derived;
      };

      const updatePlaceholderSummaryText = () => {
        const state = ensurePlaceholderState();
        const placeholders = getStablePlaceholders();
        if (!placeholderSummary) return;
        if (!placeholders.length) {
          placeholderSummary.textContent = 'Ingen [UDFYLD: …] / [VEDLÆG: …] felter fundet i udkastet.';
          return;
        }
        let missingCount = 0;
        for (const p of placeholders) {
          if (p.type === 'VEDLÆG') {
            const files = getAttachmentFilesFor(p.key);
            if (!files.length) missingCount++;
          } else {
            const currentVal = String(state.values?.[p.key] ?? '').trim();
            if (!currentVal) missingCount++;
          }
        }
        placeholderSummary.textContent = `Manglende udfyldning: ${missingCount} / ${placeholders.length}`;
      };

      const applyPlaceholderValuesIntoDraft = () => {
        if (!liveText) return;
        if (!placeholderRoot) return;
        if (overlay.__docSyncState?.syncingFromDraft) return;

        const state = ensurePlaceholderState();
        const placeholders = getStablePlaceholders();
        if (!placeholders.length) return;

        const base = (state.baseDraft && String(state.baseDraft).trim().length > 0)
          ? state.baseDraft
          : liveText.value;

        const s0 = liveText.selectionStart;
        const s1 = liveText.selectionEnd;

        overlay.__docSyncState.syncingFromInputs = true;
        try {
          let next = String(base);
          for (const p of placeholders) {
            const value = String(state.values?.[p.key] ?? '').trim();
            if (!value) continue;
            // Replace all occurrences of the *current* token string.
            next = next.split(p.token).join(value);
          }
          liveText.value = next;
          liveText.setAttribute('data-dirty', 'true');
        } finally {
          overlay.__docSyncState.syncingFromInputs = false;
        }

        try {
          if (typeof s0 === 'number' && typeof s1 === 'number') {
            liveText.setSelectionRange(Math.min(s0, liveText.value.length), Math.min(s1, liveText.value.length));
          }
        } catch(_) {}
      };

      const renderDocPlaceholderInputs = () => {
        if (!placeholderRoot || !liveText) return;
        const state = ensurePlaceholderState();

        const placeholders = getStablePlaceholders();
        placeholderRoot.innerHTML = '';

        if (!placeholders.length) {
          if (placeholderSummary) placeholderSummary.textContent = 'Ingen [UDFYLD: …] / [VEDLÆG: …] felter fundet i udkastet.';
          const empty = document.createElement('div');
          empty.className = 'muted';
          empty.style.marginTop = '10px';
          empty.textContent = 'Når udkastet indeholder udfyldningsfelter, vises de her.';
          placeholderRoot.appendChild(empty);
          return;
        }

        const buildStep3DocsSummary = () => {
          const box = document.createElement('div');
          box.style.marginTop = '12px';
          box.style.border = '1px solid var(--c-border-strong)';
          box.style.borderRadius = '12px';
          box.style.padding = '12px';
          box.style.background = 'var(--c-surface-subtle)';
          box.style.color = 'var(--c-text)';

          const title = document.createElement('div');
          title.style.fontWeight = '700';
          title.style.color = 'var(--c-text)';
          title.textContent = 'Bilag fra trin 3 (tilknyttet krav)';

          const sub = document.createElement('div');
          sub.className = 'muted';
          sub.style.marginTop = '4px';
          sub.style.lineHeight = '1.5';
          sub.textContent = 'Bilag du har uploadet ud for krav/kravgrupper i trin 3. Redigér/tilføj bilag i trin 3.';

          const list = document.createElement('div');
          list.style.marginTop = '10px';

          const collectDocsAcrossBuildings = () => {
            const ctx = overlay?.__docContext;
            if (ctx && ctx.scope === 'single' && Number.isFinite(Number(ctx.buildingIndex)) && Number.isFinite(Number(ctx.sectionIndex))) {
              const b = Number(ctx.buildingIndex);
              const i = Number(ctx.sectionIndex);
              const st = buildingsState?.buildings?.[b];
              if (!st) return [];

              const docsByCategory = st.kravCategoryDocs?.[String(i)] || {};
              const order = st.kravCategoryOrder?.[String(i)];
              const categories = sortCategoryLabelsByOrder(
                Object.keys(docsByCategory)
                  .filter(k => Array.isArray(docsByCategory[k]) && docsByCategory[k].length > 0),
                order
              );
              if (!categories.length) return [];

              const evalRes = st.evaluations?.[i];
              const bk = (evalRes && evalRes.brandklasse?.value !== undefined) ? evalRes.brandklasse.value : (evalRes?.brandklasse ?? null);

              return [{
                buildingIndex: b,
                sectionIndex: i,
                sectionTitle: st.titles?.[i] || `Bygningsafsnit ${i+1}`,
                brandklasse: bk,
                docsByCategory
              }];
            }

            const out = [];
            const buildingCount = Number.isFinite(Number(buildingsState?.count))
              ? Number(buildingsState.count)
              : (buildingsState?.buildings ? Object.keys(buildingsState.buildings).length : 1);

            for (let b = 0; b < buildingCount; b++) {
              const st = buildingsState?.buildings?.[b];
              if (!st) continue;
              const sectionCount = Number.isFinite(Number(st.count)) ? Number(st.count) : 0;
              for (let i = 0; i < sectionCount; i++) {
                const docsByCategory = st.kravCategoryDocs?.[String(i)] || {};
                const order = st.kravCategoryOrder?.[String(i)];
                const categories = sortCategoryLabelsByOrder(
                  Object.keys(docsByCategory)
                    .filter(k => Array.isArray(docsByCategory[k]) && docsByCategory[k].length > 0),
                  order
                );
                if (!categories.length) continue;

                const evalRes = st.evaluations?.[i];
                const bk = (evalRes && evalRes.brandklasse?.value !== undefined) ? evalRes.brandklasse.value : (evalRes?.brandklasse ?? null);

                out.push({
                  buildingIndex: b,
                  sectionIndex: i,
                  sectionTitle: st.titles?.[i] || `Bygningsafsnit ${i+1}`,
                  brandklasse: bk,
                  docsByCategory
                });
              }
            }
            return out;
          };

          const entries = collectDocsAcrossBuildings();
          if (!entries.length) {
            const empty = document.createElement('div');
            empty.className = 'muted';
            empty.textContent = 'Ingen bilag tilføjet i trin 3 endnu.';
            list.appendChild(empty);
          } else {
            for (const entry of entries) {
              const sectionHdr = document.createElement('div');
              sectionHdr.style.fontWeight = '700';
              sectionHdr.style.marginTop = '10px';

              const bkTxt = (entry.brandklasse !== null && entry.brandklasse !== undefined && String(entry.brandklasse).trim() !== '')
                ? ` (BK${entry.brandklasse})`
                : '';
              sectionHdr.textContent = `Bygning ${entry.buildingIndex + 1} / Bygningsafsnit ${entry.sectionIndex + 1}: ${entry.sectionTitle}${bkTxt}`;
              list.appendChild(sectionHdr);

              const cats = Object.keys(entry.docsByCategory)
                .filter(k => Array.isArray(entry.docsByCategory[k]) && entry.docsByCategory[k].length > 0)
                .slice();

              const catsOrdered = sortCategoryLabelsByOrder(cats, buildingsState?.buildings?.[entry.buildingIndex]?.kravCategoryOrder?.[String(entry.sectionIndex)]);

              for (const cat of catsOrdered) {
                const catEl = document.createElement('div');
                catEl.style.marginTop = '6px';
                catEl.style.fontWeight = '600';
                catEl.textContent = cat;
                list.appendChild(catEl);

                const ul = document.createElement('ul');
                ul.style.margin = '6px 0 0 18px';
                ul.style.padding = '0';
                for (const d of (entry.docsByCategory[cat] || [])) {
                  const li = document.createElement('li');
                  const name = String(d?.name || 'fil');
                  const caption = String(d?.caption || '').trim();
                  const desc = String(d?.description || '').trim();
                  li.textContent = caption ? `${name} — ${caption}` : name;
                  if (desc) {
                    const div = document.createElement('div');
                    div.className = 'muted';
                    div.style.marginTop = '2px';
                    div.textContent = desc;
                    li.appendChild(div);
                  }
                  ul.appendChild(li);
                }
                list.appendChild(ul);
              }
            }
          }

          box.appendChild(title);
          box.appendChild(sub);
          box.appendChild(list);
          return box;
        };

        let insertedStep3Docs = false;

        for (const p of placeholders) {
          const currentVal = String(state.values?.[p.key] ?? '').trim();

          const wrapper = document.createElement('div');
          wrapper.className = 'form-field';

          const label = document.createElement('label');
          const typePrefix = (p.type === 'VEDLÆG') ? 'Vedlæg' : 'Udfyld';
          if (p.type === 'VEDLÆG') {
            const raw = String(p.label || '').trim();
            if (/^situationsplan\b/i.test(raw)) {
              label.textContent = 'Vedlæg situationsplan';
            } else if (/^brandplan/i.test(raw) || /^brandplaner/i.test(raw) || /brandtegning|brandtegn/i.test(raw)) {
              label.textContent = 'Vedlæg brandplaner';
            } else {
              label.textContent = `${typePrefix}: ${p.label}`;
            }
          } else {
            label.textContent = `${typePrefix}: ${p.label}`;
          }
          wrapper.appendChild(label);

          const wantsYesNo = /\bja\s*\/\s*nej\b/i.test(p.label);
          const useTextarea = (!wantsYesNo) && (p.label.length > 80 || /\bbeskriv\b|\bsuppl[ée]r\b|\bforuds[æa]tninger\b/i.test(p.label));

          let input;

          const addHelpText = (text) => {
            const t = String(text || '').trim();
            if (!t) return;
            const help = document.createElement('div');
            help.className = 'muted';
            help.style.marginTop = '2px';
            help.style.lineHeight = '1.5';
            help.textContent = t;
            wrapper.appendChild(help);
          };

          // Guidance for the notat field (shown above the textarea)
          if (p.type === 'UDFYLD' && /^notat\b/i.test(String(p.label || '').trim())) {
            addHelpText('For overskuelighedens skyld bør der herudover vedlægges et notat, som beskriver, hvorledes afstandsforhold, bærende konstruktioner, indvendige og udvendige overflader samt redningsberedskabets indsatsforhold udføres i henhold til de præ-accepterede løsninger.');
          }

          if (p.type === 'VEDLÆG') {
            // Render upload UI + per-file caption, and auto-insert into draft.
            const isMulti = /brandplan|brandtegning|brandtegn/i.test(String(p.label || ''));
            const isSituationsplan = /^situationsplan\b/i.test(String(p.label || '').trim());

            if (isSituationsplan) {
              addHelpText('Dokumentationen skal endvidere omfatte relevant tegningsmateriale, herunder en situationsplan, der viser bygningernes placering på ejendommen i forhold til anden bebyggelse, naboskel samt vej- og stimidte.');
            } else if (isMulti) {
              addHelpText('Der skal desuden udarbejdes en brandplan, som viser bygningens eventuelle opdeling i brandmæssige enheder samt placering af røgalarmer og eventuelle redningsåbninger.');
            }

            const box = document.createElement('div');
            box.className = 'doc-attachment-box';

            const row = document.createElement('div');
            row.className = 'doc-attachment-row';

            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = ACCEPT_ATTACHMENT_TYPES;
            fileInput.multiple = !!isMulti;

            const hint = document.createElement('div');
            hint.className = 'muted';
            hint.style.fontSize = '12px';
            hint.textContent = isMulti
              ? 'Upload én eller flere filer (PDF/JPG/PNG). Tilføj billedtekst pr. fil.'
              : 'Upload en fil (PDF/JPG/PNG) og angiv en billedtekst.';

            row.appendChild(fileInput);
            box.appendChild(row);
            box.appendChild(hint);

            const list = document.createElement('div');
            list.className = 'doc-attachment-list';
            box.appendChild(list);

            const renderList = () => {
              list.innerHTML = '';
              const files = getAttachmentFilesFor(p.key);
              if (!files.length) {
                const empty = document.createElement('div');
                empty.className = 'muted';
                empty.textContent = 'Ingen filer valgt endnu.';
                list.appendChild(empty);
                return;
              }

              files.forEach((f, idx) => {
                const item = document.createElement('div');
                item.className = 'doc-attachment-item';

                const meta = document.createElement('div');
                meta.className = 'doc-attachment-meta';

                const left = document.createElement('div');
                const fname = f?.file?.name || f?.name || '';
                const ftype = f?.file?.type || f?.type || '';
                left.textContent = fname || `Fil ${idx + 1}`;

                const right = document.createElement('div');
                right.className = 'muted';
                right.textContent = ftype ? ftype : '';

                meta.appendChild(left);
                meta.appendChild(right);
                item.appendChild(meta);

                const caption = document.createElement('input');
                caption.type = 'text';
                caption.placeholder = 'Billedtekst (valgfri)…';
                caption.value = String(f?.caption || '');
                caption.addEventListener('input', () => {
                  const next = getAttachmentFilesFor(p.key);
                  if (!next[idx]) return;
                  next[idx].caption = String(caption.value || '');
                  setAttachmentFilesFor(p.key, next);
                  updateVedlaegValueForPlaceholder(p);
                  scheduleApplyPlaceholdersIntoDraft();
                });
                item.appendChild(caption);

                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'btn-secondary';
                removeBtn.textContent = 'Fjern fra dokument';
                removeBtn.addEventListener('click', () => {
                  const next = getAttachmentFilesFor(p.key).slice();
                  next.splice(idx, 1);
                  setAttachmentFilesFor(p.key, next);
                  updateVedlaegValueForPlaceholder(p);
                  applyPlaceholderValuesIntoDraft();
                  updatePlaceholderSummaryText();
                  renderList();
                });
                item.appendChild(removeBtn);

                list.appendChild(item);
              });
            };

            fileInput.addEventListener('change', async () => {
              let chosen = Array.from(fileInput.files || []);
              try {
                const pdfs = chosen.filter(f => f && ((String(f.type || '').toLowerCase() === 'application/pdf') || /\.pdf$/i.test(String(f.name || ''))));
                if (pdfs.length > 0) {
                  const ok = confirm('PDF-bilag bliver konverteret til billede (side 1) for at kunne indgå i eksport. Fortsæt?');
                  if (ok) {
                    const out = [];
                    for (const f of chosen) {
                      if (f && ((String(f.type || '').toLowerCase() === 'application/pdf') || /\.pdf$/i.test(String(f.name || '')))) {
                        try {
                          const img = await pdfFileToPngFile(f, { pageNumber: 1, scale: 2 });
                          out.push(img);
                        } catch(err) {
                          out.push(f);
                        }
                      } else {
                        out.push(f);
                      }
                    }
                    chosen = out;
                  }
                }
              } catch(_) {}

              const current = getAttachmentFilesFor(p.key);

              // Replace selection (predictable) while attempting to keep existing captions if same filename.
              const next = chosen.map(file => {
                const prev = current.find(x => (x?.file?.name || x?.name) === file.name);
                return { file, name: file.name, type: file.type, caption: prev ? String(prev.caption || '') : '' };
              });

              setAttachmentFilesFor(p.key, next);
              updateVedlaegValueForPlaceholder(p);
              applyPlaceholderValuesIntoDraft();
              updatePlaceholderSummaryText();
              renderList();
            });

            // Initialize from any existing state
            updateVedlaegValueForPlaceholder(p);
            renderList();

            wrapper.appendChild(box);
            placeholderRoot.appendChild(wrapper);
            continue;
          }

          if (wantsYesNo) {
            const sel = document.createElement('select');
            sel.innerHTML = '<option value="" selected>Vælg…</option><option value="JA">JA</option><option value="NEJ">NEJ</option>';
            sel.value = currentVal;
            sel.addEventListener('change', () => {
              state.values[p.key] = String(sel.value || '').trim();
              applyPlaceholderValuesIntoDraft();
              updatePlaceholderSummaryText();
            });
            input = sel;
          } else if (useTextarea) {
            const ta = document.createElement('textarea');
            ta.placeholder = 'Skriv tekst…';
            ta.value = currentVal;
            ta.addEventListener('input', () => {
              state.values[p.key] = String(ta.value || '');
              // Don’t replace continuously while typing large text; apply on a short debounce.
              scheduleApplyPlaceholdersIntoDraft();
            });
            input = ta;
          } else {
            const inp = document.createElement('input');
            inp.type = 'text';
            inp.placeholder = 'Skriv tekst…';
            inp.value = currentVal;
            inp.addEventListener('input', () => {
              state.values[p.key] = String(inp.value || '');
              scheduleApplyPlaceholdersIntoDraft();
            });
            input = inp;
          }

          wrapper.appendChild(input);
          placeholderRoot.appendChild(wrapper);

          // Insert trin-3 bilag summary right after the “Notat om brandteknisk udførelse” field.
          if (!insertedStep3Docs && p.type === 'UDFYLD') {
            const lbl = String(p.label || '').toLowerCase();
            if (lbl.includes('notat om brandteknisk udførelse') || lbl.includes('notat om brandteknisk udfoerelse')) {
              placeholderRoot.appendChild(buildStep3DocsSummary());
              insertedStep3Docs = true;
            }
          }
        }

        // Fallback: if the notat field wasn't present, still show the summary at the end.
        if (!insertedStep3Docs) {
          placeholderRoot.appendChild(buildStep3DocsSummary());
        }

        updatePlaceholderSummaryText();
      };

      const scheduleRenderDocPlaceholderInputs = () => {
        const state = ensurePlaceholderState();
        if (state.renderTimer) clearTimeout(state.renderTimer);
        state.renderTimer = setTimeout(() => {
          state.renderTimer = null;
          renderDocPlaceholderInputs();
        }, 120);
      };

      const scheduleApplyPlaceholdersIntoDraft = () => {
        if (!overlay.__docSyncState) return;
        const state = ensurePlaceholderState();
        if (state.applyTimer) clearTimeout(state.applyTimer);
        state.applyTimer = setTimeout(() => {
          state.applyTimer = null;
          applyPlaceholderValuesIntoDraft();
          updatePlaceholderSummaryText();
        }, 250);
      };

      const syncHeaderIntoDraft = () => {
        if (!liveText) return;
        if (overlay.__docSyncState?.syncingFromDraft) return;
        const projectInfo = getProjectInfoFromInputs();
        const s0 = liveText.selectionStart;
        const s1 = liveText.selectionEnd;
        overlay.__docSyncState.syncingFromInputs = true;
        liveText.value = updateDocHeaderLines(liveText.value, projectInfo);
        overlay.__docSyncState.syncingFromInputs = false;
        try {
          if (typeof s0 === 'number' && typeof s1 === 'number') {
            liveText.setSelectionRange(Math.min(s0, liveText.value.length), Math.min(s1, liveText.value.length));
          }
        } catch(_) {}
      };

      const syncInputsFromDraftHeader = () => {
        if (!liveText) return;
        if (overlay.__docSyncState?.syncingFromInputs) return;
        const parsed = parseProjectInfoFromDraft(liveText.value || '');
        if (!parsed) return;

        const fields = [
          ['doc-projektnavn', 'projektnavn'],
          ['doc-adresse', 'adresse'],
          ['doc-bygherre', 'bygherre'],
          ['doc-raadgiver', 'raadgiver'],
        ];

        overlay.__docSyncState.syncingFromDraft = true;
        try {
          fields.forEach(([id, key]) => {
            const el = document.getElementById(id);
            if (!el) return;
            const nextVal = String(parsed[key] || '').trim();
            if (!nextVal) return;
            if (el.value !== nextVal) el.value = nextVal;
          });
        } finally {
          overlay.__docSyncState.syncingFromDraft = false;
        }
      };

      const scheduleSyncInputsFromDraftHeader = () => {
        if (!overlay.__docSyncState) return;
        if (overlay.__docSyncState.draftSyncTimer) clearTimeout(overlay.__docSyncState.draftSyncTimer);
        overlay.__docSyncState.draftSyncTimer = setTimeout(() => {
          overlay.__docSyncState.draftSyncTimer = null;
          syncInputsFromDraftHeader();
        }, 200);
      };
      
      const collectSingleSectionForDoc = (buildingIndex, sectionIndex) => {
        const bIdx = Number.isFinite(Number(buildingIndex)) ? Number(buildingIndex) : null;
        const sIdx = Number.isFinite(Number(sectionIndex)) ? Number(sectionIndex) : null;
        if (bIdx === null || sIdx === null) return null;
        const st = buildingsState?.buildings?.[bIdx];
        if (!st) return null;
        const evalRes = st.evaluations?.[sIdx];
        if (!evalRes) return null;
        return {
          buildingIndex: bIdx,
          sectionIndex: sIdx,
          title: st.titles?.[sIdx] || `Bygningsafsnit ${sIdx + 1}`,
          data: evalRes,
          inputs: st.inputData?.[sIdx] || {},
          kravCategoryDocs: st.kravCategoryDocs?.[String(sIdx)] || {},
          kravCategoryOrder: st.kravCategoryOrder?.[String(sIdx)] || []
        };
      };

      const parseBkNum = (evalRes) => {
        const v = evalRes?.brandklasse?.value ?? evalRes?.brandklasse;
        const n = parseInt(v, 10);
        return Number.isFinite(n) ? n : null;
      };

      let sections = [];
      let bkMode = Number.isFinite(Number(options.brandklasse)) ? Number(options.brandklasse) : null;

      const single = collectSingleSectionForDoc(options.buildingIndex, options.sectionIndex);
      if (single) {
        sections = [single];
        bkMode = bkMode || parseBkNum(single.data) || 1;
        overlay.__docContext = { scope: 'single', buildingIndex: single.buildingIndex, sectionIndex: single.sectionIndex, brandklasse: bkMode };
      } else {
        // Backwards compatibility: default to BK1 sections across all buildings.
        bkMode = 1;
        sections = collectBk1SectionsAcrossBuildings();
        overlay.__docContext = { scope: 'all', brandklasse: bkMode };
      }

      if (!sections || sections.length === 0) {
        alert('Ingen bygningsafsnit er tilgængelige for dokumentation.');
        return;
      }

      setOverlayModeTexts(bkMode);

      // Populate preview with first section's data
      const firstSection = sections[0];
      const today = new Date().toLocaleDateString('da-DK');
      document.getElementById('doc-preview-dato').textContent = today;
      
      const bygningstype = firstSection.inputs.bygningstype || 'N/A';
      document.getElementById('doc-preview-bygningstype').textContent = 
        bygningstype.charAt(0).toUpperCase() + bygningstype.slice(1);
      
      document.getElementById('doc-preview-ak').textContent = 
        firstSection.data.anvendelseskategori?.value || 'N/A';
      
      document.getElementById('doc-preview-rk').textContent = 
        firstSection.data.risikoklasse?.value || 'N/A';

      // Populate/refresh the editable draft (right side)
      if (liveText) {
        const projectInfo = getProjectInfoFromInputs();
        const isDirty = liveText.getAttribute('data-dirty') === 'true';
        if (!liveText.value.trim() || !isDirty) {
          const draft = buildDocumentTextWithProjectInfo(sections, [], {
            projektnavn: projectInfo.projektnavn || '[UDFYLD: Projektnavn]',
            adresse: projectInfo.adresse || '[UDFYLD: Adresse/Matrikel]',
            bygherre: projectInfo.bygherre || '[UDFYLD: Bygherre]',
            raadgiver: projectInfo.raadgiver || '[UDFYLD: Rådgiver]',
          }, { brandklasse: bkMode, mode: (bkMode === 2 ? 'dialog' : 'myndighed') });
          liveText.value = draft;
          liveText.setAttribute('data-dirty', 'false');
          // Store a stable base draft for placeholder replacement.
          try { setBaseDraftIfPossible(draft); } catch (_) {}
        } else {
          // If user has edited, prefer the draft as source of truth for the header.
          syncInputsFromDraftHeader();
          // If the current draft still contains placeholders, treat it as the new base.
          try {
            const txt = String(liveText.value || '');
            if (/\[(UDFYLD|VEDLÆG):/i.test(txt)) setBaseDraftIfPossible(txt);
          } catch (_) {}
        }
      }

      // Build/refresh the placeholder input list (left side)
      try { renderDocPlaceholderInputs(); } catch (_) {}

      // One-time wiring for the editor controls
      if (!overlay.__docOverlayWired) {
        overlay.__docOverlayWired = true;

        // Mark dirty on manual edits
        if (liveText) {
          liveText.addEventListener('input', () => {
            liveText.setAttribute('data-dirty', 'true');
            scheduleSyncInputsFromDraftHeader();
            // Update the placeholder list when the user edits the draft.
            scheduleRenderDocPlaceholderInputs();
          });
        }

        // Keep header lines in sync when user edits left inputs
        ['doc-projektnavn', 'doc-adresse', 'doc-bygherre', 'doc-raadgiver'].forEach((id) => {
          const el = document.getElementById(id);
          if (!el) return;
          el.addEventListener('input', syncHeaderIntoDraft);
          el.addEventListener('change', syncHeaderIntoDraft);
        });

        // Refresh draft button
        if (refreshBtn) {
          refreshBtn.addEventListener('click', () => {
            const liveText2 = document.getElementById('doc-live-text');
            if (!liveText2) return;

            const ctx = overlay.__docContext || { scope: 'all', brandklasse: 1 };
            let nextBk = Number.isFinite(Number(ctx.brandklasse)) ? Number(ctx.brandklasse) : 1;
            let nextSections = [];
            if (ctx.scope === 'single') {
              const s = collectSingleSectionForDoc(ctx.buildingIndex, ctx.sectionIndex);
              if (s) {
                nextSections = [s];
                nextBk = nextBk || parseBkNum(s.data) || 1;
              }
            }
            if (nextSections.length === 0) {
              nextBk = 1;
              nextSections = collectBk1SectionsAcrossBuildings();
            }

            setOverlayModeTexts(nextBk);

            const p = getProjectInfoFromInputs();
            liveText2.value = buildDocumentTextWithProjectInfo(nextSections, [], {
              projektnavn: p.projektnavn || '[UDFYLD: Projektnavn]',
              adresse: p.adresse || '[UDFYLD: Adresse/Matrikel]',
              bygherre: p.bygherre || '[UDFYLD: Bygherre]',
              raadgiver: p.raadgiver || '[UDFYLD: Rådgiver]',
            }, { brandklasse: nextBk, mode: (nextBk === 2 ? 'dialog' : 'myndighed') });
            liveText2.setAttribute('data-dirty', 'false');

            // Reset base draft for placeholder replacement and refresh the list.
            try { setBaseDraftIfPossible(liveText2.value); } catch (_) {}

            // Re-render placeholders after refresh
            try { renderDocPlaceholderInputs(); } catch (_) {}
          });
        }
      }
      
      // Show overlay
      overlay.style.display = 'flex';
      overlay.setAttribute('aria-hidden', 'false');
      
      // Focus first input
      setTimeout(() => {
        document.getElementById('doc-projektnavn')?.focus();
      }, 100);
    }
    
    function closeDocGeneratorOverlay() {
      const overlay = document.getElementById('doc-generator-overlay');
      if (!overlay) return;
      
      overlay.style.display = 'none';
      overlay.setAttribute('aria-hidden', 'true');
    }

    function collectBk1SectionsAcrossBuildings() {
      const out = [];
      const buildingCount = Number.isFinite(Number(buildingsState?.count))
        ? Number(buildingsState.count)
        : (buildingsState?.buildings ? Object.keys(buildingsState.buildings).length : 1);

      for (let b = 0; b < buildingCount; b++) {
        const st = buildingsState?.buildings?.[b];
        if (!st) continue;
        const sectionCount = Number.isFinite(Number(st.count)) ? Number(st.count) : 0;

        for (let i = 0; i < sectionCount; i++) {
          const evalRes = st.evaluations?.[i];
          if (evalRes && (evalRes.brandklasse?.value === '1' || evalRes.brandklasse?.value === 1)) {
            out.push({
              buildingIndex: b,
              sectionIndex: i,
              title: st.titles?.[i] || `Bygningsafsnit ${i+1}`,
              data: evalRes,
              inputs: st.inputData?.[i] || {},
              kravCategoryDocs: st.kravCategoryDocs?.[String(i)] || {},
              kravCategoryOrder: st.kravCategoryOrder?.[String(i)] || []
            });
          }
        }
      }

      return out;
    }

    function collectSectionsAcrossBuildingsByBrandklasse(targetBk) {
      const out = [];
      const bkTarget = parseInt(targetBk, 10);
      if (!Number.isFinite(bkTarget)) return out;

      const buildingCount = Number.isFinite(Number(buildingsState?.count))
        ? Number(buildingsState.count)
        : (buildingsState?.buildings ? Object.keys(buildingsState.buildings).length : 1);

      for (let b = 0; b < buildingCount; b++) {
        const st = buildingsState?.buildings?.[b];
        if (!st) continue;
        const sectionCount = Number.isFinite(Number(st.count)) ? Number(st.count) : 0;

        for (let i = 0; i < sectionCount; i++) {
          const evalRes = st.evaluations?.[i];
          const v = evalRes?.brandklasse?.value ?? evalRes?.brandklasse;
          const n = parseInt(v, 10);
          if (!evalRes || !Number.isFinite(n) || n !== bkTarget) continue;
          out.push({
            buildingIndex: b,
            sectionIndex: i,
            title: st.titles?.[i] || `Bygningsafsnit ${i+1}`,
            data: evalRes,
            inputs: st.inputData?.[i] || {},
            kravCategoryDocs: st.kravCategoryDocs?.[String(i)] || {},
            kravCategoryOrder: st.kravCategoryOrder?.[String(i)] || []
          });
        }
      }
      return out;
    }
    
    async function generateDocumentFromOverlay() {
      // If the user has typed header fields directly in the draft, make sure the left inputs reflect it.
      const liveTextDraft = document.getElementById('doc-live-text');
      const overlay = document.getElementById('doc-generator-overlay');
      if (liveTextDraft && overlay && overlay.__docSyncState && liveTextDraft.getAttribute('data-dirty') === 'true') {
        try {
          const parsed = parseProjectInfoFromDraft(liveTextDraft.value || '');
          if (parsed) {
            overlay.__docSyncState.syncingFromDraft = true;
            [['doc-projektnavn','projektnavn'],['doc-adresse','adresse'],['doc-bygherre','bygherre'],['doc-raadgiver','raadgiver']].forEach(([id, key]) => {
              const el = document.getElementById(id);
              if (!el) return;
              const nextVal = String(parsed[key] || '').trim();
              if (!nextVal) return;
              el.value = nextVal;
            });
          }
        } catch(_) {}
        finally {
          overlay.__docSyncState.syncingFromDraft = false;
        }
      }

      // NOTE: Exports should work even if not all fields are filled.
      const projektnavn = (document.getElementById('doc-projektnavn')?.value || '').trim();
      const adresse = (document.getElementById('doc-adresse')?.value || '').trim();
      const bygherre = (document.getElementById('doc-bygherre')?.value || '').trim();
      const raadgiver = (document.getElementById('doc-raadgiver')?.value || '').trim();
      
      // Collect sections based on overlay context
      const overlayCtx = overlay?.__docContext || { scope: 'all', brandklasse: 1 };
      const bkMode = Number.isFinite(Number(overlayCtx.brandklasse)) ? Number(overlayCtx.brandklasse) : 1;
      let docSections = [];
      if (overlayCtx.scope === 'single' && Number.isFinite(Number(overlayCtx.buildingIndex)) && Number.isFinite(Number(overlayCtx.sectionIndex))) {
        const bIdx = Number(overlayCtx.buildingIndex);
        const sIdx = Number(overlayCtx.sectionIndex);
        const st = buildingsState?.buildings?.[bIdx];
        const evalRes = st?.evaluations?.[sIdx];
        if (st && evalRes) {
          docSections = [{
            buildingIndex: bIdx,
            sectionIndex: sIdx,
            title: st.titles?.[sIdx] || `Bygningsafsnit ${sIdx + 1}`,
            data: evalRes,
            inputs: st.inputData?.[sIdx] || {},
            kravCategoryDocs: st.kravCategoryDocs?.[String(sIdx)] || {},
            kravCategoryOrder: st.kravCategoryOrder?.[String(sIdx)] || []
          }];
        }
      }
      if (docSections.length === 0) {
        docSections = (bkMode === 1) ? collectBk1SectionsAcrossBuildings() : collectSectionsAcrossBuildingsByBrandklasse(bkMode);
      }

      const liveText = document.getElementById('doc-live-text');
      const projectInfo = {
        projektnavn: projektnavn || '—',
        adresse: adresse || '—',
        bygherre: bygherre || '—',
        raadgiver: raadgiver || '—'
      };

      // If the user has edited the draft, download as-is (only sync header lines first).
      if (liveText && liveText.value.trim() && liveText.getAttribute('data-dirty') === 'true') {
        const finalText = updateDocHeaderLines(liveText.value, projectInfo);
        const today = new Date().toLocaleDateString('da-DK');
        const safeName = (projektnavn || 'projekt').replace(/[^a-zA-Z0-9]/g, '_');
        const blob = new Blob([finalText], {type: 'text/plain;charset=utf-8'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `BK${bkMode}_Dokumentation_${safeName}_${today.replace(/\./g, '-')}.txt`;
        a.click();
        URL.revokeObjectURL(url);
        closeDocGeneratorOverlay();
        return;
      }
      
      // Fetch explanations for all sections
      const explanationPromises = docSections.map(async section => {
        try {
          const resp = await fetch(`${API_BASE}/generate-explanation`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
              inputs: section.inputs,
              results: section.data
            })
          });
          if (resp.ok) {
            const data = await resp.json();
            return data.explanation;
          }
        } catch (e) {
          console.error('Failed to fetch explanation:', e);
        }
        return null;
      });
      
      const explanations = await Promise.all(explanationPromises);

      // Generate document text (and populate the draft textarea for visibility)
      const generated = buildDocumentTextWithProjectInfo(docSections, explanations, projectInfo, { brandklasse: bkMode, mode: (bkMode === 2 ? 'dialog' : 'myndighed') });
      if (liveText) {
        liveText.value = generated;
        liveText.setAttribute('data-dirty', 'false');
      }

      // Download the generated version
      const today = new Date().toLocaleDateString('da-DK');
      const safeName = (projektnavn || 'projekt').replace(/[^a-zA-Z0-9]/g, '_');
      const blob = new Blob([generated], {type: 'text/plain;charset=utf-8'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `BK${bkMode}_Dokumentation_${safeName}_${today.replace(/\./g, '-')}.txt`;
      a.click();
      URL.revokeObjectURL(url);
      
      // Close overlay
      closeDocGeneratorOverlay();
    }

    // ---- Export helpers (HTML/PDF + DOCX) ----
    function getDocOverlayProjectInfoLenient(){
      const projektnavn = (document.getElementById('doc-projektnavn')?.value || '').trim();
      const adresse = (document.getElementById('doc-adresse')?.value || '').trim();
      const bygherre = (document.getElementById('doc-bygherre')?.value || '').trim();
      const raadgiver = (document.getElementById('doc-raadgiver')?.value || '').trim();
      const safeName = (projektnavn || 'projekt').replace(/[^a-zA-Z0-9]/g, '_');
      return {
        projektnavn: projektnavn || '—',
        adresse: adresse || '—',
        bygherre: bygherre || '—',
        raadgiver: raadgiver || '—',
        __safeName: safeName
      };
    }

    function collectAllStep3DocsWithFiles(){
      const out = [];
      const store = getKravDocFileStore();
      const buildingCount = Number.isFinite(Number(buildingsState?.count)) ? Number(buildingsState.count) : 0;
      for (let b = 0; b < buildingCount; b++) {
        const st = buildingsState?.buildings?.[b];
        if (!st) continue;
        const sectionCount = Number.isFinite(Number(st.count)) ? Number(st.count) : 0;
        for (let s = 0; s < sectionCount; s++) {
          const docsByCat = st.kravCategoryDocs?.[String(s)] || {};
          const catsWithDocs = Object.keys(docsByCat || {}).filter(cat => {
            const list = Array.isArray(docsByCat[cat]) ? docsByCat[cat] : [];
            return list.length > 0;
          });
          const orderedCats = sortCategoryLabelsByOrder(catsWithDocs, st.kravCategoryOrder?.[String(s)]);
          for (const cat of orderedCats) {
            const list = Array.isArray(docsByCat[cat]) ? docsByCat[cat] : [];
            for (const meta of list) {
              const id = String(meta?.id || '');
              const file = store[id] || null;
              out.push({
                buildingIndex: b,
                sectionIndex: s,
                sectionTitle: st.titles?.[s] || `Bygningsafsnit ${s + 1}`,
                category: String(cat || '').trim(),
                meta,
                file
              });
            }
          }
        }
      }
      return out;
    }

    function indexToBilagLetters(index){
      // 0 -> A, 25 -> Z, 26 -> AA ...
      let n = Number(index);
      if (!Number.isFinite(n) || n < 0) n = 0;
      n = Math.floor(n);
      let s = '';
      let x = n + 1;
      while (x > 0) {
        const rem = (x - 1) % 26;
        s = String.fromCharCode(65 + rem) + s;
        x = Math.floor((x - 1) / 26);
      }
      return s || 'A';
    }

    function buildStep3BilagLetterIndex(step3ImageItems){
      const items = Array.isArray(step3ImageItems) ? step3ImageItems : [];
      const seen = new Set();
      const itemsWithLetter = [];
      const letterByDocId = {};
      let i = 0;
      for (const it of items) {
        const id = String(it?.meta?.id || '').trim();
        if (!id) continue;
        if (seen.has(id)) continue;
        seen.add(id);
        const letter = indexToBilagLetters(i++);
        letterByDocId[id] = letter;
        itemsWithLetter.push({ ...it, __bilagLetter: letter });
      }
      return { itemsWithLetter, letterByDocId };
    }

    function buildStep3ComplianceSummaryGroups(letterByDocId){
      // NOTE: Despite the historical name, this function returns an ordered per-building/per-section structure.
      // Ordering is preserved to match the Step-3 UI:
      // building order -> section order -> category order -> krav row order -> bullet order.
      const letters = (letterByDocId && typeof letterByDocId === 'object') ? letterByDocId : {};
      const makeCheckKey = (kravId, text) => `${String(kravId || '').trim()}::${String(text || '').trim()}`;

      const decodeGorulesString = (value) => {
        if (value === null || value === undefined) return '';
        let s = String(value);
        s = s.trim();
        if (s.length >= 2 && s.startsWith('"') && s.endsWith('"')) {
          s = s.slice(1, -1);
        }
        s = s
          .replace(/\\r\\n/g, '\n')
          .replace(/\\n/g, '\n')
          .replace(/\\r/g, '\n')
          .replace(/\\t/g, '\t')
          .replace(/\\"/g, '"')
          .replace(/\\\\/g, '\\');
        return s;
      };
      const norm = (v) => decodeGorulesString(v).trim();

      // Match the Step-3 checklist parsing logic (see parseChecklistItems in requirements renderer).
      const parseChecklistItems = (raw) => {
        const s = norm(raw);
        if (!s) return [];
        const text = s.replace(/\r\n/g, '\n');

        if (/\n\s*\n/.test(text)) {
          return text
            .split(/\n\s*\n/)
            .map(x => x.trim())
            .filter(Boolean);
        }

        if (/\n\s*-\s+/.test(text)) {
          return text
            .split(/\n+/)
            .map(l => l.trim())
            .filter(Boolean)
            .map(l => l.replace(/^\s*-\s*/, '').trim())
            .filter(Boolean);
        }

        const one = text.trim();
        if (!one) return [];
        if (/\s-\s/.test(one) && !/^\s*-\s/.test(one)) {
          const parts = one.split(/\s-\s/).map(x => x.trim()).filter(Boolean);
          return parts.length ? parts : [one];
        }
        return [one];
      };

      const buildingCount = Number.isFinite(Number(buildingsState?.count))
        ? Number(buildingsState.count)
        : (buildingsState?.buildings ? Object.keys(buildingsState.buildings).length : 0);

      const out = [];

      for (let b = 0; b < buildingCount; b++) {
        const st = buildingsState?.buildings?.[b];
        if (!st) continue;
        const sectionCount = Number.isFinite(Number(st.count)) ? Number(st.count) : 0;

        for (let s = 0; s < sectionCount; s++) {
          const rowsRaw = st.kravResults?.[s] || st.kravResults?.[String(s)] || [];
          const rows = Array.isArray(rowsRaw) ? rowsRaw : [];
          if (!rows.length) continue;

          // Persisted checklist completion state is stored per bygningsafsnit index.
          const checkState = (() => {
            try {
              const raw = st?.kravChecks;
              const obj = Array.isArray(raw)
                ? raw[s]
                : (raw && typeof raw === 'object' ? (raw[s] || raw[String(s)]) : null);
              return (obj && typeof obj === 'object') ? obj : {};
            } catch(_) {
              return {};
            }
          })();

          const excludedState = (() => {
            try {
              const raw = st?.kravExcluded;
              const obj = Array.isArray(raw)
                ? raw[s]
                : (raw && typeof raw === 'object' ? (raw[s] || raw[String(s)]) : null);
              return (obj && typeof obj === 'object') ? obj : {};
            } catch(_) {
              return {};
            }
          })();

          const noteState = (() => {
            try {
              const raw = st?.kravNotes;
              const obj = Array.isArray(raw)
                ? raw[s]
                : (raw && typeof raw === 'object' ? (raw[s] || raw[String(s)]) : null);
              return (obj && typeof obj === 'object') ? obj : {};
            } catch(_) {
              return {};
            }
          })();

          const docsByCat = (st.kravCategoryDocs && typeof st.kravCategoryDocs === 'object')
            ? (st.kravCategoryDocs[String(s)] || st.kravCategoryDocs[s] || {})
            : {};

          // Category order: prefer the persisted UI order.
          const storedOrder = Array.isArray(st.kravCategoryOrder?.[String(s)]) ? st.kravCategoryOrder[String(s)] : null;
          const catOrder = storedOrder ? storedOrder.slice() : (() => {
            const seen = new Set();
            const ord = [];
            for (const r of rows) {
              const cat = (norm(r?.Krav_Titel) || '').trim();
              if (!cat) continue;
              if (seen.has(cat)) continue;
              seen.add(cat);
              ord.push(cat);
            }
            return ord;
          })();

          const categories = [];
          for (const catNameRaw of catOrder) {
            const catName = String(catNameRaw || '').trim();
            if (!catName) continue;
            const items = [];

            for (let i = 0; i < rows.length; i++) {
              const r = rows[i];
              const rowCat = (norm(r?.Krav_Titel) || '').trim();
              if (rowCat !== catName) continue;

              const kravId = (norm(r?.Krav_id) || `__row_${i}`).trim();
              const bullets = parseChecklistItems(r?.Krav_Tjekliste);
              for (const btxt of bullets) {
                const text = String(btxt || '').trim();
                if (!text) continue;
                const k = makeCheckKey(kravId, text);

                // Excluded items should not appear in the documentation report.
                if (!!excludedState[k]) continue;

                // Determine bilag letters for this checklist item.
                const docLists = (Array.isArray(docsByCat[catName]) ? [docsByCat[catName]] : [])
                  .concat(Object.values(docsByCat).filter(x => Array.isArray(x)));

                const lettersSet = new Set();
                for (const list of docLists) {
                  for (const d of (Array.isArray(list) ? list : [])) {
                    const id = String(d?.id || '').trim();
                    if (!id) continue;
                    const cov = Array.isArray(d?.coversChecklistKeys) ? d.coversChecklistKeys : [];
                    if (!cov.map(x => String(x || '').trim()).includes(String(k || '').trim())) continue;
                    const L = String(letters[id] || '').trim();
                    if (L) lettersSet.add(L);
                  }
                }

                const lettersArr = Array.from(lettersSet).sort((a, b) => a.localeCompare(b, 'en'));
                items.push({ kravId, text, letters: lettersArr, checked: !!checkState[k], note: String(noteState[k] || '') });
              }
            }

            if (items.length) categories.push({ category: catName, items });
          }

          if (!categories.length) continue;
          out.push({
            buildingIndex: b,
            sectionIndex: s,
            sectionTitle: (st.titles?.[s] || `Bygningsafsnit ${s + 1}`),
            categories
          });
        }
      }

      return out;
    }

    function buildStep3ComplianceSummaryLines(groups){
      const sections = Array.isArray(groups) ? groups : [];
      if (!sections.length) return [];

      const lines = [];
      lines.push('Kravliste (dokumentation i bilag)');
      lines.push('Denne kravliste angiver de relevante krav samt hvor dokumentation kan ses i bilag.');
      lines.push('');

      const splitKravIdPrefix = (rawText) => {
        const s = String(rawText || '').trim();
        const m = s.match(/^\s*(K-\d+(?:-\d+){1,4})\s*:\s*(.*)$/i);
        if (m) return { id: String(m[1] || '').trim(), text: String(m[2] || '').trim() };
        return { id: '', text: s };
      };

      for (const sec of sections) {
        const b = Number(sec?.buildingIndex);
        const s = Number(sec?.sectionIndex);
        const secTitle = String(sec?.sectionTitle || '').trim();
        const header = `Bygning ${Number.isFinite(b) ? (b + 1) : '?'} / Bygningsafsnit ${Number.isFinite(s) ? (s + 1) : '?'}${secTitle ? `: ${secTitle}` : ''}`;
        lines.push(header);
        lines.push('');

        const cats = Array.isArray(sec?.categories) ? sec.categories : [];
        for (const g of cats) {
          const cat = String(g?.category || 'Kravgruppe').trim();
          const items = Array.isArray(g?.items) ? g.items : [];
          if (!items.length) continue;
          lines.push(`Kravgruppe: ${cat}`);
          lines.push('');
          for (const it of items) {
            const kravId = String(it?.kravId || '').trim();
            const rawTxt = String(it?.text || '').trim().replace(/\s*\r?\n\s*/g, ' / ');
            const split = splitKravIdPrefix(rawTxt);
            const mainTxt = String(split.text || rawTxt).trim();
            const displayId = String((split.id || kravId) || '').trim();
            const letters = Array.isArray(it?.letters) ? it.letters : [];
            const left = mainTxt + (displayId ? ` (${displayId})` : '');
            const bilagTxt = letters.length ? letters.join(', ') : '';
            const noteTxt = String(it?.note || '').trim().replace(/\s*\r?\n\s*/g, ' / ');
            lines.push(`• ${left}`);
            if (noteTxt) {
              lines.push(`  Dokumentation: ${noteTxt}`);
            }
            if (bilagTxt) {
              lines.push(`  Dokumentation kan ses i bilag ${formatBilagDisplayId(bilagTxt)}.`);
            } else if (!noteTxt) {
              lines.push('  - Der er ikke knyttet dokumentation til dette punkt.');
            }
            lines.push('');
          }
          // extra spacing between categories
          if (lines.length && String(lines[lines.length - 1]).trim()) lines.push('');
        }

        // extra spacing between sections
        if (lines.length && String(lines[lines.length - 1]).trim()) lines.push('');
        lines.push('');
      }

      while (lines.length && !String(lines[lines.length - 1]).trim()) lines.pop();
      return lines;
    }

    function collectOverlayVedlaegWithFiles(){
      const overlay = document.getElementById('doc-generator-overlay');
      const state = overlay?.__docPlaceholderState;
      const attachments = state?.attachments && typeof state.attachments === 'object' ? state.attachments : {};
      const out = [];
      for (const [key, entry] of Object.entries(attachments)) {
        const files = Array.isArray(entry?.files) ? entry.files : [];
        for (const f of files) {
          const file = f?.file || f;
          out.push({
            placeholderKey: String(key || ''),
            name: String(f?.name || file?.name || ''),
            type: String(f?.type || file?.type || ''),
            caption: String(f?.caption || '').trim(),
            file
          });
        }
      }
      return out;
    }

    function buildOverlayVedlaegIndex(items){
      const normalizeKey = (s) => String(s || '')
        .toLowerCase()
        .trim()
        .replace(/\s+/g, '')
        .replace(/[^a-z0-9æøå]/g, '');

      const overlay = document.getElementById('doc-generator-overlay');
      const placeholders = Array.isArray(overlay?.__docPlaceholderState?.placeholders)
        ? overlay.__docPlaceholderState.placeholders
        : [];

      const keyToLabel = {};
      for (const p of placeholders) {
        if (p?.type !== 'VEDLÆG') continue;
        const k = String(p.key || '').trim();
        const lbl = String(p.label || '').trim();
        if (k && lbl) keyToLabel[k] = lbl;
      }

      const idx = {};
      const push = (k, it) => {
        if (!k) return;
        (idx[k] ||= []).push(it);
      };

      for (const it of Array.isArray(items) ? items : []) {
        const rawKey = String(it?.placeholderKey || it?.placeholder || it?.key || '').trim();
        const byInternal = normalizeKey(rawKey);
        push(byInternal, it);

        const lbl = keyToLabel[rawKey] || '';
        const byLabel = normalizeKey(lbl);
        push(byLabel, it);
      }

      return idx;
    }

    function buildVedlaegByFileName(items){
      const norm = (s) => String(s || '').trim().toLowerCase();
      const idx = {};
      for (const it of Array.isArray(items) ? items : []) {
        const name = norm(it?.name || it?.file?.name || '');
        if (!name) continue;
        (idx[name] ||= []).push(it);
      }
      return { idx, norm };
    }

    function parseVedlagtFileNameFromLine(line){
      let t = String(line || '').trim();
      t = t.replace(/^Vedlagt\s*:\s*/i, '');
      t = t.replace(/^[-•]\s+/, '');
      // If caption is appended using an em dash or dash, only keep the filename.
      t = t.split(/\s+—\s+|\s+-\s+/)[0];
      return String(t || '').trim();
    }

    function fileToDataUrlLocal(file){
      return new Promise((resolve, reject) => {
        try {
          const r = new FileReader();
          r.onload = () => resolve(String(r.result || ''));
          r.onerror = reject;
          r.readAsDataURL(file);
        } catch (e) { reject(e); }
      });
    }

    async function ensureHtml2PdfLoaded(){
      if (window.html2pdf) return window.html2pdf;
      const existing = document.querySelector('script[data-html2pdf="true"]');
      if (!existing) {
        await new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.dataset.html2pdf = 'true';
          s.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js';
          s.onload = resolve;
          s.onerror = reject;
          document.head.appendChild(s);
        });
      } else {
        await new Promise((resolve, reject) => {
          if (window.html2pdf) return resolve();
          existing.addEventListener('load', resolve, { once: true });
          existing.addEventListener('error', reject, { once: true });
        });
      }
      if (!window.html2pdf) throw new Error('Kunne ikke indlæse PDF biblioteket');
      return window.html2pdf;
    }

    async function ensureJsPdfLoaded(){
      // Prefer an existing jsPDF (may be present via html2pdf bundle), otherwise load it on-demand.
      if (window.jspdf && window.jspdf.jsPDF) return window.jspdf;
      const existing = document.querySelector('script[data-jspdf="true"]');
      if (!existing) {
        await new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.dataset.jspdf = 'true';
          s.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
          s.onload = resolve;
          s.onerror = reject;
          document.head.appendChild(s);
        });
      } else {
        await new Promise((resolve, reject) => {
          if (window.jspdf && window.jspdf.jsPDF) return resolve();
          existing.addEventListener('load', resolve, { once: true });
          existing.addEventListener('error', reject, { once: true });
        });
      }
      if (!window.jspdf || !window.jspdf.jsPDF) throw new Error('Kunne ikke indlæse jsPDF');
      return window.jspdf;
    }

    function getDocOverlayDraftTextForExport(projectInfo){
      const liveEl = document.getElementById('doc-live-text');
      const overlayEl = document.getElementById('doc-generator-overlay');
      const state = overlayEl && overlayEl.__docPlaceholderState ? overlayEl.__docPlaceholderState : null;

      let text = (liveEl && String(liveEl.value || '').trim()) ? String(liveEl.value || '') : '';
      if (!text && state && String(state.baseDraft || '').trim()) text = String(state.baseDraft || '');

      const placeholders = Array.isArray(state?.placeholders) ? state.placeholders : [];
      const attachments = state?.attachments || {};

      // If placeholders were replaced with a friendly "Vedlagt: ..." text in the live draft,
      // restore the original [VEDLÆG: ...] token so exporters can insert images inline.
      if (text && placeholders.length && !/\[(?:VEDLÆG|VEDLAEG)\s*:/i.test(text)) {
        for (const p of placeholders) {
          if (p?.type !== 'VEDLÆG') continue;
          const entry = attachments?.[p.key];
          const files = Array.isArray(entry?.files) ? entry.files : [];
          if (!files.length) continue;

          let repl = '';
          if (typeof formatVedlaegReplacementText === 'function') {
            repl = String(formatVedlaegReplacementText(p, files) || '').trim();
          } else {
            const name = files?.[0]?.file?.name || files?.[0]?.name || '';
            repl = name ? ('Vedlagt: ' + name) : '';
          }

          if (!repl) continue;
          text = text.split(repl).join(String(p.token || ''));
        }
      }

      if (projectInfo && typeof updateDocHeaderLines === 'function') {
        text = updateDocHeaderLines(text, projectInfo);
      }
      if (typeof normalizeGeneratedDocumentText === 'function') {
        text = normalizeGeneratedDocumentText(text);
      }
      return text;
    }

    async function exportDocOverlayAsPdf(){
      const btn = document.getElementById('doc-gen-export-pdf');
      const prevLabel = btn ? String(btn.textContent || '') : '';
      try {
        if (btn) {
          btn.disabled = true;
          btn.textContent = '⏳ Genererer PDF…';
        }

        const today = new Date().toLocaleDateString('da-DK');
        const projectInfo = getDocOverlayProjectInfoLenient();

        const draftText = String(getDocOverlayDraftTextForExport(projectInfo) || '').trim()
          ? String(getDocOverlayDraftTextForExport(projectInfo) || '')
          : (() => {
              try {
                const bk1Sections = collectBk1SectionsAcrossBuildings();
                const explanations = (bk1Sections || []).map(() => null);
                return buildDocumentTextWithProjectInfo(bk1Sections, explanations, projectInfo);
              } catch(_) {
                return '';
              }
            })();

        const step3 = collectAllStep3DocsWithFiles();
        const vedlaeg = collectOverlayVedlaegWithFiles();
        const step3ImageItems = step3.filter(x => x?.file && String(x.file.type || '').startsWith('image/'));
        const vedlaegImageItems = vedlaeg.filter(x => x?.file && String(x.file.type || '').startsWith('image/'));

        const { itemsWithLetter: step3ItemsWithLetter, letterByDocId: step3LetterById } = buildStep3BilagLetterIndex(step3ImageItems);
        const step3ComplianceGroups = buildStep3ComplianceSummaryGroups(step3LetterById);
        const step3ComplianceLines = buildStep3ComplianceSummaryLines(step3ComplianceGroups);

        // Build PDF directly with jsPDF (more reliable than html2canvas capture)
        const jspdfLib = await ensureJsPdfLoaded();
        const { jsPDF } = jspdfLib;
        const doc = new jsPDF({ unit: 'mm', format: 'a4', orientation: 'portrait' });

        const pageW = doc.internal.pageSize.getWidth();
        const pageH = doc.internal.pageSize.getHeight();
        const margin = 14;
        const contentW = pageW - margin * 2;
        let y = margin;

        const ensureSpace = (needMm) => {
          if (y + needMm <= pageH - margin) return;
          doc.addPage();
          y = margin;
        };

        // Header
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(16);
        doc.text('BK1 Dokumentation', margin, y);
        y += 8;
        doc.setFont('helvetica', 'normal');
        doc.setFontSize(10);
        doc.setTextColor(71, 85, 105);
        doc.text('Eksporteret: ' + String(today), margin, y);
        doc.setTextColor(15, 23, 42);
        y += 8;

        const sanitizePdfText = (s) => {
          // jsPDF default fonts don't support box drawing; replace with simple ASCII.
          return String(s || '')
            .replace(/[\u00A0\u202F\u2007]/g, ' ')
            .replace(/[\u200B\u200C\u200D\uFEFF]/g, '')
            .replace(/\u00AD/g, '')
            .replace(/[═━]+/g, '------------------------------------------------------------')
            .replace(/[║│]/g, '|')
            .replace(/[╔╗╚╝╠╣╦╩╬]/g, '+')
            .replace(/[□■]/g, '-')
            .replace(/[–—]/g, '-')
            .replace(/[“”]/g, '"')
            .replace(/[’]/g, "'")
            .replace(/[≤]/g, '<=')
            .replace(/[≥]/g, '>=')
            .replace(/[×]/g, 'x')
            .replace(/[²]/g, '2')
            .replace(/[³]/g, '3');
        };

        const normalizeWeirdListLine = (s) => {
          let t = String(s || '');

          // Convert old pseudo-bullets like "%i" to a simple dash bullet.
          t = t.replace(/^\s*%\s*[a-z]\s*/i, '- ');

          // If the line is letter-spaced ("S i t u a t i o n s p l a n"), de-space it.
          // Heuristic: lots of single-letter tokens.
          const trimmed = t.trim();
          const tokens = trimmed.split(/\s+/g);
          const singleCharTokens = tokens.filter(x => x.length === 1).length;
          if (tokens.length >= 10 && singleCharTokens / tokens.length > 0.7) {
            t = trimmed
              .replace(/\s*\(\s*/g, '(')
              .replace(/\s*\)\s*/g, ')')
              .replace(/\s*:\s*/g, ': ')
              .replace(/\s+/g, ' ')
              .replace(/([A-Za-zÆØÅæøå0-9])\s(?=[A-Za-zÆØÅæøå0-9])/g, '$1');
          }

          // Normalize excessive spacing (but keep indentation after bullets).
          t = t.replace(/^(\s*[-*•]\s+)\s+/g, '$1');
          t = t.replace(/\t/g, '  ');
          return t;
        };

        const normalizeKey = (s) => String(s || '')
          .toLowerCase()
          .trim()
          .replace(/\s+/g, '')
          .replace(/[^a-z0-9æøå]/g, '');

        const extractVedlaegKeyFromLine = (line) => {
          const t = String(line || '').trim();
          // Support both bracketed placeholders: "[VEDLÆG: X]" and raw remnants: "VEDLÆG: X" / "VEDLÆG:X".
          const m = t.match(/^(?:\[\s*)?(?:VEDLÆG|VEDLAEG)\s*:\s*([^\]]+?)(?:\s*\])?\s*$/i);
          return m ? String(m[1] || '').trim() : '';
        };

        const vedlaegByKey = buildOverlayVedlaegIndex(vedlaegImageItems);
        const { idx: vedlaegByFileName, norm: normFileName } = buildVedlaegByFileName(vedlaegImageItems);

        const step3BlocksByCategory = (() => {
          const groups = {};
          for (const it of step3ImageItems) {
            const cat = String(it.category || 'Kravgruppe').trim() || 'Kravgruppe';
            (groups[cat] ||= []).push(it);
          }
          // Keep insertion order from collectAllStep3DocsWithFiles() (already ordered by kravCategoryOrder)
          return groups;
        })();

        const isSeparatorLine = (s) => {
          const t = String(s || '').trim();
          if (!t) return false;
          if (/^[-]{10,}$/.test(t)) return true;
          if (/^[=]{10,}$/.test(t)) return true;
          if (/^[_]{10,}$/.test(t)) return true;
          // Convert common remnants from sanitized box drawing
          if (/^[+|\-=_ ]{10,}$/.test(t)) return true;
          return false;
        };

        const isHeadingLine = (s) => {
          const t = String(s || '').trim();
          if (!t) return false;
          // Numbered headings like "4.1 DOKUMENTATION ..." or "6. NOTAT ..."
          if (/^\d+(?:\.\d+)*\.\s+/.test(t)) return true;
          // Common top-level headings in the draft
          if (/^(PROJEKTINFORMATION|INDHOLDSFORTEGNELSE|TEKNISK INFORMATION)\b/i.test(t)) return true;
          // Uppercase heading lines (avoid short words)
          if (t.length >= 12 && t === t.toUpperCase() && /[A-ZÆØÅ]/.test(t)) return true;
          // Section labels
          if (/^Bygningsafsnit\s+\d+\s*:/i.test(t)) return true;
          return false;
        };

        const drawHr = () => {
          ensureSpace(6);
          doc.setDrawColor(226, 232, 240);
          doc.setLineWidth(0.4);
          doc.line(margin, y, pageW - margin, y);
          y += 6;
        };

        const setBodyTextStyle = (kind) => {
          if (kind === 'heading') {
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(11.5);
            doc.setTextColor(15, 23, 42);
            return 5.2;
          }
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(10.2);
          doc.setTextColor(15, 23, 42);
          return 4.6;
        };

        const lines = String(draftText || '').split(/\r?\n/);

        const addWrappedText = (text, fontSize, color) => {
          if (text === null || text === undefined) return;
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(fontSize);
          if (color) doc.setTextColor(color[0], color[1], color[2]);
          const parts = String(text).split(/\r?\n/);
          for (const p of parts) {
            const w = doc.splitTextToSize(String(p), contentW);
            for (const ln of w) {
              ensureSpace(4.4);
              doc.text(String(ln), margin, y);
              y += 4.4;
            }
          }
          if (color) doc.setTextColor(15, 23, 42);
        };

        const loadImageSizeFromDataUrl = async (dataUrl) => {
          return await new Promise((resolve, reject) => {
            try {
              const img = new Image();
              img.onload = () => resolve({ width: img.naturalWidth, height: img.naturalHeight });
              img.onerror = () => reject(new Error('Billede kunne ikke indlæses'));
              img.src = dataUrl;
            } catch (e) {
              reject(e);
            }
          });
        };

        // Lock uploaded bilag size for a more consistent report layout.
        // 0.9 means "90% of the large/full width".
        const PDF_BILAG_WIDTH_FRAC = 0.9;

        const addImageBlock = async ({ title, subtitle, caption, file }) => {
          const dataUrl = await fileToDataUrlLocal(file);
          const isPng = /^data:image\/png/i.test(dataUrl);
          const fmt = isPng ? 'PNG' : 'JPEG';
          const dims = await loadImageSizeFromDataUrl(dataUrl);
          const iw = Number(dims?.width) || 1;
          const ih = Number(dims?.height) || 1;
          const ratio = iw / ih;

          // Title
          if (title) {
            ensureSpace(10);
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(12);
            doc.text(String(title), margin, y);
            y += 6;
          }

          // Subtitle
          if (subtitle) {
            addWrappedText(String(subtitle), 9.5, [71, 85, 105]);
            y += 1;
          }

          const maxW = Math.max(10, contentW * PDF_BILAG_WIDTH_FRAC);
          const minBottom = 10;
          const computeAvailH = () => (pageH - margin) - y - minBottom;

          let w = maxW;
          let h = w / ratio;

          // If the image would have to shrink because we're near the bottom of the page,
          // start it on a new page instead. This keeps bilag a consistent size.
          let availH = computeAvailH();
          if (availH < 40 || h > availH) {
            doc.addPage();
            y = margin;
            w = maxW;
            h = w / ratio;
            availH = computeAvailH();
          }

          // If the image is still too tall even on a fresh page, shrink to fit.
          if (h > availH) {
            h = availH;
            w = h * ratio;
          }

          w = Math.max(10, w);
          h = Math.max(10, h);

          ensureSpace(h + 8);
          const x = margin + Math.max(0, (contentW - w) / 2);
          doc.addImage(dataUrl, fmt, x, y, w, h);
          y += h + 4;

          if (caption) {
            addWrappedText(String(caption), 10, null);
          }
          y += 6;
        };

        let insertedComplianceSummary = false;
        const insertComplianceSummaryInline = () => {
          if (insertedComplianceSummary) return;
          insertedComplianceSummary = true;
          if (!step3ComplianceLines.length) return;

          ensureSpace(8);
          y += 2;

          for (const lnRaw of step3ComplianceLines) {
            // Sanitize and normalize the compliance lines too, because krav-text can contain
            // NBSP/soft-hyphen/zero-width chars and (in some sources) letter-spaced words.
            const ln = normalizeWeirdListLine(sanitizePdfText(String(lnRaw ?? '')));
            const trimmed = String(ln || '').trimEnd();
            if (!trimmed.trim()) {
              ensureSpace(3.8);
              y += 3.8;
              continue;
            }

            const isMainTitleLine = /^Kravliste\b/i.test(trimmed);
            const isSectionLine = /^Bygning\s+\d+\s*\/\s*Bygningsafsnit\s+\d+/i.test(trimmed);
            const isGroupLine = /^Kravgruppe\s*:/i.test(trimmed);
            const isBulletLine = /^•\s+/.test(trimmed);
            const isBilagLine = /^\s*(?:Dokumentation\s*:|Dokumentation\s+kan\s+ses\s+i\s+bilag\b|-\s*Der\s+er\s+ikke\s+knyttet\s+dokumentation\b)/i.test(trimmed.trim());

            if (isMainTitleLine) {
              doc.setFont('helvetica', 'bold');
              doc.setFontSize(12.2);
              const wrapped = doc.splitTextToSize(trimmed, contentW);
              for (const wline of wrapped) {
                ensureSpace(5.4);
                doc.text(String(wline), margin, y);
                y += 5.4;
              }
              y += 1.5;
              continue;
            }

            if (isSectionLine) {
              ensureSpace(6.4);
              y += 1.2;
              doc.setFont('helvetica', 'bold');
              doc.setFontSize(11.2);
              const wrapped = doc.splitTextToSize(trimmed, contentW);
              for (const wline of wrapped) {
                ensureSpace(5.1);
                doc.text(String(wline), margin, y);
                y += 5.1;
              }
              y += 0.8;
              continue;
            }

            if (isGroupLine) {
              ensureSpace(6.0);
              y += 0.6;
              doc.setFont('helvetica', 'bold');
              doc.setFontSize(10.8);
              const wrapped = doc.splitTextToSize(trimmed, contentW);
              for (const wline of wrapped) {
                ensureSpace(5.0);
                doc.text(String(wline), margin, y);
                y += 5.0;
              }
              y += 0.8;
              continue;
            }

            if (isBulletLine) {
              doc.setFont('helvetica', 'normal');
              doc.setFontSize(10.2);
              const text = trimmed.replace(/^•\s+/, '');
              const x = margin + 4;
              const w = contentW - 4;
              // Use plain bullet rendering but ensure the text can wrap reliably.
              const wrapped = doc.splitTextToSize('• ' + String(text || ''), w);
              for (const wline of wrapped) {
                ensureSpace(4.9);
                doc.text(String(wline), x, y);
                y += 4.9;
              }
              continue;
            }

            if (isBilagLine) {
              doc.setFont('helvetica', 'normal');
              doc.setFontSize(9.6);
              doc.setTextColor(71, 85, 105);
              const x = margin + 10;
              const w = contentW - 10;
              const wrapped = doc.splitTextToSize(trimmed.trim(), w);
              for (const wline of wrapped) {
                ensureSpace(4.4);
                doc.text(String(wline), x, y);
                y += 4.4;
              }
              doc.setTextColor(15, 23, 42);
              continue;
            }

            // Fallback
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(10.2);
            const wrapped = doc.splitTextToSize(trimmed, contentW);
            for (const wline of wrapped) {
              ensureSpace(4.6);
              doc.text(String(wline), margin, y);
              y += 4.6;
            }
          }

          y += 4;
          doc.setFont('helvetica', 'normal');
          doc.setFontSize(10.2);
          doc.setTextColor(15, 23, 42);
        };

        const appendStep3BilagAtEnd = async () => {
          if (!step3ItemsWithLetter.length) return;
          doc.addPage();
          y = margin;
          doc.setFont('helvetica', 'bold');
          doc.setFontSize(14);
          doc.setTextColor(15, 23, 42);
          doc.text('Bilag (trin 3)', margin, y);
          y += 10;

          doc.setFont('helvetica', 'normal');
          doc.setFontSize(10);
          doc.setTextColor(71, 85, 105);
          doc.text('Bilagene er samlet nederst og refereres i afsnit 5 som A, B, C, ...', margin, y);
          doc.setTextColor(15, 23, 42);
          y += 8;

          for (const it of step3ItemsWithLetter) {
            const letter = String(it.__bilagLetter || '').trim();
            const cat = String(it.category || 'Kravgruppe').trim() || 'Kravgruppe';
            const name = String(it.meta?.name || it.file?.name || 'bilag');
            const cap = String(it.meta?.caption || '').trim();
            const desc = String(it.meta?.description || '').trim();
            const label = `Kravgruppe: ${cat} — Bygning ${it.buildingIndex + 1} / Bygningsafsnit ${it.sectionIndex + 1}: ${it.sectionTitle}`;
            const subtitle = desc ? (label + '\n' + desc) : label;
            const titleText = (cap || name).trim();
            await addImageBlock({
              title: (letter ? `Bilag ${letter}` : 'Bilag') + (titleText ? `: ${titleText}` : ''),
              subtitle,
              caption: '',
              file: it.file
            });
          }
        };

        let inVedlagteFiler = false;
        for (const rawLine of lines) {
          const line = String(rawLine ?? '');

          // Insert compliance summary inside section 5 (right after the heading line).
          // Avoid inserting inside the TOC by requiring the anchor line to be ALL-CAPS.
          const insertComplianceAfterLine = (!insertedComplianceSummary && (() => {
            const t = String(line || '').trim();
            if (!t) return false;
            if (t !== t.toUpperCase()) return false;
            return /NOTAT\s+OM\s+(?:DEN\s+)?BRANDTEKNISK/i.test(t);
          })());

          // Inline Step-4 attachments where placeholders appear
          const vedKey = extractVedlaegKeyFromLine(line);
          if (vedKey) {
            const nk = normalizeKey(vedKey);
            const matches = Array.isArray(vedlaegByKey[nk]) ? vedlaegByKey[nk] : [];
            if (matches.length) {
              for (const it of matches) {
                const cap = String(it.caption || '').trim();
                const caption = cap || '';
                await addImageBlock({
                  title: '',
                  subtitle: '',
                  caption,
                  file: it.file
                });
              }
              continue; // don't print the placeholder line
            }

            // Always suppress placeholder lines in the exported report.
            continue;
          }

          // Fallback: if the draft has replaced the placeholder with "Vedlagt: <filnavn>",
          // insert images based on filename (same robustness as step-3 bilag handling).
          let postLineVedlaegMatches = [];
          const trimmed = String(line || '').trim();
          if (/^Vedlagte\s+filer\s*:/i.test(trimmed)) {
            inVedlagteFiler = true;
          } else if (inVedlagteFiler) {
            if (!trimmed) {
              inVedlagteFiler = false;
            } else if (!/^[-•]\s+/.test(trimmed)) {
              inVedlagteFiler = false;
            }
          }

          if (/^Vedlagt\s*:/i.test(trimmed)) {
            const fname = parseVedlagtFileNameFromLine(trimmed);
            const hits = Array.isArray(vedlaegByFileName[normFileName(fname)]) ? vedlaegByFileName[normFileName(fname)] : [];
            if (hits.length) postLineVedlaegMatches = hits;
            // Never render "Vedlagt:" lines in PDF output (not pretty); show the image(s) only.
            if (postLineVedlaegMatches.length) {
              for (const it of postLineVedlaegMatches) {
                const cap = String(it.caption || '').trim();
                const caption = cap || '';
                await addImageBlock({ title: '', subtitle: '', caption, file: it.file });
              }
            }
            continue;
          } else if (inVedlagteFiler && /^[-•]\s+/.test(trimmed)) {
            const fname = parseVedlagtFileNameFromLine(trimmed.replace(/^[-•]\s+/, ''));
            const hits = Array.isArray(vedlaegByFileName[normFileName(fname)]) ? vedlaegByFileName[normFileName(fname)] : [];
            if (hits.length) postLineVedlaegMatches = hits;
            // Suppress the list line; render image(s) only.
            if (postLineVedlaegMatches.length) {
              for (const it of postLineVedlaegMatches) {
                const cap = String(it.caption || '').trim();
                const caption = cap || '';
                await addImageBlock({ title: '', subtitle: '', caption, file: it.file });
              }
            }
            continue;
          }

          if (!line.trim()) {
            ensureSpace(4.6);
            y += 4.6;
            continue;
          }

          let sanitized = sanitizePdfText(line);
          sanitized = normalizeWeirdListLine(sanitized);
          if (isSeparatorLine(sanitized)) {
            drawHr();
            continue;
          }

          const kind = isHeadingLine(sanitized) ? 'heading' : 'body';
          const lh = setBodyTextStyle(kind);
          const wrapped = doc.splitTextToSize(sanitized, contentW);
          for (const wline of wrapped) {
            ensureSpace(lh);
            doc.text(String(wline), margin, y);
            y += lh;
          }

          if (insertComplianceAfterLine) {
            insertComplianceSummaryInline();
          }

          if (postLineVedlaegMatches.length) {
            for (const it of postLineVedlaegMatches) {
              const cap = String(it.caption || '').trim();
              const caption = cap || '';
              await addImageBlock({ title: '', subtitle: '', caption, file: it.file });
            }
          }
        }

        // Any Step-4 attachments not referenced by a placeholder are added at the end.
        const usedVed = new Set();
        // We consider "used" any placeholder that matched; track it via vedlaegByKey being consumed is complex,
        // so just append all remaining if there was no placeholder at all.
        const anyVedPlaceholderInText = /\[(?:VEDLÆG|VEDLAEG)\s*:/i.test(String(draftText || ''));
        if (!anyVedPlaceholderInText && vedlaegImageItems.length) {
          doc.addPage();
          y = margin;
          doc.setFont('helvetica', 'bold');
          doc.setFontSize(14);
          doc.text('Bilag (trin 4) – ikke placeret i tekst', margin, y);
          y += 10;
          for (const it of vedlaegImageItems) {
            const cap = String(it.caption || '').trim();
            const caption = cap || '';
            await addImageBlock({ title: '', subtitle: '', caption, file: it.file });
          }
        }

        // Always place Step-3 bilag at the very bottom.
        await appendStep3BilagAtEnd();

        const fileName = `BK1_Dokumentation_${projectInfo.__safeName}_${today.replace(/\./g, '-')}.pdf`;
        doc.save(fileName);

      } finally {
        if (btn) {
          btn.disabled = false;
          btn.textContent = prevLabel || '📄 PDF';
        }
      }
    }

    async function exportDocOverlayAsHtml(){
      // Open immediately to avoid browser blocking
      const win = window.open('', '_blank');
      if (!win) {
        alert('Popup blev blokeret. Tillad popups for at kunne lave Print/PDF.');
        return;
      }

      const today = new Date().toLocaleDateString('da-DK');
      const projectInfo = getDocOverlayProjectInfoLenient();
      win.document.open();
      // Keep this HTML as a single plain string: avoids backticks/template literals and multiline concatenation pitfalls.
      const baseHtml = '<!doctype html><html lang="da"><head><meta charset="utf-8"/>' +
        '<meta name="viewport" content="width=device-width, initial-scale=1"/>' +
        '<title>BK1 Dokumentation</title>' +
        '<style>' +
          'body{ font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 24px; color:#0f172a; }' +
          'pre{ white-space: pre-wrap; word-wrap: break-word; background:#fff; border:1px solid #e2e8f0; border-radius:12px; padding:16px; }' +
          'h1,h2,h3{ margin: 0 0 12px; }' +
          '.muted{ color:#475569; }' +
          '@media print { body{ margin: 12mm; } pre{ border:none; padding:0; } figure{ break-inside: avoid; } }' +
        '</style></head><body>' +
        '<h1>BK1 Dokumentation</h1>' +
        '<div class="muted" style="margin-bottom: 14px;">Eksporteret: ' + escapeHtml(today) + '</div>' +
        '<div id="content"><div class="muted">Genererer... (vent et oejeblik og brug derefter Ctrl+P -> Gem som PDF)</div></div>';
      win.document.write(baseHtml);
      win.document.close();

      const draftText = String(getDocOverlayDraftTextForExport(projectInfo) || '').trim()
        ? String(getDocOverlayDraftTextForExport(projectInfo) || '')
        : (() => {
            try {
              const bk1Sections = collectBk1SectionsAcrossBuildings();
              const explanations = (bk1Sections || []).map(() => null);
              return buildDocumentTextWithProjectInfo(bk1Sections, explanations, projectInfo);
            } catch(_) {
              return '';
            }
          })();

      const step3 = collectAllStep3DocsWithFiles();
      const vedlaeg = collectOverlayVedlaegWithFiles();
      const step3ImageItems = step3.filter(x => x?.file && String(x.file.type || '').startsWith('image/'));
      const vedlaegImageItems = vedlaeg.filter(x => x?.file && String(x.file.type || '').startsWith('image/'));

      const { itemsWithLetter: step3ItemsWithLetter, letterByDocId: step3LetterById } = buildStep3BilagLetterIndex(step3ImageItems);
      const step3ComplianceGroups = buildStep3ComplianceSummaryGroups(step3LetterById);
      const step3ComplianceLines = buildStep3ComplianceSummaryLines(step3ComplianceGroups);

      const complianceHtmlFromLines = (linesArr) => {
        const lines = Array.isArray(linesArr) ? linesArr : [];
        if (!lines.length) return '';

        const isBulletLine = (t) => /^•\s+/.test(t);
        const isDocLine = (t) => /^\s*(?:Dokumentation\s*:|Dokumentation\s+kan\s+ses\s+i\s+bilag\b|-\s*Der\s+er\s+ikke\s+knyttet\s+dokumentation\b)/i.test(String(t || '').trim());

        let html = '<div style="margin: 12px 0 6px;">';
        for (const lnRaw of lines) {
          const ln = String(lnRaw ?? '');
          const trimmed = ln.trimEnd();
          const t = trimmed.trim();
          if (!t) {
            html += '<div style="height: 8px;"></div>';
            continue;
          }

          if (/^Kravliste\b/i.test(t)) {
            html += '<h2 style="margin: 18px 0 10px;">' + escapeHtml(t) + '</h2>';
            continue;
          }

          if (/^Bygning\s+\d+\s*\/\s*Bygningsafsnit\s+\d+/i.test(t)) {
            html += '<h3 style="margin: 14px 0 8px;">' + escapeHtml(t) + '</h3>';
            continue;
          }

          if (/^Kravgruppe\s*:/i.test(t)) {
            html += '<div style="font-weight:700; margin: 10px 0 6px;">' + escapeHtml(t) + '</div>';
            continue;
          }

          if (isBulletLine(t)) {
            const clean = String(t || '').replace(/^•\s+/, '');
            html += '<div style="margin: 6px 0 2px;">• ' + escapeHtml(clean) + '</div>';
            continue;
          }

          if (isDocLine(t)) {
            html += '<div class="muted" style="margin-left: 18px; font-size: 12px;">' + escapeHtml(t) + '</div>';
            continue;
          }

          html += '<div>' + escapeHtml(t) + '</div>';
        }
        html += '</div>';
        return html;
      };

      const contentEl = win.document.getElementById('content');
      if (contentEl) {
        const normalizeKey = (s) => String(s || '').toLowerCase().trim().replace(/\s+/g, '').replace(/[^a-z0-9æøå]/g, '');
        const extractVedKey = (line) => {
          const m = String(line || '').match(/\[(?:VEDLÆG|VEDLAEG)\s*:\s*([^\]]+)\]/i);
          return m ? String(m[1] || '').trim() : '';
        };
        const vedByKey = buildOverlayVedlaegIndex(vedlaegImageItems);
        const { idx: vedByFileName, norm: normFileName } = buildVedlaegByFileName(vedlaegImageItems);

        const addFigureHtml = async (title, file, caption, subcaption) => {
          const dataUrl = await fileToDataUrlLocal(file);
          return (
            '<figure style="margin: 16px 0; padding: 12px; border: 1px solid #e2e8f0; border-radius: 10px; background: #fff;">' +
            (title ? '<div style="font-weight:700; color:#0f172a; margin-bottom:6px;">' + escapeHtml(title) + '</div>' : '') +
            (subcaption ? '<div class="muted" style="font-size: 12px; margin-bottom:10px; white-space: pre-wrap;">' + escapeHtml(subcaption) + '</div>' : '') +
            '<img src="' + String(dataUrl || '') + '" alt="' + escapeHtml(caption || title) + '" style="width: 90%; max-width: 90%; height: auto; border-radius: 6px; display:block; margin: 0 auto;"/>' +
            (caption ? '<figcaption style="margin-top:8px; color:#0f172a; font-size: 13px;">' + escapeHtml(caption) + '</figcaption>' : '') +
            '</figure>'
          );
        };

        const parts = [];
        const lines = String(draftText || '').split(/\r?\n/);
        let insertedComplianceSummary = false;
        let inVedlagteFiler = false;
        for (const line of lines) {
          const insertComplianceAfterLine = (!insertedComplianceSummary && (() => {
            const t = String(line || '').trim();
            if (!t) return false;
            if (t !== t.toUpperCase()) return false;
            return /NOTAT\s+OM\s+(?:DEN\s+)?BRANDTEKNISK/i.test(t);
          })());

          const vedKey = extractVedKey(line);
          if (vedKey) {
            const nk = normalizeKey(vedKey);
            const matches = Array.isArray(vedByKey[nk]) ? vedByKey[nk] : [];
            if (matches.length) {
              for (const it of matches) {
                const cap = String(it.caption || '').trim();
                const title = '';
                const caption = cap || '';
                parts.push(await addFigureHtml(title, it.file, caption, ''));
              }
              continue;
            }
          }

          const trimmed = String(line || '').trim();
          if (/^Vedlagte\s+filer\s*:/i.test(trimmed)) {
            inVedlagteFiler = true;
          } else if (inVedlagteFiler) {
            if (!trimmed) {
              inVedlagteFiler = false;
            } else if (!/^[-•]\s+/.test(trimmed)) {
              inVedlagteFiler = false;
            }
          }

          parts.push(escapeHtml(line));

          if (insertComplianceAfterLine) {
            insertedComplianceSummary = true;
            if (step3ComplianceLines.length) {
              parts.push('');
              parts.push(complianceHtmlFromLines(step3ComplianceLines));
              parts.push('');
            }
          }

          let postMatches = [];
          if (/^Vedlagt\s*:/i.test(trimmed)) {
            const fname = parseVedlagtFileNameFromLine(trimmed);
            const hits = Array.isArray(vedByFileName[normFileName(fname)]) ? vedByFileName[normFileName(fname)] : [];
            if (hits.length) postMatches = hits;
          } else if (inVedlagteFiler && /^[-•]\s+/.test(trimmed)) {
            const fname = parseVedlagtFileNameFromLine(trimmed.replace(/^[-•]\s+/, ''));
            const hits = Array.isArray(vedByFileName[normFileName(fname)]) ? vedByFileName[normFileName(fname)] : [];
            if (hits.length) postMatches = hits;
          }

          if (postMatches.length) {
            for (const it of postMatches) {
              const cap = String(it.caption || '').trim();
              const caption = cap || '';
              parts.push(await addFigureHtml('', it.file, caption, ''));
            }
          }
        }

        // If anchor missing (user edited), still include the compliance summary at the end.
        if (!insertedComplianceSummary && step3ComplianceLines.length) {
          parts.push('');
          parts.push(complianceHtmlFromLines(step3ComplianceLines));
          parts.push('');
        }

        // Always place Step-3 bilag at the very bottom.
        if (step3ItemsWithLetter.length) {
          parts.push('');
          parts.push('<h2 style="margin-top: 26px;">Bilag (trin 3)</h2>');
          parts.push('<div class="muted" style="margin-bottom: 10px;">Bilagene er samlet nederst og refereres i afsnit 5 som A, B, C, ...</div>');
          for (const item of step3ItemsWithLetter) {
            const letter = String(item.__bilagLetter || '').trim();
            const cat = String(item.category || 'Kravgruppe').trim() || 'Kravgruppe';
            const name = String(item.meta?.name || item.file?.name || 'bilag');
            const cap = String(item.meta?.caption || '').trim();
            const desc = String(item.meta?.description || '').trim();
            const label = `${cat} — Bygning ${item.buildingIndex + 1} / Bygningsafsnit ${item.sectionIndex + 1}: ${item.sectionTitle}`;
            const titleText = String((cap || name) || '').trim();
            const title = (letter ? (`Bilag ${letter}`) : 'Bilag') + (titleText ? `: ${titleText}` : '');
            parts.push(await addFigureHtml(title, item.file, '', desc ? `${label}\n${desc}` : label));
          }
        }

        contentEl.innerHTML = '<pre>' + parts.join('\n') + '</pre>';
      }
    }

    async function ensureDocxLoaded(){
      if (window.docx) return window.docx;
      const existing = document.querySelector('script[data-docx="true"]');
      if (!existing) {
        await new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.dataset.docx = 'true';
          s.src = 'https://cdn.jsdelivr.net/npm/docx@8.5.0/build/index.umd.js';
          s.onload = resolve;
          s.onerror = reject;
          document.head.appendChild(s);
        });
      } else {
        await new Promise((resolve, reject) => {
          if (window.docx) return resolve();
          existing.addEventListener('load', resolve, { once: true });
          existing.addEventListener('error', reject, { once: true });
        });
      }
      if (!window.docx) throw new Error('Kunne ikke indlæse DOCX biblioteket');
      return window.docx;
    }

    async function exportDocOverlayAsDocx(){
      const today = new Date().toLocaleDateString('da-DK');
      const projectInfo = getDocOverlayProjectInfoLenient();

      const draftText = String(getDocOverlayDraftTextForExport(projectInfo) || '').trim()
        ? String(getDocOverlayDraftTextForExport(projectInfo) || '')
        : (() => {
            try {
              const bk1Sections = collectBk1SectionsAcrossBuildings();
              const explanations = (bk1Sections || []).map(() => null);
              return buildDocumentTextWithProjectInfo(bk1Sections, explanations, projectInfo);
            } catch(_) {
              return '';
            }
          })();

      const lib = await ensureDocxLoaded();
      const { Document, Packer, Paragraph, TextRun, HeadingLevel, ImageRun } = lib;

      const DOC_FONT = 'Arial';
      const DOC_SIZE = 24; // 12pt (docx uses half-points)

      const isSeparatorLine = (s) => {
        const t = String(s || '').trim();
        if (!t) return false;
        // Lines consisting primarily of repeated separator characters
        if (/^[-]{10,}$/.test(t)) return true;
        if (/^[=]{10,}$/.test(t)) return true;
        if (/^[_]{10,}$/.test(t)) return true;
        if (/^[═━─]{10,}$/.test(t)) return true;
        if (/^[+|\-=_ ═━─]{10,}$/.test(t)) return true;
        return false;
      };

      const isHeadingLine = (s) => {
        const t = String(s || '').trim();
        if (!t) return false;
        if (/^\d+(?:\.\d+)*\.\s+/.test(t)) return true;
        if (/^(PROJEKTINFORMATION|INDHOLDSFORTEGNELSE|TEKNISK INFORMATION)\b/i.test(t)) return true;
        if (t.length >= 12 && t === t.toUpperCase() && /[A-ZÆØÅ]/.test(t)) return true;
        if (/^Bygningsafsnit\s+\d+\s*:/i.test(t)) return true;
        return false;
      };

      const headingLevelFor = (s) => {
        const t = String(s || '').trim();
        const m = t.match(/^(\d+)(?:\.(\d+))?(?:\.(\d+))?\./);
        if (m) {
          const depth = m[3] ? 3 : (m[2] ? 2 : 1);
          if (depth === 1) return HeadingLevel.HEADING_1;
          if (depth === 2) return HeadingLevel.HEADING_2;
          return HeadingLevel.HEADING_3;
        }
        if (/^Bygningsafsnit\s+\d+\s*:/i.test(t)) return HeadingLevel.HEADING_2;
        return HeadingLevel.HEADING_1;
      };

      const normalizeWeirdListLine = (s) => {
        let t = String(s || '');
        t = t.replace(/^\s*%\s*[a-z]\s*/i, '• ');
        const trimmed = t.trim();
        const tokens = trimmed.split(/\s+/g);
        const singleCharTokens = tokens.filter(x => x.length === 1).length;
        if (tokens.length >= 10 && singleCharTokens / tokens.length > 0.7) {
          t = trimmed
            .replace(/\s*\(\s*/g, '(')
            .replace(/\s*\)\s*/g, ')')
            .replace(/\s*:\s*/g, ': ')
            .replace(/\s+/g, ' ')
            .replace(/([A-Za-zÆØÅæøå0-9])\s(?=[A-Za-zÆØÅæøå0-9])/g, '$1');
        }
        t = t.replace(/\t/g, '  ');
        return t;
      };

      const normalizeKey = (s) => String(s || '').toLowerCase().trim().replace(/\s+/g, '').replace(/[^a-z0-9æøå]/g, '');
      const extractVedlaegKeyFromLine = (line) => {
        const m = String(line || '').match(/\[(?:VEDLÆG|VEDLAEG)\s*:\s*([^\]]+)\]/i);
        return m ? String(m[1] || '').trim() : '';
      };

      const getImageNaturalSize = async (file) => {
        return await new Promise((resolve, reject) => {
          let url = '';
          try {
            url = URL.createObjectURL(file);
            const img = new Image();
            img.onload = () => {
              try { URL.revokeObjectURL(url); } catch(_) {}
              const w = Number(img.naturalWidth);
              const h = Number(img.naturalHeight);
              resolve({ width: w, height: h });
            };
            img.onerror = () => {
              try { URL.revokeObjectURL(url); } catch(_) {}
              reject(new Error('Kunne ikke indlæse billeddimensioner'));
            };
            img.src = url;
          } catch (e) {
            try { if (url) URL.revokeObjectURL(url); } catch(_) {}
            reject(e);
          }
        });
      };

      const children = [];
      const step3 = collectAllStep3DocsWithFiles().filter(x => x?.file && String(x.file.type || '').startsWith('image/'));
      const vedlaeg = collectOverlayVedlaegWithFiles().filter(x => x?.file && String(x.file.type || '').startsWith('image/'));

      const { itemsWithLetter: step3ItemsWithLetter, letterByDocId: step3LetterById } = buildStep3BilagLetterIndex(step3);
      const step3ComplianceGroups = buildStep3ComplianceSummaryGroups(step3LetterById);
      const step3ComplianceLines = buildStep3ComplianceSummaryLines(step3ComplianceGroups);

      const vedlaegByKey = buildOverlayVedlaegIndex(vedlaeg);
      const { idx: vedlaegByFileName, norm: normFileName } = buildVedlaegByFileName(vedlaeg);

      const addImage = async (title, file, caption, subtitle) => {
        const ab = await file.arrayBuffer();
        // Lock bilag width to 90% of the "large" docx image width.
        let w = 504; // 560 * 0.9
        let h = 378;
        try {
          const dim = await getImageNaturalSize(file);
          const nw = Number(dim?.width);
          const nh = Number(dim?.height);
          if (Number.isFinite(nw) && Number.isFinite(nh) && nw > 0 && nh > 0) {
            const targetW = 504;
            const maxH = 760;
            let tw = targetW;
            let th = Math.round((nh / nw) * tw);
            if (th > maxH) {
              th = maxH;
              tw = Math.round((nw / nh) * th);
            }
            w = Math.max(1, tw);
            h = Math.max(1, th);
          }
        } catch(_) {}
        if (title) {
          children.push(new Paragraph({
            children: [new TextRun({ text: String(title), bold: true, font: DOC_FONT, size: DOC_SIZE })]
          }));
        }
        if (subtitle) {
          children.push(new Paragraph({
            children: [new TextRun({ text: String(subtitle), italics: true, font: DOC_FONT, size: DOC_SIZE - 2 })]
          }));
        }
        children.push(new Paragraph({ children: [new ImageRun({ data: ab, transformation: { width: w, height: h } })] }));
        if (caption) {
          children.push(new Paragraph({
            children: [new TextRun({ text: String(caption), font: DOC_FONT, size: DOC_SIZE })]
          }));
        }
        children.push(new Paragraph({ text: '' }));
      };

      let insertedComplianceSummary = false;
      const insertComplianceSummaryInline = () => {
        if (insertedComplianceSummary) return;
        insertedComplianceSummary = true;
        if (!step3ComplianceLines.length) return;

        children.push(new Paragraph({ text: '' }));
        for (const lnRaw of step3ComplianceLines) {
          const ln = String(lnRaw ?? '');
          const trimmed = ln.trimEnd();
          if (!trimmed.trim()) {
            children.push(new Paragraph({ text: '' }));
            continue;
          }

          const isMainTitleLine = /^Kravliste\b/i.test(trimmed);
          const isSectionLine = /^Bygning\s+\d+\s*\/\s*Bygningsafsnit\s+\d+/i.test(trimmed);
          const isGroupLine = /^Kravgruppe\s*:/i.test(trimmed);
          const isBulletLine = /^•\s+/.test(trimmed);
          const isBilagLine = /^\s*(?:Dokumentation\s*:|Dokumentation\s+kan\s+ses\s+i\s+bilag\b|-\s*Der\s+er\s+ikke\s+knyttet\s+dokumentation\b)/i.test(trimmed.trim());

          if (isMainTitleLine) {
            children.push(new Paragraph({
              heading: HeadingLevel.HEADING_2,
              children: [new TextRun({ text: trimmed.trim(), bold: true, font: DOC_FONT, size: DOC_SIZE + 2 })],
            }));
            children.push(new Paragraph({ text: '' }));
            continue;
          }

          if (isSectionLine) {
            children.push(new Paragraph({
              heading: HeadingLevel.HEADING_3,
              children: [new TextRun({ text: trimmed.trim(), bold: true, font: DOC_FONT, size: DOC_SIZE })],
              spacing: { before: 160, after: 80 }
            }));
            continue;
          }

          if (isGroupLine) {
            children.push(new Paragraph({
              children: [new TextRun({ text: trimmed.trim(), bold: true, font: DOC_FONT, size: DOC_SIZE })],
              spacing: { before: 160, after: 80 }
            }));
            continue;
          }

          if (isBulletLine) {
            const text = trimmed.replace(/^•\s+/, '').trim();
            children.push(new Paragraph({
              bullet: { level: 0 },
              spacing: { before: 0, after: 40 },
              children: [new TextRun({ text, font: DOC_FONT, size: DOC_SIZE })]
            }));
            continue;
          }

          if (isBilagLine) {
            children.push(new Paragraph({
              indent: { left: 540 },
              spacing: { before: 0, after: 160 },
              children: [new TextRun({ text: trimmed.trim(), italics: true, font: DOC_FONT, size: DOC_SIZE - 2 })]
            }));
            continue;
          }

          children.push(new Paragraph({
            children: [new TextRun({ text: trimmed.trim(), font: DOC_FONT, size: DOC_SIZE })]
          }));
        }
        children.push(new Paragraph({ text: '' }));
      };

      const appendStep3BilagAtEnd = async () => {
        if (!step3ItemsWithLetter.length) return;
        children.push(new Paragraph({ text: '' }));
        children.push(new Paragraph({ text: 'Bilag (trin 3)', heading: HeadingLevel.HEADING_2 }));
        children.push(new Paragraph({ children: [new TextRun({ text: 'Bilagene er samlet nederst og refereres i afsnit 5 som A, B, C, ...', italics: true })] }));
        children.push(new Paragraph({ text: '' }));

        for (const item of step3ItemsWithLetter) {
          const letter = String(item.__bilagLetter || '').trim();
          const cat = String(item.category || 'Kravgruppe').trim() || 'Kravgruppe';
          const name = String(item.meta?.name || item.file?.name || 'bilag');
          const cap = String(item.meta?.caption || '').trim();
          const desc = String(item.meta?.description || '').trim();
          const label = `${cat} — Bygning ${item.buildingIndex + 1} / Bygningsafsnit ${item.sectionIndex + 1}: ${item.sectionTitle}`;
          const titleText = String((cap || name) || '').trim();
          const title = (letter ? `Bilag ${letter}` : 'Bilag') + (titleText ? `: ${titleText}` : '');
          const subtitle = desc ? (label + ' | ' + desc) : label;
          await addImage(title, item.file, '', subtitle);
        }
      };

      let inVedlagteFiler = false;
      for (const lineRaw of String(draftText || '').split(/\r?\n/)) {
        let line = String(lineRaw ?? '');
        line = normalizeWeirdListLine(line);

        // Insert compliance summary inside section 5 (right after the heading line).
        // Avoid inserting inside the TOC by requiring the anchor line to be ALL-CAPS.
        const insertComplianceAfterLine = (!insertedComplianceSummary && (() => {
          const t = String(line || '').trim();
          if (!t) return false;
          if (t !== t.toUpperCase()) return false;
          return /NOTAT\s+OM\s+(?:DEN\s+)?BRANDTEKNISK/i.test(t);
        })());

        // Inline Step-4 attachments where placeholders appear
        const vedKey = extractVedlaegKeyFromLine(line);
        if (vedKey) {
          const nk = normalizeKey(vedKey);
          const matches = Array.isArray(vedlaegByKey[nk]) ? vedlaegByKey[nk] : [];
          if (matches.length) {
            for (const it of matches) {
              const cap = String(it.caption || '').trim();
              const title = '';
              const caption = cap || '';
              await addImage(title, it.file, caption, '');
            }
            continue; // don't add placeholder line as plain text
          }
        }

        const trimmed = String(line || '').trim();
        if (/^Vedlagte\s+filer\s*:/i.test(trimmed)) {
          inVedlagteFiler = true;
        } else if (inVedlagteFiler) {
          if (!trimmed) {
            inVedlagteFiler = false;
          } else if (!/^[-•]\s+/.test(trimmed)) {
            inVedlagteFiler = false;
          }
        }

        let postMatches = [];
        if (/^Vedlagt\s*:/i.test(trimmed)) {
          const fname = parseVedlagtFileNameFromLine(trimmed);
          const hits = Array.isArray(vedlaegByFileName[normFileName(fname)]) ? vedlaegByFileName[normFileName(fname)] : [];
          if (hits.length) postMatches = hits;
        } else if (inVedlagteFiler && /^[-•]\s+/.test(trimmed)) {
          const fname = parseVedlagtFileNameFromLine(trimmed.replace(/^[-•]\s+/, ''));
          const hits = Array.isArray(vedlaegByFileName[normFileName(fname)]) ? vedlaegByFileName[normFileName(fname)] : [];
          if (hits.length) postMatches = hits;
        }

        if (isSeparatorLine(line)) continue;

        if (!line.trim()) {
          children.push(new Paragraph({ text: '' }));
          continue;
        }

        if (isHeadingLine(line)) {
          const lvl = headingLevelFor(line);
          const size = (lvl === HeadingLevel.HEADING_1) ? 28 : (lvl === HeadingLevel.HEADING_2 ? 26 : 24);
          children.push(new Paragraph({
            heading: lvl,
            children: [
              new TextRun({ text: String(line).trim(), bold: true, font: DOC_FONT, size })
            ]
          }));

          if (insertComplianceAfterLine) {
            insertComplianceSummaryInline();
          }
          continue;
        }

        children.push(new Paragraph({
          children: [new TextRun({ text: line, font: DOC_FONT, size: DOC_SIZE })]
        }));

        if (postMatches.length) {
          for (const it of postMatches) {
            const cap = String(it.caption || '').trim();
            const caption = cap || '';
            await addImage('', it.file, caption, '');
          }
        }
      }

      // If anchor missing (user edited), still include the compliance summary at the end.
      if (!insertedComplianceSummary) {
        insertComplianceSummaryInline();
      }

      // If there were no [VEDLÆG: ...] placeholders at all, append vedlæg at end
      const anyVedPlaceholderInText = /\[(?:VEDLÆG|VEDLAEG)\s*:/i.test(String(draftText || ''));
      if (!anyVedPlaceholderInText && vedlaeg.length) {
        children.push(new Paragraph({ text: '' }));
        children.push(new Paragraph({ text: 'Vedlæg (trin 4) – ikke placeret i tekst', heading: HeadingLevel.HEADING_2 }));
        for (const it of vedlaeg) {
          const cap = String(it.caption || '').trim();
          const caption = cap || '';
          await addImage('', it.file, caption, '');
        }
      }

      // Always place Step-3 bilag at the very bottom.
      await appendStep3BilagAtEnd();

      const doc = new Document({
        styles: {
          default: {
            document: {
              run: { font: DOC_FONT, size: DOC_SIZE },
            },
          },
        },
        sections: [{ children }]
      });
      const blob = await Packer.toBlob(doc);
      const url = URL.createObjectURL(blob);

      // Try auto-download; if blocked, provide a clickable fallback link in the overlay
      try {
        const a = document.createElement('a');
        a.href = url;
        a.download = `BK1_Dokumentation_${projectInfo.__safeName}_${today.replace(/\./g, '-')}.docx`;
        document.body.appendChild(a);
        a.click();
        a.remove();
      } catch(_) {}

      try {
        const overlay = document.getElementById('doc-generator-overlay');
        const actions = overlay ? overlay.querySelector('.bilag-actions .right') : null;
        if (actions) {
          let link = document.getElementById('docx-download-link');
          if (!link) {
            link = document.createElement('a');
            link.id = 'docx-download-link';
            link.className = 'btn-secondary';
            link.style.textDecoration = 'none';
            link.textContent = '⬇ Download DOCX';
            actions.prepend(link);
          }
          link.href = url;
          link.download = `BK1_Dokumentation_${projectInfo.__safeName}_${today.replace(/\./g, '-')}.docx`;
        }
      } catch(_) {}

      setTimeout(() => { try { URL.revokeObjectURL(url); } catch(_) {} }, 60_000);
    }
    
    function generateDocumentWithProjectInfo(bk1Sections, explanations, projectInfo) {
      // Legacy helper (kept for backwards compatibility). The overlay export path
      // uses buildDocumentTextWithProjectInfo directly.
      const today = new Date().toLocaleDateString('da-DK');
      const p = projectInfo || { projektnavn: '—', adresse: '—', bygherre: '—', raadgiver: '—' };
      const safeName = String(p.projektnavn || 'projekt').replace(/[^a-zA-Z0-9]/g, '_');
      const text = buildDocumentTextWithProjectInfo(bk1Sections || [], explanations || [], p);

      const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      try {
        const a = document.createElement('a');
        a.href = url;
        a.download = 'BK1_Dokumentation_' + safeName + '_' + today.replace(/\./g, '-') + '.txt';
        document.body.appendChild(a);
        a.click();
        a.remove();
      } finally {
        try { URL.revokeObjectURL(url); } catch (_) {}
      }
    }

    function filterActiveInputsForRule(node, rule, inputs, computedValues) {
      if (!node || !rule || !node.content || !Array.isArray(node.content.inputs)) return [];
      const out = [];
      node.content.inputs.forEach(inp => {
        if (!inp || !inp.id) return;
        const conditionValue = rule[inp.id];
        const isArray = Array.isArray(conditionValue);
        const isActive = conditionValue !== '' && conditionValue !== undefined && conditionValue !== null && !(isArray && conditionValue.length === 0);
        if (!isActive) return;

        const fieldName = inp.field;
        const displayName = inp.name || inp.field || inp.id;

        let value = undefined;
        if (computedValues && fieldName in computedValues) value = computedValues[fieldName];
        if (value === undefined) value = inputs ? inputs[fieldName] : undefined;

        out.push({
          field: fieldName,
          name: displayName,
          condition: conditionValue,
          value
        });
      });
      return out;
    }

    function buildAutoClassificationExplanationTextForSection(section, idx) {
      if (!section || !section.data) return '';
      const evaluation = section.data;
      const inputs = section.inputs || {};

      const akValue = evaluation?.anvendelseskategori?.value;
      const rkValue = evaluation?.risikoklasse?.value;
      const bkValue = evaluation?.brandklasse?.value;
      const bilagValue = evaluation?.relevant_bilag?.value || evaluation?.relevant_bilag;
      const bilagTitle = getBilagTitleFromEvaluation(evaluation);

      const computed = {
        anvendelseskategori: akValue,
        risikoklasse: rkValue,
        brandklasse: bkValue,
        relevant_bilag: bilagValue
      };

      const lines = [];
      lines.push('Følgende afsnit dokumenterer fastlæggelsen af byggeriets anvendelseskategori, risikoklasse og brandklasse på baggrund af de indtastede projektoplysninger. Klassificeringen danner grundlag for den videre brandtekniske dokumentation.');
      lines.push('');

      const uniq = (arr) => {
        const out = [];
        const seen = new Set();
        for (const s of (arr || [])) {
          const key = String(s || '').trim();
          if (!key) continue;
          if (seen.has(key)) continue;
          seen.add(key);
          out.push(key);
        }
        return out;
      };

      const formatConditionSentence = (ac) => {
        if (!ac) return '';
        const field = ac.field;
        const name = ac.name;
        const value = ac.value;
        const condition = ac.condition;

        if (field === 'anvendelseskategori') {
          return `Bygningsafsnittet er vurderet til anvendelseskategori ${value}`;
        }
        if (field === 'risikoklasse') {
          return `Bygningsafsnittet er vurderet til risikoklasse ${value}`;
        }
        if (field === 'relevant_bilag') {
          return `Der anvendes relevant bilag ${formatBilagDisplayId(value)}`;
        }

        // Explicit area fields (as requested)
        if (field === 'area_BA') {
          const v = (value === null || value === undefined) ? '' : String(value).trim();
          return `Arealet af bygningsafsnittet er ${v} m²`;
        }
        if (field === 'area_total') {
          const v = (value === null || value === undefined) ? '' : String(value).trim();
          return `Det totale areal af bygningen er ${v} m²`;
        }

        try {
          return formatChecklistItem(field, name, value, condition);
        } catch (_) {
          return `${name}: ${value}`;
        }
      };

      const getActiveBullets = (nodeNameCandidates, outputField, matchedRuleId, opts) => {
        const options = opts || {};
        const excludeFields = new Set(options.excludeFields || []);
        let bullets = [];
        try {
          const node = findDecisionNodeByNameOrOutput(nodeNameCandidates, outputField);
          const rule = findRuleByIdOrIndex(node, matchedRuleId);
          const active = extractActiveConditions(node, rule, inputs, computed);
          bullets = active
            .filter(ac => ac && !excludeFields.has(ac.field))
            .map(ac => formatConditionSentence(ac))
            .map(s => `- ${s}`)
            .filter(Boolean);
        } catch (_) {}
        return uniq(bullets);
      };

      const normalizeAkConclusion = (akVal, descRaw) => {
        const desc = (descRaw === null || descRaw === undefined) ? '' : String(descRaw).trim();
        if (!desc) return `Bygningsafsnittet henføres derfor til anvendelseskategori ${akVal}.`;
        const m = desc.match(/Dette\s+er\s+typisk\s+([^\.]+)\.?/i);
        if (m && m[1]) {
          return `Bygningsafsnittet henføres derfor til anvendelseskategori ${akVal}, som omfatter typisk ${m[1].trim()}.`;
        }
        return `Bygningsafsnittet henføres derfor til anvendelseskategori ${akVal}.`;
      };

      const normalizeRkConclusion = (rkVal, descRaw) => {
        const raw = (descRaw === null || descRaw === undefined) ? '' : String(descRaw).trim();
        if (!raw) return `Byggeriet klassificeres derfor i risikoklasse ${rkVal}.`;
        let d = raw.replace(/\s+/g, ' ');
        // Typical patterns: "Risikoklasse 1 indikerer at byggeriet er ..."
        d = d.replace(/^Risikoklasse\s*\d+\s*(indikerer|angiver|betyder)\s+at\s+/i, '');
        d = d.replace(/^Risikoklasse\s*\d+\s*(indikerer|angiver|betyder)\s+/i, '');
        d = d.replace(/^Risikoklasse\s*\d+\s*/i, '');
        d = d.replace(/^byggeriet\s+er\s+/i, '');
        d = d.trim();
        if (!d) return `Byggeriet klassificeres derfor i risikoklasse ${rkVal}.`;
        if (!/[.!?]$/.test(d)) d += '.';
        return `På denne baggrund vurderes byggeriet at være ${d} Byggeriet klassificeres derfor i risikoklasse ${rkVal}.`;
      };

      const normalizeBkConclusion = (bkVal) => {
        const v = (bkVal === null || bkVal === undefined) ? '' : String(bkVal).trim();
        if (!v) return '';
        if (v === '1') {
          return 'Byggeriet henføres derfor til brandklasse 1, hvor den brandtekniske dokumentation kan ske på grundlag af præ-accepterede løsninger uden brandteknisk dimensionering.';
        }
        if (v === '2') {
          return 'Byggeriet henføres derfor til brandklasse 2, hvor den brandtekniske dokumentation typisk forudsætter certificeret brandrådgivning og kan omfatte fravigelser og/eller brandteknisk dimensionering.';
        }
        return `Byggeriet henføres derfor til brandklasse ${v}.`;
      };

      // ===== Anvendelseskategori =====
      if (akValue !== null && akValue !== undefined && String(akValue).trim() !== '') {
        lines.push(`Anvendelseskategori: ${akValue}`);
        const akBullets = getActiveBullets(
          ['Anvendelseskategori 2.0'],
          'anvendelseskategori',
          evaluation?.anvendelseskategori?.matched_rule_id,
          { excludeFields: [] }
        );
        if (akBullets.length > 0) {
          lines.push('Det er angivet at:');
          lines.push(...akBullets);
        }
        lines.push(normalizeAkConclusion(akValue, evaluation?.anvendelseskategori?.description));
        lines.push('');
      }

      // ===== Risikoklasse =====
      if (rkValue !== null && rkValue !== undefined && String(rkValue).trim() !== '') {
        lines.push(`Risikoklasse: ${rkValue}`);
        const rkBullets = getActiveBullets(
          ['Risikoklasse'],
          'risikoklasse',
          evaluation?.risikoklasse?.matched_rule_id,
          { excludeFields: [] }
        );
        if (rkBullets.length > 0) {
          lines.push('Det er angivet at:');
          lines.push(...rkBullets);
        }
        lines.push(normalizeRkConclusion(rkValue, evaluation?.risikoklasse?.description));
        lines.push('');
      }

      // ===== Brandklasse =====
      if (bkValue !== null && bkValue !== undefined && String(bkValue).trim() !== '') {
        lines.push(`Brandklasse: ${bkValue}`);

        const bygningstypeArticle = (typeof describeBygningstypeArticle === 'function')
          ? describeBygningstypeArticle(inputs?.bygningstype)
          : 'et byggeri';
        const bilagRefTitle = bilagTitle ? String(bilagTitle).trim() : '';
        const bilagIntro = bilagRefTitle ? `i ${bilagRefTitle}` : 'i relevant bilag';
        lines.push(`Byggeriet er ${bygningstypeArticle} i anvendelseskategori ${akValue ?? 'N/A'} og risikoklasse ${rkValue ?? 'N/A'}, hvilket medfører at byggeriet vurderes op imod de præ-accepterede løsninger ${bilagIntro}.`);

        const bkBullets = getActiveBullets(
          ['Brandklasse', 'Præ-accepterede løsninger'],
          'brandklasse',
          evaluation?.brandklasse?.matched_rule_id,
          {
            excludeFields: [
              'anvendelseskategori',
              'risikoklasse',
              'relevant_bilag',
              'brandklasse'
            ]
          }
        );

        if (bkBullets.length > 0) {
          lines.push('Ydermere er det angivet at:');
          lines.push(...bkBullets);
        }

        lines.push(normalizeBkConclusion(bkValue));
        lines.push('');
      }

      return lines.join('\n').replace(/\n{3,}/g, '\n\n').trim();
    }

    // Same content as generateDocumentWithProjectInfo, but returns the text instead of downloading.
    function buildDocumentTextWithProjectInfo(bk1Sections, explanations, projectInfo, options) {
      const today = new Date().toLocaleDateString('da-DK');
      const bkMode = (() => {
        const n = parseInt(options?.brandklasse, 10);
        return Number.isFinite(n) ? n : 1;
      })();

      const buildBrandforholdDocsText = () => {
        const lines = [];
        let any = false;

        (bk1Sections || []).forEach((section) => {
          const docsByCategory = section?.kravCategoryDocs && typeof section.kravCategoryDocs === 'object'
            ? section.kravCategoryDocs
            : {};
          const categories = sortCategoryLabelsByOrder(
            Object.keys(docsByCategory)
              .filter(k => Array.isArray(docsByCategory[k]) && docsByCategory[k].length > 0),
            section?.kravCategoryOrder
          );

          if (categories.length === 0) return;
          any = true;
          const sIdx = Number.isFinite(Number(section?.sectionIndex)) ? Number(section.sectionIndex) : null;
          const bIdx = Number.isFinite(Number(section?.buildingIndex)) ? Number(section.buildingIndex) : null;
          const prefix = (bIdx !== null) ? `Bygning ${bIdx + 1} / ` : '';
          const sectionLabel = (sIdx !== null)
            ? `${prefix}Bygningsafsnit ${sIdx + 1}: ${section.title}`
            : `${prefix}${section.title}`;
          lines.push(sectionLabel);

          for (const cat of categories) {
            lines.push(`- ${cat}`);
            for (const d of (docsByCategory[cat] || [])) {
              const name = String(d?.name || 'fil');
              const caption = String(d?.caption || '').trim();
              const desc = String(d?.description || '').trim();
              lines.push(`  - ${caption ? `${name} — ${caption}` : name}`);
              if (desc) lines.push(`    ${desc}`);
            }
          }
          lines.push('');
        });

        if (!any) return 'Ingen dokumentation tilføjet i trin 3 endnu.';
        return lines.join('\n').trim();
      };

      let docContent = `${bkMode === 2 ? 'DOKUMENTATION (UDKAST) – DIALOG MED BRANDRÅDGIVER' : 'DOKUMENTATION TIL KOMMUNALBESTYRELSEN'}
    Brandteknisk ${bkMode === 2 ? 'dokumentationsudkast' : 'Dokumentation'} for Brandklasse ${bkMode} Byggeri

═══════════════════════════════════════════════════════════════

PROJEKTINFORMATION

Projektnavn:        ${projectInfo.projektnavn}
Adresse/Matrikel:   ${projectInfo.adresse}
Bygherre:           ${projectInfo.bygherre}
Rådgiver:           ${projectInfo.raadgiver}

Dato:               ${today}
Version:            1.0

═══════════════════════════════════════════════════════════════
 
INDHOLDSFORTEGNELSE

1. Teknisk information
2. Overordnede beskrivelser og forudsætninger
3. Redegørelse for valg af brandklasse
4. Tegningsmateriale
  4.1 Situationsplan
  4.2 Brandplan
5. Notat om brandteknisk udførelse

═══════════════════════════════════════════════════════════════

1. TEKNISK INFORMATION

`;

      bk1Sections.forEach((section, idx) => {
        const data = section.data;
        const explanation = explanations?.[idx];
        const bygningstype = section.inputs.bygningstype || 'N/A';

        docContent += `Bygningsafsnit ${idx + 1}: ${section.title}

Bygningstype:           ${bygningstype.charAt(0).toUpperCase() + bygningstype.slice(1)}
Anvendelseskategori:    ${data.anvendelseskategori?.value || 'N/A'}
Risikoklasse:           ${data.risikoklasse?.value || 'N/A'}
Relevant bilag:         ${data.relevant_bilag?.value || data.relevant_bilag || 'N/A'}
Forudsat brandklasse:   ${bkMode}

`;
        const autoExpl = buildAutoClassificationExplanationTextForSection(section, idx);
        const backendSummary = (explanation && explanation.summary) ? String(explanation.summary).trim() : '';
        const backendFull = (explanation && typeof explanation === 'object') ? explanation : null;

        if (autoExpl) {
          docContent += `BEGRUNDELSE FOR KLASSIFICERING:
${autoExpl}

`;
        } else if (backendSummary) {
          docContent += `BEGRUNDELSE FOR KLASSIFICERING:
${backendSummary}

`;
        } else if (backendFull && (backendFull.anvendelseskategori || backendFull.risikoklasse || backendFull.brandklasse)) {
          // Fallback if backend returned structured explanations but no summary
          const parts = [];
          try {
            if (backendFull.anvendelseskategori?.text) parts.push(String(backendFull.anvendelseskategori.text).trim());
            if (backendFull.risikoklasse?.text) parts.push(String(backendFull.risikoklasse.text).trim());
            if (backendFull.brandklasse?.text) parts.push(String(backendFull.brandklasse.text).trim());
          } catch (_) {}
          if (parts.length > 0) {
            docContent += `BEGRUNDELSE FOR KLASSIFICERING:
${parts.join('\n\n')}

`;
          }
        }
        docContent += `---

`;
      });

      docContent += `
    ══════════════════════════════════════════════════════════════

    2. OVERORDNEDE BESKRIVELSER OG FORUDSÆTNINGER

Projektbeskrivelse:
[UDFYLD: Beskriv projektets overordnede karakter, formål og anvendelse]

Forudsætninger:
Se teknisk information ovenfor for automatisk genererede oplysninger.

═══════════════════════════════════════════════════════════════

3. REDEGØRELSE FOR VALG AF BRANDKLASSE

${bkMode === 2
  ? `Byggeriet er indplaceret i Brandklasse 2. Dette udkast kan bruges som dialoggrundlag med en brandrådgiver.
Den endelige vurdering og dokumentation skal udarbejdes af en certificeret brandrådgiver.`
  : `Byggeriet er klassificeret som Brandklasse 1 baseret på de præ-accepterede 
løsninger i BR18. Se teknisk information ovenfor for detaljeret begrundelse
genereret af BR18 Komplet System.`}

[UDFYLD: Supplér med yderligere projektspecifik information om 
brandklassificeringen hvis relevant]

[VEDLÆG: Figurer til brandklasse]

═══════════════════════════════════════════════════════════════

4. TEGNINGSMATERIALE

4.1 SITUATIONSPLAN
[VEDLÆG: Situationsplan]
- Bygningernes placering på ejendommen
- Forhold til anden bebyggelse
- Forhold til naboskel
- Vej- og stimidte

4.2 BRANDPLAN
[VEDLÆG: Brandplaner]
- Bygningens eventuelle opdeling i brandmæssige enheder
- Placering af røgalarmer
- Eventuelle redningsåbninger
[Se Bilag 13 i BR18 vejledningen for krav til udfærdigelse af brandplaner]

═══════════════════════════════════════════════════════════════

5. NOTAT OM BRANDTEKNISK UDFØRELSE
[UDFYLD: Notat om brandteknisk udførelse]

 
`;

  return normalizeGeneratedDocumentText(docContent);
    }

    function normalizeGeneratedDocumentText(text) {
      if (text === null || text === undefined) return '';
      return String(text)
        // Remove legacy footer lines (document should be submission-ready)
        .replace(/\n\s*Dette dokument er genereret af BR18 Komplet System\.\s*\n?/m, '\n')
        .replace(/\n\s*Alle felter markeret med \[UDFYLD\] og \[VEDLÆG\] skal udfyldes\/vedlægges\s*\n?/m, '\n')
        .replace(/\n\s*f\u00f8r indsendelse til kommunalbestyrelsen\.\s*\n?/mi, '\n')
        .replace(/\n\s*Genereret:\s*[^\n]*\n?/mi, '\n')
        // Remove legacy appendix blocks (kept as a user-editable section 6 instead)
        .replace(
          /\n(?:═{10,}|-{10,}|_{10,}|={10,})\n\s*\nBILAG\s*\n[\s\S]*?NOTER TIL FÆRDIGMELDING\s*\n[\s\S]*?(?:═{10,}|-{10,}|_{10,}|={10,})\n\s*\n(?=Dette dokument er genereret af BR18 Komplet System\.)/m,
          '\n\n'
        )
        .replace(
          /\nBILAG\s*\n[\s\S]*?NOTER TIL FÆRDIGMELDING\s*\n[\s\S]*?(?=\n\s*Dette dokument er genereret af BR18 Komplet System\.)/m,
          '\n\n'
        )
        // Avoid leaking code indentation into the generated document
        .replace(/^[ \t]+(?=═)/gm, '')
        // Only strip indentation for numbered ALL-CAPS section headings (not TOC subitems like "5.1 Situationsplan")
        .replace(/^[ \t]+(?=\d+\.\s+[A-ZÆØÅ0-9][A-ZÆØÅ0-9 .\-]*$)/gm, '')
        // Keep output tidy
        .replace(/\n{3,}/g, '\n\n');
    }

    function updateDocHeaderLines(existingText, projectInfo) {
      if (!existingText) return existingText;
      const replaceLine = (text, label, value) => {
        const re = new RegExp(`^(${label}\\s*)(.*)$`, 'm');
        if (re.test(text)) return text.replace(re, `$1${value}`);
        return text;
      };
      let t = existingText;
      t = replaceLine(t, 'Projektnavn:\\s*', String(projectInfo.projektnavn || ''));
      t = replaceLine(t, 'Adresse/Matrikel:\\s*', String(projectInfo.adresse || ''));
      t = replaceLine(t, 'Bygherre:\\s*', String(projectInfo.bygherre || ''));
      t = replaceLine(t, 'Rådgiver:\\s*', String(projectInfo.raadgiver || ''));
      return t;
    }

    function parseProjectInfoFromDraft(text) {
      if (!text) return null;
      const read = (label) => {
        const re = new RegExp(`^${label}\\s*(.*)$`, 'm');
        const m = String(text).match(re);
        return (m && m[1] ? String(m[1]).trim() : '');
      };
      const projektnavn = read('Projektnavn:');
      const adresse = read('Adresse/Matrikel:');
      const bygherre = read('Bygherre:');
      const raadgiver = read('Rådgiver:');
      if (!projektnavn && !adresse && !bygherre && !raadgiver) return null;
      return { projektnavn, adresse, bygherre, raadgiver };
    }

    function generateDocumentationTemplate() {
      // Collect all Brandklasse 1 sections
      const bk1Sections = [];
      for (let i = 0; i < sectionsState.count; i++) {
        const evalRes = sectionsState.evaluations[i];
        if (evalRes && (evalRes.brandklasse?.value === '1' || evalRes.brandklasse?.value === 1)) {
          bk1Sections.push({
            sectionIndex: i,
            title: sectionsState.titles[i] || `Bygningsafsnit ${i+1}`,
            data: evalRes,
            inputs: sectionsState.inputData[i] || {},
            kravCategoryDocs: sectionsState.kravCategoryDocs?.[String(i)] || {}
          });
        }
      }
      
      if (bk1Sections.length === 0) {
        alert('Ingen bygningsafsnit er klassificeret som Brandklasse 1.');
        return;
      }
      
      // Fetch explanations for all sections
      const explanationPromises = bk1Sections.map(async section => {
        try {
          const resp = await fetch(`${API_BASE}/generate-explanation`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
              inputs: section.inputs,
              results: section.data
            })
          });
          if (resp.ok) {
            const data = await resp.json();
            return data.explanation;
          }
        } catch (e) {
          console.error('Failed to fetch explanation:', e);
        }
        return null;
      });
      
      // Wait for all explanations and generate document
      Promise.all(explanationPromises).then(explanations => {
        generateDocumentWithExplanations(bk1Sections, explanations);
      });
    }
    
    function generateDocumentWithExplanations(bk1Sections, explanations) {
      // Generate documentation template
      const today = new Date().toLocaleDateString('da-DK');
      let docContent = `DOKUMENTATION TIL KOMMUNALBESTYRELSEN
Brandteknisk Dokumentation for Brandklasse 1 Byggeri

Dato: ${today}
Genereret af: BR18 Komplet System

═══════════════════════════════════════════════════════════════

INDHOLDSFORTEGNELSE

1. Teknisk information
2. Overordnede beskrivelser og forudsætninger
3. Redegørelse for valg af brandklasse
4. Tegningsmateriale
  4.1 Situationsplan
  4.2 Brandplan
5. Notat om brandteknisk udførelse

═══════════════════════════════════════════════════════════════

1. TEKNISK INFORMATION
`;

      // Add section data with explanations
      bk1Sections.forEach((section, idx) => {
        const data = section.data;
        const explanation = explanations[idx];
        
        docContent += `\nBygningsafsnit ${idx + 1}: ${section.title}
- Anvendelseskategori: ${data.anvendelseskategori?.value || 'N/A'}
- Risikoklasse: ${data.risikoklasse?.value || 'N/A'}
- Relevant bilag: ${data.relevant_bilag?.value || data.relevant_bilag || 'N/A'}
- Brandklasse: ${data.brandklasse?.value || 'N/A'}

`;
        // Add automatic explanation if available
        if (explanation && explanation.anvendelseskategori) {
          docContent += `Anvendelseskategori forklaring:
${explanation.anvendelseskategori.description}

`;
        }
        if (explanation && explanation.risikoklasse) {
          docContent += `Risikoklasse forklaring:
${explanation.risikoklasse.description}

`;
        }
      });

      docContent += `
═══════════════════════════════════════════════════════════════

2. OVERORDNEDE BESKRIVELSER OG FORUDSÆTNINGER

Projektbeskrivelse:
[UDFYLD: Beskriv projektets overordnede karakter, formål og anvendelse]

Forudsætninger:
Se teknisk information ovenfor for automatisk genererede oplysninger.

═══════════════════════════════════════════════════════════════

3. REDEGØRELSE FOR VALG AF BRANDKLASSE

Byggeriet er klassificeret som Brandklasse 1 baseret på følgende:

`;

      bk1Sections.forEach((section, idx) => {
        const explanation = explanations[idx];
        docContent += `\nBygningsafsnit ${idx + 1}: ${section.title}

`;
        // Add automatic explanation for brandklasse
        if (explanation && explanation.summary) {
          docContent += `Automatisk genereret forklaring:
${explanation.summary}

`;
        }
        
        docContent += `[UDFYLD: Supplér med yderligere projektspecifik information om brandklassificeringen]

`;
      });

      docContent += `
    ══════════════════════════════════════════════════════════════

  4. TEGNINGSMATERIALE

  4.1 SITUATIONSPLAN
[VEDLÆG: Situationsplan]
- Bygningernes placering på ejendommen
- Forhold til anden bebyggelse
- Forhold til naboskel
- Vej- og stimidte

  4.2 BRANDPLAN
[VEDLÆG: Brandplaner]
- Bygningens eventuelle opdeling i brandmæssige enheder
- Placering af røgalarmer
- Eventuelle redningsåbninger
[Se Bilag 13 i BR18 vejledningen for krav til udfærdigelse af brandplaner]

═══════════════════════════════════════════════════════════════

  5. NOTAT OM BRANDTEKNISK UDFØRELSE

[UDFYLD: Notat om brandteknisk udførelse]

═══════════════════════════════════════════════════════════════

BILAG

Følgende bilag skal vedlægges:
□ Situationsplan (tegning)
□ Brandplan (tegning)
□ Eventuel godkendelse fra kommunalbestyrelsen (ved fravigelser)
□ Dokumentation for materialevalg
□ Beregninger (hvis relevant)

═══════════════════════════════════════════════════════════════

NOTER TIL FÆRDIGMELDING

Ved færdigmelding skal følgende opdateres/vedlægges:
□ Opdateret dokumentation med eventuelle ændringer i det færdige byggeri
□ DKV-plan (Drift-, Kontrol- og Vedligeholdelsesplan)
□ Bekræftelse på at byggeriet er udført i overensstemmelse med godkendt dokumentation

═══════════════════════════════════════════════════════════════

Dette dokument er en skabelon genereret af BR18 Komplet System.
Alle felter markeret med [UDFYLD] og [VEDLÆG] skal udfyldes/vedlægges før indsendelse til kommunalbestyrelsen.
`;

      // Create and download the document
      docContent = normalizeGeneratedDocumentText(docContent);
      const blob = new Blob([docContent], {type: 'text/plain;charset=utf-8'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `Brandklasse_1_Dokumentation_${today.replace(/\./g, '-')}.txt`;
      a.click();
      URL.revokeObjectURL(url);
      
      // Show confirmation
      alert('Dokumentationsskabelon er genereret og downloadet!\n\nHusk at udfylde alle [UDFYLD] felter og vedlægge alle [VEDLÆG] dokumenter før indsendelse til kommunalbestyrelsen.');
    }

    // Custom Dropdown Implementation
    function initCustomSelects() {
      document.querySelectorAll('select:not(.custom-select-native)').forEach(select => {
        // Skip if already converted
        if (select.parentElement?.classList.contains('custom-select-wrapper')) return;
        
        // Create wrapper
        const wrapper = document.createElement('div');
        wrapper.className = 'custom-select-wrapper';
        select.parentNode.insertBefore(wrapper, select);
        wrapper.appendChild(select);
        select.classList.add('custom-select-native');
        
        // Create custom select
        const customSelect = document.createElement('div');
        customSelect.className = 'custom-select';
        customSelect.setAttribute('tabindex', '0');
        
        const trigger = document.createElement('div');
        trigger.className = 'custom-select-trigger';
        
        const valueEl = document.createElement('span');
        valueEl.className = 'custom-select-value';
        
        const arrow = document.createElement('span');
        arrow.className = 'custom-select-arrow';
        
        trigger.appendChild(valueEl);
        trigger.appendChild(arrow);
        customSelect.appendChild(trigger);
        
        // Create dropdown
        const dropdown = document.createElement('div');
        dropdown.className = 'custom-select-dropdown';
        
        // Build options
        function buildOptions() {
          dropdown.innerHTML = '';
          let currentGroup = null;
          
          Array.from(select.options).forEach(option => {
            // Skip disabled placeholder options in the dropdown list
            if (option.disabled && option.value === '') {
              return;
            }
            
            // Check for optgroup
            const parentGroup = option.parentElement;
            if (parentGroup.tagName === 'OPTGROUP' && parentGroup !== currentGroup) {
              currentGroup = parentGroup;
              const groupLabel = document.createElement('div');
              groupLabel.className = 'custom-option-group-label';
              groupLabel.textContent = parentGroup.label;
              dropdown.appendChild(groupLabel);
            }
            
            const optionEl = document.createElement('div');
            optionEl.className = 'custom-option';
            if (parentGroup.tagName === 'OPTGROUP') {
              optionEl.classList.add('custom-option-group-item');
            }
            optionEl.textContent = option.textContent;
            optionEl.dataset.value = option.value;
            
            if (option.disabled) {
              optionEl.classList.add('disabled');
            }
            if (option.selected) {
              optionEl.classList.add('selected');
            }
            
            if (!option.disabled) {
              optionEl.addEventListener('click', (e) => {
                e.stopPropagation();
                select.value = option.value;
                select.dispatchEvent(new Event('change', { bubbles: true }));
                updateValue();
                // Close dropdown immediately after selection
                customSelect.classList.remove('open');
                try {
                  const host = customSelect.closest('.acc-item');
                  if (host) host.classList.remove('dropdown-host');
                } catch(_) {}
              });
            }
            
            dropdown.appendChild(optionEl);
          });
        }
        
        function updateValue() {
          const selectedOption = select.options[select.selectedIndex];
          if (selectedOption) {
            // If it's a disabled placeholder or no value selected, show empty/blank
            if ((selectedOption.disabled && selectedOption.value === '') || selectedOption.value === '') {
              valueEl.textContent = '';
              valueEl.classList.add('placeholder');
            } else {
              valueEl.textContent = selectedOption.textContent;
              valueEl.classList.remove('placeholder');
            }
          }
          
          // Update selected state
          dropdown.querySelectorAll('.custom-option').forEach(opt => {
            opt.classList.toggle('selected', opt.dataset.value === select.value);
          });
        }
        
        buildOptions();
        updateValue();
        customSelect.appendChild(dropdown);
        wrapper.appendChild(customSelect);

        // Toggle dropdown (click anywhere on the select box)
        customSelect.addEventListener('click', (e) => {
          // If click originated from inside the dropdown, ignore (dropdown stops propagation too).
          if (dropdown.contains(e.target)) return;
          e.stopPropagation();
          // Close all other dropdowns
          document.querySelectorAll('.custom-select.open').forEach(other => {
            if (other !== customSelect) other.classList.remove('open');
          });
          const willOpen = !customSelect.classList.contains('open');
          customSelect.classList.toggle('open');
          try {
            // Ensure the accordion item containing the open dropdown is above others.
            document.querySelectorAll('.acc-item.dropdown-host').forEach(it => it.classList.remove('dropdown-host'));
            const host = customSelect.closest('.acc-item');
            if (host && willOpen) host.classList.add('dropdown-host');
            if (host && !willOpen) host.classList.remove('dropdown-host');
          } catch(_) {}
        });

        // Prevent interactions inside the dropdown (scrollbar, group labels, whitespace)
        // from bubbling and accidentally toggling/closing the select.
        dropdown.addEventListener('mousedown', (e) => { e.stopPropagation(); });
        dropdown.addEventListener('click', (e) => { e.stopPropagation(); });
        
        // Keyboard navigation
        customSelect.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            customSelect.classList.toggle('open');
          } else if (e.key === 'Escape') {
            customSelect.classList.remove('open');
          } else if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
            e.preventDefault();
            const options = Array.from(select.options).filter(opt => !opt.disabled);
            const currentIndex = options.findIndex(opt => opt.selected);
            let newIndex = currentIndex;
            
            if (e.key === 'ArrowDown') {
              newIndex = Math.min(options.length - 1, currentIndex + 1);
            } else {
              newIndex = Math.max(0, currentIndex - 1);
            }
            
            if (options[newIndex]) {
              select.value = options[newIndex].value;
              select.dispatchEvent(new Event('change', { bubbles: true }));
              updateValue();
            }
          }
        });
        
        // Close on outside click
        document.addEventListener('click', () => {
          customSelect.classList.remove('open');
          try {
            const host = customSelect.closest('.acc-item');
            if (host) host.classList.remove('dropdown-host');
          } catch(_) {}
        });
        
        // Watch for programmatic changes
        const observer = new MutationObserver(() => {
          buildOptions();
          updateValue();
        });
        observer.observe(select, { childList: true, subtree: true, attributes: true, attributeFilter: ['selected'] });
        
        // Watch for value changes
        select.addEventListener('change', updateValue);
        
        // Create a property setter override to catch direct value assignments
        const nativeValueSetter = Object.getOwnPropertyDescriptor(HTMLSelectElement.prototype, 'value').set;
        const customValueSetter = function(val) {
          nativeValueSetter.call(this, val);
          setTimeout(() => updateValue(), 0);
        };
        if (!select.__customValueSet) {
          Object.defineProperty(select, 'value', {
            set: customValueSetter,
            get: function() {
              return this.options[this.selectedIndex]?.value || '';
            },
            configurable: true
          });
          select.__customValueSet = true;
        }
      });
    }

    // Initialize on load
    document.addEventListener('DOMContentLoaded', ()=>{
      console.log('DOM loaded, initializing event listeners...');

      // Disable spellcheck everywhere (including dynamically injected fields).
      // This prevents red underlines in project/documentation text areas.
      const disableSpellcheckIn = (root) => {
        try {
          const scope = root && root.querySelectorAll ? root : document;
          const nodes = scope.querySelectorAll('textarea, input[type="text"], input[type="search"], input[type="email"], input[type="url"], input[type="tel"], input:not([type])');
          nodes.forEach(el => {
            try {
              el.setAttribute('spellcheck', 'false');
              el.setAttribute('autocorrect', 'off');
              el.setAttribute('autocapitalize', 'off');
            } catch (_) {}
          });
        } catch (_) {}
      };
      disableSpellcheckIn(document);

      try {
        const obs = new MutationObserver((mutations) => {
          for (const m of mutations) {
            for (const n of (m.addedNodes || [])) {
              if (!n) continue;
              if (n.nodeType !== 1) continue;
              disableSpellcheckIn(n);
            }
          }
        });
        obs.observe(document.body, { childList: true, subtree: true });
      } catch (_) {}

      function initStep1FieldListLayout() {
        const accordion = document.getElementById('data-accordion');
        const list = document.getElementById('step1-field-list');
        if (!accordion || !list) return;

        const allFields = Array.from(accordion.querySelectorAll('.form-field'));
        if (allFields.length === 0) return;

        const fieldByControlId = new Map();
        for (const field of allFields) {
          const control = field.querySelector('[id^="fld_"]');
          if (control && control.id) fieldByControlId.set(control.id, field);
        }

        // Requested order (note: “fritstaaende” maps to fld_fritliggende_BA in the current UI)
        const orderedControlIds = [
          'fld_bygningstype',
          'fld_overnatning',
          'fld_kendskab_flugtveje',
          'fld_selvhjulpen',
          'fld_antal_personer_BA',
          'fld_area_BA',
          'fld_area_total',
          'fld_antal_etager_over_terraen_BA',
          'fld_antal_etager_under_terraen_BA',
          'fld_antal_etager_BA',
          'fld_brandbelastning_BA',
          'fld_etage_hoejde_BA',
          'fld_etage_dybde_BA',
          'fld_etage_hoejde',
          'fld_antal_overnattende',
          'fld_fritliggende_BA',
          'fld_med_erhvervssammenbygning',
          'fld_med_tilbygning',
          'fld_direkte_udgange',
          'fld_direkte_udgange_soverum',
          'fld_bygningsafsnit_i_RK4'
        ];

        const used = new Set();
        for (const controlId of orderedControlIds) {
          const field = fieldByControlId.get(controlId);
          if (!field || used.has(field)) continue;
          list.appendChild(field);
          used.add(field);
        }

        // Append any remaining fields (keeps functionality even if not listed in the requested order)
        const remaining = allFields.filter(f => !used.has(f));
        for (const field of remaining) list.appendChild(field);

        // Hide the old accordion shell now that fields are flattened
        accordion.style.display = 'none';
      }

      // Build the long-list layout before initializing custom selects and listeners.
      try { initStep1FieldListLayout(); } catch (_) {}
      
      // Initialize custom selects
      initCustomSelects();
      
      // Re-initialize after dynamic content loads
      const reinitSelects = () => {
        setTimeout(() => initCustomSelects(), 100);
      };
      
      // Ensure the first page starts without pre-filled data.
      function initializeEmptyForm(){
        // Clear numeric/text inputs in the left panel
        document.querySelectorAll('.left-panel .form-field input[type="number"], .left-panel .form-field input[type="text"]').forEach(el => {
          try { el.value = ''; } catch(_) {}
        });
        // Add a placeholder option for selects and reset them to "unselected"
        document.querySelectorAll('.left-panel .form-field select').forEach(sel => {
          try {
            const first = sel.options && sel.options[0];
            const hasPlaceholder = first && first.value === '' && first.disabled;
            if (!hasPlaceholder) {
              const opt = document.createElement('option');
              opt.value = '';
              opt.textContent = 'Vælg…';
              opt.disabled = true;
              opt.selected = true;
              sel.insertBefore(opt, sel.firstChild);
            }
            sel.value = '';
          } catch(_) {}
        });
        reinitSelects();
      }
      // Reset gate state on full reload so user can choose anew
      try { sessionStorage.removeItem('reqGateState'); } catch(_) {}
      // Convert native title tooltips to custom tooltips
      document.querySelectorAll('.info-icon[title]').forEach(el => {
        el.setAttribute('data-tip', el.getAttribute('title'));
        el.removeAttribute('title');
        if(!el.textContent.trim()) el.textContent = 'i';
      });

      // JS tooltip that clamps within viewport (prevents left/right overflow)
      const tooltip = document.createElement('div');
      tooltip.id = 'info-tooltip';
      tooltip.setAttribute('role', 'tooltip');
      document.body.appendChild(tooltip);

      const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
      let activeIcon = null;

      function hideTooltip(){
        tooltip.classList.remove('visible', 'above', 'below');
        tooltip.style.left = '-9999px';
        tooltip.style.top = '-9999px';
        activeIcon = null;
      }

      function positionTooltip(iconEl){
        if (!iconEl) return;
        const tip = iconEl.getAttribute('data-tip') || '';
        if (!tip.trim()) return;

        // Set content and show offscreen to measure
        tooltip.textContent = tip;
        tooltip.classList.add('visible');
        const requested = (() => {
          const raw = iconEl.getAttribute('data-tip-maxwidth');
          const n = raw ? Number.parseInt(String(raw).trim(), 10) : NaN;
          return Number.isFinite(n) && n > 0 ? n : 560;
        })();
        tooltip.style.maxWidth = `${Math.min(requested, window.innerWidth - 16)}px`;
        tooltip.style.left = '-9999px';
        tooltip.style.top = '-9999px';
        tooltip.classList.remove('above', 'below');
        tooltip.classList.add('above');

        const rect = iconEl.getBoundingClientRect();
        const tRect = tooltip.getBoundingClientRect();
        const margin = 8;
        const gap = 10;

        // Prefer above; flip below if not enough room
        let top = rect.top - tRect.height - gap;
        let placement = 'above';
        if (top < margin) {
          top = rect.bottom + gap;
          placement = 'below';
        }
        tooltip.classList.remove('above', 'below');
        tooltip.classList.add(placement);

        // Default left aligned with icon, but clamp to viewport
        let left = rect.left;
        left = clamp(left, margin, window.innerWidth - margin - tRect.width);

        // Arrow points to icon center, clamped within tooltip bounds
        const iconCenterX = rect.left + rect.width / 2;
        const arrowLeft = clamp(iconCenterX - left, 12, tRect.width - 12);
        tooltip.style.setProperty('--arrow-left', `${arrowLeft}px`);

        tooltip.style.left = `${left}px`;
        tooltip.style.top = `${top}px`;
      }

      function showTooltipFor(iconEl){
        activeIcon = iconEl;
        positionTooltip(iconEl);
      }

      function ensureInfoIconIsCustomTooled(el){
        if (!el) return;
        // Convert on-demand (supports dynamically inserted icons like bilag overlay)
        if (!el.getAttribute('data-tip')){
          const title = el.getAttribute('title');
          if (title && title.trim()){
            el.setAttribute('data-tip', title);
            el.removeAttribute('title');
          }
        }
        if(!el.textContent.trim()) el.textContent = 'i';
      }

      // Delegated hover/focus handlers so dynamically created icons also use custom tooltip
      document.addEventListener('mouseover', (e)=>{
        const iconEl = e.target && e.target.closest ? e.target.closest('.info-icon, .validation-badge, .tip-target') : null;
        if (!iconEl) return;
        const from = e.relatedTarget;
        if (from && iconEl.contains(from)) return; // still inside same icon
        ensureInfoIconIsCustomTooled(iconEl);
        showTooltipFor(iconEl);
      }, true);
      document.addEventListener('mouseout', (e)=>{
        const iconEl = e.target && e.target.closest ? e.target.closest('.info-icon, .validation-badge, .tip-target') : null;
        if (!iconEl) return;
        const to = e.relatedTarget;
        if (to && iconEl.contains(to)) return;
        hideTooltip();
      }, true);
      document.addEventListener('focusin', (e)=>{
        const iconEl = e.target && e.target.closest ? e.target.closest('.info-icon, .validation-badge, .tip-target') : null;
        if (!iconEl) return;
        ensureInfoIconIsCustomTooled(iconEl);
        showTooltipFor(iconEl);
      }, true);
      document.addEventListener('focusout', (e)=>{
        const iconEl = e.target && e.target.closest ? e.target.closest('.info-icon, .validation-badge, .tip-target') : null;
        if (!iconEl) return;
        hideTooltip();
      }, true);

      window.addEventListener('scroll', ()=>{ if (activeIcon) positionTooltip(activeIcon); }, true);
      window.addEventListener('resize', ()=>{ if (activeIcon) positionTooltip(activeIcon); });

      // Step 3: lockable, draggable panel for Krav_Korrekt_Dimensionering
      const dimPanel = document.getElementById('krav-dim-panel');
      const dimHeader = document.getElementById('krav-dim-header');
      const dimBody = document.getElementById('krav-dim-body');
      const dimPinBtn = document.getElementById('krav-dim-pin');
      const dimCloseBtn = document.getElementById('krav-dim-close');
      const dimTitleEl = document.getElementById('krav-dim-title');
      let dimPinned = false;
      let dimActiveSource = null;
      let dimHideTimer = null;
      let dragging = false;
      let dragOffsetX = 0;
      let dragOffsetY = 0;

      function hideDim(force = false){
        if (!dimPanel) return;
        if (dimPinned && !force) return;
        dimPanel.style.display = 'none';
        dimPanel.setAttribute('aria-hidden', 'true');
        dimActiveSource = null;
      }

      function scheduleHide(){
        if (dimHideTimer) clearTimeout(dimHideTimer);
        dimHideTimer = setTimeout(()=> hideDim(false), 180);
      }

      function showDim(text, anchorEl, title){
        if (!dimPanel || !dimBody) return;
        const t = (text || '').trim();
        if (!t) return;

        const parts = t.replace(/\r\n/g, '\n').split(/\n\s*\n/g).map(p => p.trim()).filter(Boolean);
        
        // Check validation status for dimensionering
        const kravId = (title || '').trim();
        const kravValidation = getKravValidationRecord(kravId);
        const isValidated = kravDimensioneringValidated(kravValidation);
        
        const validationBadgeHtml = `
          <div style="
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 14px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 12px;
            ${isValidated 
              ? 'background: var(--c-bg-2); color: var(--c-accent); border: 1px solid var(--c-accent);' 
              : 'background: var(--c-surface-muted); color: var(--c-primary); border: 1px solid var(--c-primary);'}
          ">
            ${isValidated ? '✓' : '✗ Ikke valideret'}
          </div>
        `;
        
        dimBody.innerHTML = parts.map(p => `<p>${escapeHtml(p)}</p>`).join('');
        if (dimTitleEl) {
          const extra = (title || '').trim();
          dimTitleEl.innerHTML = (extra ? `Uddybning (${extra})` : 'Uddybning (korrekt dimensionering)') + validationBadgeHtml;
        }

        // Position near anchor
        if (anchorEl) {
          const rect = anchorEl.getBoundingClientRect();
          const margin = 10;
          // Measure after making visible offscreen
          dimPanel.style.display = 'block';
          dimPanel.style.left = '-9999px';
          dimPanel.style.top = '-9999px';
          dimPanel.setAttribute('aria-hidden', 'false');
          const pRect = dimPanel.getBoundingClientRect();

          const preferredLeft = rect.right + 12;
          const preferredTop = rect.top - 12;
          const left = clamp(preferredLeft, margin, window.innerWidth - margin - pRect.width);
          const top = clamp(preferredTop, margin, window.innerHeight - margin - pRect.height);
          dimPanel.style.left = `${left}px`;
          dimPanel.style.top = `${top}px`;
        } else {
          dimPanel.style.display = 'block';
          dimPanel.setAttribute('aria-hidden', 'false');
        }

        if (dimPinBtn) dimPinBtn.textContent = dimPinned ? 'Lås op' : 'Lås';
      }

      if (dimCloseBtn) dimCloseBtn.addEventListener('click', ()=>{ dimPinned = false; hideDim(true); if (dimPinBtn) dimPinBtn.textContent = 'Lås'; });
      if (dimPinBtn) dimPinBtn.addEventListener('click', ()=>{ dimPinned = !dimPinned; if (dimPinBtn) dimPinBtn.textContent = dimPinned ? 'Lås op' : 'Lås'; if (!dimPinned) scheduleHide(); });

      // Delegated hover/click behavior on question icons
      document.addEventListener('mouseover', (e)=>{
        const icon = e.target && e.target.closest ? e.target.closest('.q-icon') : null;
        if (!icon) return;
        if (dimHideTimer) { clearTimeout(dimHideTimer); dimHideTimer = null; }
        const text = icon.getAttribute('data-dim') || '';
        const title = icon.getAttribute('data-dim-title') || '';
        const source = `${title}::${text.slice(0, 64)}`;
        if (dimPinned && dimActiveSource && dimActiveSource !== source) return;
        dimActiveSource = source;
        showDim(text, icon, title);
      }, true);
      document.addEventListener('mouseout', (e)=>{
        const icon = e.target && e.target.closest ? e.target.closest('.q-icon') : null;
        if (!icon) return;
        if (!dimPinned) scheduleHide();
      }, true);
      document.addEventListener('click', (e)=>{
        const icon = e.target && e.target.closest ? e.target.closest('.q-icon') : null;
        if (!icon) return;
        const text = icon.getAttribute('data-dim') || '';
        const title = icon.getAttribute('data-dim-title') || '';
        const source = `${title}::${text.slice(0, 64)}`;
        if (!dimPinned) {
          dimPinned = true;
          dimActiveSource = source;
          showDim(text, icon, title);
        } else if (dimActiveSource === source) {
          dimPinned = false;
          if (dimPinBtn) dimPinBtn.textContent = 'Lås';
          scheduleHide();
        }
        if (dimPinBtn) dimPinBtn.textContent = dimPinned ? 'Lås op' : 'Lås';
      }, true);

      // Dragging panel
      if (dimHeader && dimPanel) {
        dimHeader.addEventListener('mousedown', (e)=>{
          const btn = e.target && e.target.closest ? e.target.closest('button') : null;
          if (btn) return;
          dragging = true;
          const rect = dimPanel.getBoundingClientRect();
          dragOffsetX = e.clientX - rect.left;
          dragOffsetY = e.clientY - rect.top;
          e.preventDefault();
        });
        window.addEventListener('mousemove', (e)=>{
          if (!dragging) return;
          const margin = 8;
          const rect = dimPanel.getBoundingClientRect();
          const left = clamp(e.clientX - dragOffsetX, margin, window.innerWidth - margin - rect.width);
          const top = clamp(e.clientY - dragOffsetY, margin, window.innerHeight - margin - rect.height);
          dimPanel.style.left = `${left}px`;
          dimPanel.style.top = `${top}px`;
        });
        window.addEventListener('mouseup', ()=>{ dragging = false; });
      }

      // Load example button
      const loadBtn = document.getElementById('load-example');
      if (loadBtn) loadBtn.addEventListener('click', async ()=>{
        try {
          // Fetch input1.json from backend API host
          const resp = await fetch(`${API_BASE}/input1.json`);
          if(!resp.ok) throw new Error('Kan ikke hente input1.json');
          const exampleJson = await resp.json();
          // Normalize example payload so the advanced JSON view is stable and complete.
          const canonical = canonicalizeInputData(exampleJson);
          const merged = { ...canonical, ...getActiveBilagExtras() };
          if (merged.med_tilbygning === undefined) merged.med_tilbygning = null;
          if (merged.med_erhvervssammenbygning === undefined) merged.med_erhvervssammenbygning = null;
          jsonTextarea.value = JSON.stringify(merged, null, 2);

          // Loading an example is not a "manual JSON edit"; keep form as source of truth.
          jsonManualEdit = false;
          try { 
            syncingFromJson = true; 
            updateFormFromJson(merged);
            // Capture the loaded data to the current section so it doesn't leak to other sections
            captureInputsToSection(getActiveSectionIndex());
            // Force refresh of all custom dropdowns after a short delay
            setTimeout(() => {
              // Re-create all custom dropdowns to reflect new values
              if (typeof initCustomSelects === 'function') {
                initCustomSelects();
              }
              // Also manually trigger updateValue for each custom select
              document.querySelectorAll('.custom-select-wrapper').forEach(wrapper => {
                const customSelect = wrapper.querySelector('.custom-select-value');
                const select = wrapper.querySelector('select');
                if (select && customSelect) {
                  const selectedOpt = select.options[select.selectedIndex];
                  if (selectedOpt && selectedOpt.value !== '') {
                    customSelect.textContent = selectedOpt.textContent;
                    customSelect.classList.remove('placeholder');
                  } else {
                    customSelect.textContent = '';
                    customSelect.classList.add('placeholder');
                  }
                }
              });
            }, 150);
          } catch(_) {} finally { syncingFromJson = false; }
          updateStatus();
          scheduleEvaluate();
        } catch(err){
          console.error('Failed to fetch input1.json from server:', err);
          alert('Kan ikke hente input1.json fra serveren. Tjek at backend kører på http://127.0.0.1:8000 og at /input1.json kan tilgås.');
        }
      });

      // Wire up wizard navigation buttons
      ['btn-continue-step1', 'btn-continue-step1-top'].forEach(id => {
        const btn = document.getElementById(id);
        if (!btn) return;
        btn.addEventListener('click', () => {
          openPrestepOverlay();
        });
      });

      // Pre-step overlay navigation
      const prestepOverlay = document.getElementById('prestep-overlay');
      const prestepClose = document.getElementById('prestep-close');
      const prestepBack = document.getElementById('prestep-back');
      const prestepNext = document.getElementById('prestep-next');
      const prestepSkip = document.getElementById('prestep-skip');

      if (prestepOverlay){
        prestepOverlay.addEventListener('click', (e)=>{ if (e.target === prestepOverlay) closePrestepOverlay(); });
      }
      if (prestepClose) prestepClose.addEventListener('click', ()=> closePrestepOverlay());
      if (prestepBack) prestepBack.addEventListener('click', ()=>{ prestepState.index = Math.max(0, prestepState.index - 1); renderPrestepOverlay(); });
      if (prestepNext) prestepNext.addEventListener('click', async ()=>{
        const last = prestepState.index >= (prestepState.pages.length - 1);
        if (last){
          closePrestepOverlay();
          goToStep(2);
          // Show the design-check popup on top of Step 2 (so Step 2 is visible behind it)
          try { await showProceedToKravPopup(); } catch(_) {}
          return;
        }
        prestepState.index = Math.min(prestepState.pages.length - 1, prestepState.index + 1);
        renderPrestepOverlay();
      });
      if (prestepSkip) prestepSkip.addEventListener('click', async ()=>{
        closePrestepOverlay();
        goToStep(2);
        try { await showProceedToKravPopup(); } catch(_) {}
      });

      const btnNext2 = document.getElementById('btn-continue-step2');
      if (btnNext2) btnNext2.addEventListener('click', async ()=>{
        try {
          await openBilagOverlay();
        } catch (_) {
          // Fallback: proceed without bilag inputs
          goToStep(3);
        }
      });

      const back2 = document.getElementById('btn-back-step2');
      if (back2) back2.addEventListener('click', ()=>{ goToStep(1); });

      const back3 = document.getElementById('btn-back-step3');
      if (back3) back3.addEventListener('click', ()=>{ goToStep(2); });

      const continue3 = document.getElementById('btn-continue-step3');
      if (continue3) continue3.addEventListener('click', ()=>{ goToStep(4); });
      
      const continue3Top = document.getElementById('btn-continue-step3-top');
      if (continue3Top) continue3Top.addEventListener('click', ()=>{ goToStep(4); });

      const back4 = document.getElementById('btn-back-step4');
      if (back4) back4.addEventListener('click', ()=>{ goToStep(3); });

      const exportPdf = document.getElementById('btn-export-pdf');
      if (exportPdf) exportPdf.addEventListener('click', ()=>{ 
        alert('PDF eksport kommer snart!'); 
      });

      const exportJson = document.getElementById('btn-export-json');
      if (exportJson) exportJson.addEventListener('click', ()=>{ 
        const data = {
          version: '1.0',
          exportedAt: new Date().toISOString(),
          buildings: {
            count: buildingsState.count,
            titles: buildingsState.titles,
            buildings: buildingsState.buildings,
            lastActiveSection: buildingsState.lastActiveSection
          }
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'brandklassificering_export.json';
        a.click();
        URL.revokeObjectURL(url);
      });

      const newProject = document.getElementById('btn-new-project');
      if (newProject) newProject.addEventListener('click', ()=>{ 
        if (confirm('Er du sikker på at du vil starte et nyt projekt? Al data går tabt.')) {
          location.reload();
        }
      });

      // Documentation generator overlay wiring
      document.addEventListener('click', (e) => {
        if (e.target && e.target.id === 'btn-open-doc-generator') {
          openDocGeneratorOverlay();
        }
      });
      
      const docGenOverlay = document.getElementById('doc-generator-overlay');
      const docGenClose = document.getElementById('doc-gen-close');
      const docGenCancel = document.getElementById('doc-gen-cancel');
      const docGenExportPdf = document.getElementById('doc-gen-export-pdf');
      const docGenExportHtml = document.getElementById('doc-gen-export-html');
      const docGenExportDocx = document.getElementById('doc-gen-export-docx');
      const docGenGenerate = document.getElementById('doc-gen-generate');
      
      if (docGenOverlay) {
        docGenOverlay.addEventListener('click', (e) => {
          if (e.target === docGenOverlay) closeDocGeneratorOverlay();
        });
      }
      if (docGenClose) docGenClose.addEventListener('click', closeDocGeneratorOverlay);
      if (docGenCancel) docGenCancel.addEventListener('click', closeDocGeneratorOverlay);
      if (docGenExportPdf) docGenExportPdf.addEventListener('click', async () => {
        try { await exportDocOverlayAsPdf(); }
        catch (e) { console.error(e); alert('Kunne ikke lave PDF. Tjek Console (F12) for fejl.'); }
      });
      if (docGenExportHtml) docGenExportHtml.addEventListener('click', async () => {
        try { await exportDocOverlayAsHtml(); }
        catch (e) { console.error(e); alert('Kunne ikke lave Print. Tjek Console (F12) for fejl.'); }
      });
      if (docGenExportDocx) docGenExportDocx.addEventListener('click', async () => {
        try { await exportDocOverlayAsDocx(); }
        catch (e) { console.error(e); alert('Kunne ikke lave Word (DOCX). Tjek Console (F12) for fejl.'); }
      });
      if (docGenGenerate) docGenGenerate.addEventListener('click', generateDocumentFromOverlay);

      populateBygningstypeOptions();
      initializeEmptyForm();
      updateStatus();

      // Bilag overlay wiring
      const bilagOverlay = document.getElementById('bilag-overlay');
      const bilagClose = document.getElementById('bilag-close');
      const bilagSave = document.getElementById('bilag-save');
      if (bilagOverlay){
        bilagOverlay.addEventListener('click', (e)=>{ if (e.target === bilagOverlay) closeBilagOverlay(); });
      }
      if (bilagClose) bilagClose.addEventListener('click', ()=> closeBilagOverlay());
      if (bilagSave) bilagSave.addEventListener('click', ()=>{
        try { saveBilagAnswers(); } catch(_) {}
        closeBilagOverlay();
        goToStep(3);
      });

      // Brandklasse inputs now live on Step 1; keep extras in sync
      const areaTotalEl = document.getElementById('fld_area_total');
      const tilbygEl = document.getElementById('fld_med_tilbygning');
      const erhvEl = document.getElementById('fld_med_erhvervssammenbygning');

      const syncBrandklasseExtras = () => {
        if (tilbygEl && (tilbygEl.value === 'true' || tilbygEl.value === 'false')) {
          setActiveBilagExtra('med_tilbygning', tilbygEl.value === 'true');
        }
        if (erhvEl && (erhvEl.value === 'true' || erhvEl.value === 'false')) {
          setActiveBilagExtra('med_erhvervssammenbygning', erhvEl.value === 'true');
        }
        // Keep JSON pane in sync when user isn't editing JSON manually
        try {
          if (!syncingFromJson && !jsonManualEdit) {
            const merged = { ...canonicalizeInputData(buildJsonFromForm()), ...getActiveBilagExtras() };
            if (merged.med_tilbygning === undefined) merged.med_tilbygning = null;
            if (merged.med_erhvervssammenbygning === undefined) merged.med_erhvervssammenbygning = null;
            jsonTextarea.value = JSON.stringify(merged, null, 2);
          }
        } catch(_) {}
      };

      const onBrandklasseInput = ()=>{
        syncBrandklasseExtras();
        scheduleBrandklasseEvaluate();
      };
      if (areaTotalEl) areaTotalEl.addEventListener('input', onBrandklasseInput);
      if (tilbygEl) tilbygEl.addEventListener('change', onBrandklasseInput);
      if (erhvEl) erhvEl.addEventListener('change', onBrandklasseInput);
      // Attach auto-evaluate triggers
      document.querySelectorAll('.left-panel .form-field input, .left-panel .form-field select').forEach(el => {
        const onFormEdit = ()=>{
          // Når brugeren retter i formularen, er formularen "source of truth"
          jsonManualEdit = false;
          // Auto-calculate brandklasse from Step 1 when total area is present.
          try {
            if (currentStep === 1 && asNum('fld_area_total') !== null) {
              scheduleBrandklasseEvaluate();
            }
          } catch(_) {}
          scheduleEvaluate();
        };
        el.addEventListener('input', onFormEdit);
        el.addEventListener('change', onFormEdit);
      });
      let jsonSyncTimer = null;
      jsonTextarea.addEventListener('input', ()=>{ 
        // Når brugeren retter i JSON, er JSON "source of truth"
        jsonManualEdit = true;
        if (jsonSyncTimer) clearTimeout(jsonSyncTimer);
        jsonSyncTimer = setTimeout(()=>{
          try {
            const obj = JSON.parse(jsonTextarea.value);
            syncingFromJson = true;
            updateFormFromJson(obj);
          } catch(_) {
            // keep form as-is if JSON invalid
          } finally {
            syncingFromJson = false;
          }
          updateStatus();
          scheduleEvaluate();
        }, 250);
      });
      
      // Initialize buildings + sections (start with 1 building containing 1 section)
      try { setActiveBuildingIndex(0); } catch(_) {
        // Fallback to legacy init
        renderSectionTabs();
        setActiveSectionIndex(0);
      }

      // Load validation data on page load
      loadValidation();

      // No initial evaluation on page load; evaluate when user edits or loads an example.
    });
  </script>

  <!-- Validation Modal -->
  <div id="validation-modal" class="validation-modal">
    <div class="validation-content">
      <div class="validation-header">
        <h2>🔍 Brandrådgiver Validering</h2>
        <button id="close-validation" style="background: none; border: none; font-size: 28px; cursor: pointer; color: var(--c-text-muted);">×</button>
      </div>
      <div class="validation-tabs">
        <button class="validation-tab active" data-tab="anvendelseskategori">Anvendelseskategori</button>
        <button class="validation-tab" data-tab="risikoklasse">Risikoklasse</button>
        <button class="validation-tab" data-tab="relevant-bilag">Relevant Bilag</button>
        <button class="validation-tab" data-tab="brandklasse">Brandklasse</button>
        <button class="validation-tab" data-tab="krav">Krav</button>
      </div>
      <div class="validation-body">
        <div id="validation-anvendelseskategori" class="validation-section active">
          <!-- Anvendelseskategori tables -->
        </div>
        <div id="validation-risikoklasse" class="validation-section">
          <!-- Risikoklasse tables -->
        </div>
        <div id="validation-relevant-bilag" class="validation-section">
          <!-- Relevant bilag tables -->
        </div>
        <div id="validation-brandklasse" class="validation-section">
          <!-- Brandklasse tables -->
        </div>
        <div id="validation-krav" class="validation-section">
          <!-- Krav content will be inserted here -->
        </div>
      </div>
      <div class="validation-footer">
        <button id="validate-all" class="btn-secondary" style="background:var(--c-accent); color:var(--c-on-primary); border:none;">Valider Alt</button>
        <button id="import-validation" class="btn-secondary">Importér Validering</button>
        <button id="export-validation" class="btn-primary">Eksportér Validering</button>
      </div>
    </div>
  </div>

  <script>
    // Validation system
    let validationData = {
      version: "1.0",
      lastUpdated: "",
      validatedBy: "",
      decisionTables: {},
      krav: {}
    };

    // Krav validation helpers
    // Supports both granular schema (beskrivelse/tjekliste/dimensionering) and legacy/summary flag (validated).
    function kravIsFullyValidated(kravValidation) {
      return !!(kravValidation && kravValidation.validated === true);
    }
    function kravBeskrivelseValidated(kravValidation) {
      return kravIsFullyValidated(kravValidation) || !!(kravValidation && kravValidation.beskrivelse);
    }
    function kravDimensioneringValidated(kravValidation) {
      return kravIsFullyValidated(kravValidation) || !!(kravValidation && kravValidation.dimensionering);
    }
    function kravChecklistItemValidated(kravValidation, idx) {
      if (kravIsFullyValidated(kravValidation)) return true;
      if (!kravValidation || !kravValidation.tjekliste || typeof kravValidation.tjekliste !== 'object') return false;
      return !!kravValidation.tjekliste[idx];
    }

    function _normalizeChecklistText(text) {
      let s = String(text ?? '').trim();
      if (!s) return '';
      s = s.replace(/\r\n/g, '\n');
      s = s.replace(/[–—]/g, '-');
      // Remove common bullet/numbering prefixes so Step 3 bullets and modal bullets hash the same.
      // Examples: "- foo", "• foo", "1) foo", "1. foo"
      s = s.replace(/^\s*(?:[-•*]|\u2022)\s+/u, '');
      s = s.replace(/^\s*\d+\s*[\).:]\s+/u, '');
      // Remove wrapping quotes if present
      s = s.replace(/^"+|"+$/g, '');
      s = s.replace(/\s+/g, ' ');
      return s.toLowerCase();
    }

    function parseChecklistItemsForValidation(raw) {
      // Mirrors the Step 3 parsing logic (parseChecklistItems) so the modal and Step 3
      // agree on what constitutes a checklist "item".
      let s = String(raw ?? '').trim();
      if (!s) return [];

      // Decode common double-escaped sequences (when the model contains "\\n" literally)
      s = s
        .replace(/\\r\\n/g, '\n')
        .replace(/\\n/g, '\n')
        .replace(/\\r/g, '\n')
        .replace(/\\t/g, '\t')
        .replace(/\\"/g, '"')
        .replace(/\\\\/g, '\\');

      const text = s.replace(/\r\n/g, '\n').trim();
      if (!text) return [];

      // First try: double-newline delimiter (\n\n)
      if (/\n\s*\n/.test(text)) {
        return text
          .split(/\n\s*\n/)
          .map(x => x.trim())
          .filter(Boolean);
      }

      // Fallback: Bullet-per-line with dash
      if (/\n\s*-\s+/.test(text)) {
        return text
          .split(/\n+/)
          .map(l => l.trim())
          .filter(Boolean)
          .map(l => l.replace(/^\s*-\s*/, '').trim())
          .filter(Boolean);
      }

      // Single item (but also split on explicit " - " if user wrote multiple in one line)
      const one = text.trim();
      if (!one) return [];
      if (/\s-\s/.test(one) && !/^\s*-\s/.test(one)) {
        const parts = one.split(/\s-\s/).map(x => x.trim()).filter(Boolean);
        return parts.length ? parts : [one];
      }
      return [one];
    }

    // Simple stable hash (FNV-1a 32-bit) for checklist keying
    function _fnv1a32(str) {
      let h = 0x811c9dc5;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        // h *= 16777619 (with overflow)
        h = (h + ((h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24))) >>> 0;
      }
      return h >>> 0;
    }

    function makeChecklistValidationKey(itemText) {
      const n = _normalizeChecklistText(itemText);
      if (!n) return '';
      return `h_${_fnv1a32(n).toString(16).padStart(8, '0')}`;
    }

    function kravChecklistTextValidated(kravValidation, itemText, fallbackIdx = null) {
      if (kravIsFullyValidated(kravValidation)) return true;
      if (!kravValidation || !kravValidation.tjekliste || typeof kravValidation.tjekliste !== 'object') return false;
      const key = makeChecklistValidationKey(itemText);
      if (key && kravValidation.tjekliste[key] !== undefined) return !!kravValidation.tjekliste[key];
      if (fallbackIdx !== null && fallbackIdx !== undefined) {
        const k = String(fallbackIdx);
        if (kravValidation.tjekliste[k] !== undefined) return !!kravValidation.tjekliste[k];
        // also allow numeric indexing access
        if (kravValidation.tjekliste[fallbackIdx] !== undefined) return !!kravValidation.tjekliste[fallbackIdx];
      }
      return false;
    }

    let _kravValidationIndex = null;
    function normalizeKravId(kravId) {
      let s = String(kravId ?? '').trim().toUpperCase();
      if (!s) return '';
      // Some model values come through as quoted strings, e.g. "\"K-01-17\"".
      // Strip quotes so lookups match validationData keys.
      s = s.replace(/^"+|"+$/g, '');
      s = s.replace(/"/g, '');
      s = s.replace(/[–—]/g, '-');
      s = s.replace(/\s+/g, '');
      // Canonicalize common pattern: K-<section>-<no>
      const m = s.match(/^K-(\d+(?:\.\d+)*?)-(\d+)$/);
      if (m) {
        const sectionRaw = m[1];
        const noRaw = m[2];
        const sectionParts = sectionRaw.split('.');
        const sectionFirst = sectionParts[0].padStart(2, '0');
        const sectionRest = sectionParts.length > 1 ? sectionParts.slice(1).join('.') : '';
        const section = sectionRest ? `${sectionFirst}.${sectionRest}` : sectionFirst;
        const no = noRaw.padStart(2, '0');
        return `K-${section}-${no}`;
      }
      return s;
    }

    function invalidateKravValidationIndex() {
      _kravValidationIndex = null;
    }

    function ensureKravValidationIndex() {
      if (_kravValidationIndex) return _kravValidationIndex;
      const idx = {};
      try {
        const krav = (validationData && validationData.krav && typeof validationData.krav === 'object') ? validationData.krav : {};
        for (const key of Object.keys(krav)) {
          const norm = normalizeKravId(key);
          if (norm && idx[norm] === undefined) idx[norm] = key;
        }
      } catch (_) {}
      _kravValidationIndex = idx;
      return idx;
    }

    function getKravValidationRecord(kravId) {
      const empty = {};
      try {
        const krav = validationData?.krav;
        if (!krav || typeof krav !== 'object') return empty;
        if (kravId && krav[kravId]) return krav[kravId];
        const norm = normalizeKravId(kravId);
        if (norm && krav[norm]) return krav[norm];
        const map = ensureKravValidationIndex();
        const resolvedKey = norm ? map[norm] : undefined;
        if (resolvedKey && krav[resolvedKey]) return krav[resolvedKey];
      } catch (_) {}
      return empty;
    }

    function resolveKravValidationKey(kravId) {
      // Returns the actual key used in validationData.krav for this kravId (if any).
      // This prevents creating duplicate/unfindable keys when the model contains quoted/newline variants.
      try {
        const krav = validationData?.krav;
        if (!krav || typeof krav !== 'object') return String(kravId ?? '');
        const raw = String(kravId ?? '');
        if (raw && krav[raw]) return raw;
        const norm = normalizeKravId(raw);
        if (norm && krav[norm]) return norm;
        const map = ensureKravValidationIndex();
        const resolvedKey = norm ? map[norm] : undefined;
        if (resolvedKey && krav[resolvedKey]) return resolvedKey;
        return norm || raw;
      } catch (_) {
        return String(kravId ?? '');
      }
    }

    async function validateAllKravFromKravJson() {
      // Model-driven validation: validates ALL krav rules from Krav.json regardless of UI rendering/filtering.
      const resp = await fetch(`${API_BASE}/Krav.json?v=${Date.now()}`, { cache: 'no-store' });
      if (!resp.ok) throw new Error('Kunne ikke indlæse Krav.json');
      const kravData = await resp.json();

      const nodes = Array.isArray(kravData?.nodes) ? kravData.nodes : [];
      const decisionNode = nodes.find(n => n?.type === 'decisionTableNode' && /designkrav/i.test(String(n?.name || '')))
        || nodes.find(n => n?.type === 'decisionTableNode');
      if (!decisionNode?.content?.rules || !Array.isArray(decisionNode.content.rules)) {
        throw new Error('Kunne ikke finde decision table regler i Krav.json');
      }

      const inputs = Array.isArray(decisionNode.content.inputs) ? decisionNode.content.inputs : [];
      const outputs = Array.isArray(decisionNode.content.outputs) ? decisionNode.content.outputs : [];

      const outputsMap = {};
      outputs.forEach(o => {
        if (o && typeof o === 'object' && o.field && o.id) outputsMap[o.field] = o.id;
      });

      const cleanModelString = (value) => {
        if (value === null || value === undefined) return value;
        if (typeof value !== 'string') return value;
        let s = value.trim();
        if (s.length >= 2 && s.startsWith('"') && s.endsWith('"')) s = s.slice(1, -1);
        return s;
      };
      const pick = (obj, keys) => {
        for (const k of keys) {
          const v = obj?.[k];
          if (v !== null && v !== undefined && String(v).trim() !== '') return v;
        }
        return '';
      };

      const checklistOffsetByKravKey = {};

      decisionNode.content.rules.forEach((rule, idx) => {
        const out = {};
        Object.keys(outputsMap).forEach(field => {
          const oid = outputsMap[field];
          out[field] = cleanModelString(rule?.[oid]);
        });

        const rawKravId = pick(out, ['Krav_id']) || `krav_${idx + 1}`;
        const cleanedKravId = cleanModelString(rawKravId);
        const canonicalKravId = normalizeKravId(cleanedKravId || rawKravId) || String(cleanedKravId || rawKravId).trim();
        const key = resolveKravValidationKey(canonicalKravId || rawKravId);

        if (!validationData.krav[key]) {
          validationData.krav[key] = { beskrivelse: false, tjekliste: {}, dimensionering: false, comment: '' };
        }
        const rec = validationData.krav[key];
        rec.validated = true;

        // Preserve granular fields too (useful for tooling/exports)
        const beskrivelse = pick(out, ['Krav_Beskrivelse']);
        const dim = pick(out, ['Krav_Korrekt_Dimensionering']);
        if (beskrivelse) rec.beskrivelse = true;
        if (dim) rec.dimensionering = true;

        const tjeklisteRaw = pick(out, ['Krav_Tjekliste']);
        const items = tjeklisteRaw ? parseChecklistItemsForValidation(tjeklisteRaw) : [];
        if (items.length) {
          if (!rec.tjekliste || typeof rec.tjekliste !== 'object') rec.tjekliste = {};
          const offset = Number(checklistOffsetByKravKey[key] || 0) || 0;
          for (let i = 0; i < items.length; i++) {
            const item = items[i];
            const hashKey = makeChecklistValidationKey(item);
            if (hashKey) rec.tjekliste[hashKey] = true;
            rec.tjekliste[String(offset + i)] = true;
          }
          checklistOffsetByKravKey[key] = offset + items.length;
        }
      });

      // Ensure subsequent lookups see any newly created keys
      invalidateKravValidationIndex();
    }

    // Load existing validation if available
    async function loadValidation() {
      try {
        console.log('[Validation] Loading validation.json...');
        const resp = await fetch('validation/validation.json?v=' + Date.now(), { cache: 'no-store' });
        if (resp.ok) {
          const data = await resp.json();
          validationData = data;
          invalidateKravValidationIndex();
          console.log('[Validation] Successfully loaded validation data:', validationData);
          updateValidationStatus();
          return true;
        } else {
          console.log('[Validation] Failed to load validation.json, status:', resp.status);
        }
      } catch(e) {
        console.log('[Validation] Error loading validation data:', e.message);
      }
      return false;
    }

    // Update validation status display
    function updateValidationStatus() {
      // Count validated items
      const validatedDT = Object.values(validationData.decisionTables || {}).filter(v => v.validated).length;
      const totalDT = Object.keys(validationData.decisionTables || {}).length;
      
      // Count krav with granular validation
      let fullyValidatedKrav = 0;
      let partiallyValidatedKrav = 0;
      const totalKrav = Object.keys(validationData.krav || {}).length;
      
      Object.values(validationData.krav || {}).forEach(krav => {
        let validatedCount = 0;
        let totalCount = 0;
        
        if (krav.beskrivelse !== undefined) {
          totalCount++;
          if (krav.beskrivelse) validatedCount++;
        }
        if (krav.tjekliste && typeof krav.tjekliste === 'object') {
          const tlist = Object.keys(krav.tjekliste);
          totalCount += tlist.length;
          validatedCount += tlist.filter(k => krav.tjekliste[k]).length;
        }
        if (krav.dimensionering !== undefined) {
          totalCount++;
          if (krav.dimensionering) validatedCount++;
        }
        
        if (totalCount > 0 && validatedCount === totalCount) {
          fullyValidatedKrav++;
        } else if (validatedCount > 0) {
          partiallyValidatedKrav++;
        }
      });
      
      console.log(`Validation status: DT ${validatedDT}/${totalDT}, Krav ${fullyValidatedKrav} fuldt, ${partiallyValidatedKrav} delvist af ${totalKrav} total`);
      
      // NEVER show the topbar badge - it should always be hidden
      const badge = document.getElementById('validation-status-badge');
      if (badge) {
        badge.style.display = 'none';
      }
    }

    // Open validation modal
    document.getElementById('validation-btn').addEventListener('click', async () => {
      await loadValidation();
      await renderValidationContent();
      document.getElementById('validation-modal').classList.add('show');
    });

    // Close validation modal
    document.getElementById('close-validation').addEventListener('click', () => {
      document.getElementById('validation-modal').classList.remove('show');
    });

    // Tab switching
    document.querySelectorAll('.validation-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        const targetTab = tab.dataset.tab;
        document.querySelectorAll('.validation-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.validation-section').forEach(s => s.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(`validation-${targetTab}`).classList.add('active');
      });
    });

    // Render validation content
    async function renderValidationContent() {
      await renderDecisionTables();
      await renderKravValidation();
    }

    async function validateAllRenderedItems() {
      try {
        // Always validate based on the model first, so even non-rendered/oddly-keyed krav are covered.
        try {
          await validateAllKravFromKravJson();
        } catch (e) {
          console.warn('[Validation] validateAllKravFromKravJson failed (continuing with rendered items):', e);
        }

        // If Krav is currently filtered by bilag, temporarily render ALL krav
        // so the action truly validates everything.
        let previousKravBilagFilter = null;
        try {
          const filterEl = document.querySelector('#validation-krav #bilag-filter');
          if (filterEl) previousKravBilagFilter = String(filterEl.value || '');
          if (previousKravBilagFilter) {
            await renderKravValidation(null);
          }
        } catch (_) {
          // If rendering fails, continue with whatever is on screen.
        }

        const dtCheckboxes = Array.from(document.querySelectorAll('#validation-modal input[type="checkbox"][id^="dt_"]'));
        const kravCheckboxes = Array.from(document.querySelectorAll('#validation-modal .validation-item-checkbox'));

        let kravTotalChecked = 0;

        dtCheckboxes.forEach(cb => {
          cb.checked = true;
          const id = String(cb.id || '').replace(/^dt_/, '');
          if (!id) return;
          if (!validationData.decisionTables[id]) validationData.decisionTables[id] = {};
          validationData.decisionTables[id].validated = true;
        });

        kravCheckboxes.forEach(cb => {
          cb.checked = true;
          const key = resolveKravValidationKey(cb.dataset.key);
          const type = cb.dataset.type;
          const index = cb.dataset.index;
          const fallbackIndex = cb.dataset.fallbackIndex;
          if (!key || !type) return;
          if (!validationData.krav[key]) {
            validationData.krav[key] = { beskrivelse: false, tjekliste: {}, dimensionering: false, comment: '' };
          }
          // Mark the whole krav as validated (used as an override elsewhere)
          validationData.krav[key].validated = true;
          if (type === 'beskrivelse') {
            validationData.krav[key].beskrivelse = true;
            kravTotalChecked++;
          } else if (type === 'dimensionering') {
            validationData.krav[key].dimensionering = true;
            kravTotalChecked++;
          } else if (type === 'tjekliste') {
            if (!validationData.krav[key].tjekliste) validationData.krav[key].tjekliste = {};
            validationData.krav[key].tjekliste[index] = true;
            if (fallbackIndex !== undefined && fallbackIndex !== null && String(fallbackIndex).trim() !== '') {
              validationData.krav[key].tjekliste[String(fallbackIndex)] = true;
            }
            kravTotalChecked++;
          }
        });

        // Update metadata (used on export, but nice to keep current)
        const today = new Date().toISOString().split('T')[0];
        validationData.lastUpdated = today;

        // Important: index cache must reflect any new keys written by "Valider Alt".
        invalidateKravValidationIndex();

        updateValidationStatus();

        // Restore previous krav filter view (optional)
        try {
          if (previousKravBilagFilter) {
            await renderKravValidation(previousKravBilagFilter);
          }
        } catch (_) {}

        alert(
          '✅ Valideret!\n\n' +
          `• Decision tables: ${dtCheckboxes.length} regler markeret\n` +
          `• Krav: ${kravTotalChecked} punkter markeret\n\n` +
          'Husk: Eksportér validering hvis du vil gemme den som fil.'
        );
      } catch (e) {
        console.error('[Validation] validateAllRenderedItems failed:', e);
        alert('Kunne ikke validerer alt. Tjek Console (F12) for fejl.');
      }
    }

    // Validate all (one-click)
    const validateAllBtn = document.getElementById('validate-all');
    if (validateAllBtn) {
      validateAllBtn.addEventListener('click', async () => {
        validateAllBtn.disabled = true;
        validateAllBtn.style.opacity = '0.75';
        try { await validateAllRenderedItems(); }
        finally {
          validateAllBtn.disabled = false;
          validateAllBtn.style.opacity = '';
        }
      });
    }

    // Render decision tables from Brandklasse_Bestemmelse.json
    async function renderDecisionTables() {
      try {
        const resp = await fetch(`${API_BASE}/Brandklasse_Bestemmelse.json?v=${Date.now()}`, { cache: 'no-store' });
        const data = await resp.json();
        
        const tables = data.nodes.filter(n => n.type === 'decisionTableNode');
        
        // Categorize tables by type
        const tablesByType = {
          anvendelseskategori: tables.filter(t => t.name?.toLowerCase().includes('anvendelseskategori')),
          risikoklasse: tables.filter(t => t.name?.toLowerCase().includes('risikoklasse')),
          'relevant-bilag': tables.filter(t => t.name?.toLowerCase().includes('bilag') && !t.name?.toLowerCase().includes('brand')),
          brandklasse: tables.filter(t => t.name?.toLowerCase().includes('præ-accepterede') || t.name?.toLowerCase().includes('brandklasse'))
        };
        
        // Render each category
        for (const [type, typeTables] of Object.entries(tablesByType)) {
          const container = document.getElementById(`validation-${type}`);
          if (!container) continue;
          
          if (typeTables.length === 0) {
            container.innerHTML = '<p class="muted" style="padding:20px;">Ingen decision tables fundet for denne kategori.</p>';
            continue;
          }
          
          let html = '';
          
          for (const table of typeTables) {
            const tableName = escapeHtml(table.name || 'Unavngivet tabel');
            html += `<div class="validation-item">`;
            html += `<div style="font-size: 18px; font-weight: 700; margin-bottom: 16px; color: var(--c-text);">${tableName}</div>`;
            
            if (table.content && table.content.rules) {
              table.content.rules.forEach((rule, idx) => {
                const ruleId = `${table.id}_rule_${idx}`;
                const isValidated = validationData.decisionTables[ruleId]?.validated || false;
                const comment = validationData.decisionTables[ruleId]?.comment || '';
                
                html += `<div class="decision-rule">`;
                html += `<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">`;
                html += `<div style="font-weight:600;">Regel ${idx + 1}</div>`;
                html += `<div class="validation-checkbox">`;
                html += `<input type="checkbox" id="dt_${ruleId}" ${isValidated ? 'checked' : ''}>`;
                html += `<label for="dt_${ruleId}">Valideret</label>`;
                html += `</div>`;
                html += `</div>`;
                
                if (rule._description) {
                  html += `<div style="margin-bottom:8px; color:var(--c-text); font-size:13px;">${escapeHtml(rule._description)}</div>`;
                }
                
                // Show conditions (only input columns, not outputs)
                const conditions = [];
                const outputIds = table.content.outputs?.map(o => o.id) || [];
                for (const [key, value] of Object.entries(rule)) {
                  if (!key.startsWith('_') && value && value !== '' && !outputIds.includes(key)) {
                    const col = table.content.inputs?.find(i => i.id === key);
                    const colName = col?.name || key.substring(0, 8);
                    conditions.push(`<div class="rule-condition"><strong>${escapeHtml(colName)}:</strong> ${escapeHtml(value)}</div>`);
                  }
                }
                
                if (conditions.length > 0) {
                  html += `<div class="rule-conditions">${conditions.join('')}</div>`;
                }
                
                // Show result
                const outputKeys = Object.keys(rule).filter(k => !k.startsWith('_') && table.content.outputs?.some(o => o.id === k));
                if (outputKeys.length > 0) {
                  const output = table.content.outputs.find(o => o.id === outputKeys[0]);
                  const outputName = output?.name || 'Resultat';
                  html += `<div class="rule-result"><strong>${escapeHtml(outputName)}:</strong> ${escapeHtml(rule[outputKeys[0]])}</div>`;
                }
                
                html += `<textarea class="validation-comment" placeholder="Tilføj kommentarer..." data-id="dt_${ruleId}">${escapeHtml(comment)}</textarea>`;
                html += `</div>`;
              });
            }
            
            html += `</div>`;
          }
          
          container.innerHTML = html;
          
          // Add event listeners
          container.querySelectorAll('input[type="checkbox"]').forEach(cb => {
            cb.addEventListener('change', (e) => {
              const id = e.target.id.replace('dt_', '');
              if (!validationData.decisionTables[id]) validationData.decisionTables[id] = {};
              validationData.decisionTables[id].validated = e.target.checked;
            });
          });
          
          container.querySelectorAll('textarea').forEach(ta => {
            ta.addEventListener('change', (e) => {
              const id = e.target.dataset.id.replace('dt_', '');
              if (!validationData.decisionTables[id]) validationData.decisionTables[id] = {};
              validationData.decisionTables[id].comment = e.target.value;
            });
          });
        }
        
      } catch(e) {
        console.error('[Validation] Error rendering decision tables:', e);
      }
    }

    // Render krav validation
    async function renderKravValidation(selectedBilag = null) {
      const container = document.getElementById('validation-krav');
      container.innerHTML = '<div style="text-align:center; padding:20px;">Indlæser krav...</div>';
      
      try {
        const resp = await fetch(`${API_BASE}/Krav.json?v=${Date.now()}`, { cache: 'no-store' });
        if (!resp.ok) throw new Error('Kunne ikke indlæse Krav.json');
        const kravData = await resp.json();

        let html = '<h3 style="margin-top:0;">Krav</h3>';
        const esc = (s) => {
          const str = String(s ?? '');
          return str
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
        };
        const escWithNewlines = (s) => {
          const escaped = esc(s);
          return escaped.replace(/\\n/g, '\n');
        };
        const fmtVal = (v) => {
          if (v === null || v === undefined) return '';
          if (Array.isArray(v)) return v.map(x => String(x)).join('\n');
          if (typeof v === 'object') {
            try { return JSON.stringify(v, null, 2); } catch(_) { return String(v); }
          }
          return String(v);
        };
        const cleanModelString = (value) => {
          if (value === null || value === undefined) return value;
          if (typeof value !== 'string') return value;
          let s = value.trim();
          if (s.length >= 2 && s.startsWith('"') && s.endsWith('"')) s = s.slice(1, -1);
          return s;
        };
        const pick = (obj, keys) => {
          for (const k of keys) {
            const v = obj?.[k];
            if (v !== null && v !== undefined && String(v).trim() !== '') return v;
          }
          return '';
        };
        const makeDomSafe = (s) => String(s ?? '').replace(/[^a-zA-Z0-9_-]/g, '_');

        const nodes = Array.isArray(kravData?.nodes) ? kravData.nodes : [];
        const decisionNode = nodes.find(n => n?.type === 'decisionTableNode' && /designkrav/i.test(String(n?.name || '')))
          || nodes.find(n => n?.type === 'decisionTableNode');
        if (!decisionNode?.content?.rules || !Array.isArray(decisionNode.content.rules)) {
          container.innerHTML = html + '<div style="color:var(--c-primary); padding:20px;">Kunne ikke finde decision table regler i Krav.json</div>';
          return;
        }

        const inputs = Array.isArray(decisionNode.content.inputs) ? decisionNode.content.inputs : [];
        const outputs = Array.isArray(decisionNode.content.outputs) ? decisionNode.content.outputs : [];
        
        const inputsMap = {};
        inputs.forEach(i => {
          if (i && typeof i === 'object' && i.field && i.id) inputsMap[i.field] = i.id;
        });
        
        const outputsMap = {};
        outputs.forEach(o => {
          if (o && typeof o === 'object' && o.field && o.id) outputsMap[o.field] = o.id;
        });

        // Collect all unique bilag values from INPUT field
        const bilagInputId = inputsMap['Relevant_bilag'];
        console.log('[Krav Validation] Relevant_bilag INPUT ID:', bilagInputId);
        
        const bilagSet = new Set();
        decisionNode.content.rules.forEach((rule, idx) => {
          const bilagVal = rule?.[bilagInputId];
          if (idx < 3) console.log(`[Krav Validation] Rule ${idx} bilagVal:`, bilagVal, typeof bilagVal);
          if (bilagVal !== null && bilagVal !== undefined && bilagVal !== '') {
            const strVal = String(bilagVal).trim();
            if (strVal) bilagSet.add(strVal);
          }
        });
        
        const allBilag = Array.from(bilagSet).sort((a, b) => {
          const numA = parseFloat(a) || 0;
          const numB = parseFloat(b) || 0;
          return numA - numB;
        });
        
        console.log('[Krav Validation] Found bilag values:', allBilag);

        // Add bilag filter dropdown
        html += `<div style="margin:10px 0 16px;">`;
        html += `<label for="bilag-filter" style="font-weight:600; margin-right:8px;">Filtrér efter bilag:</label>`;
        html += `<select id="bilag-filter" style="padding:6px 12px; border:1px solid #d1d5db; border-radius:6px; font-size:14px;">`;
        html += `<option value="">Alle bilag</option>`;
        allBilag.forEach(b => {
          const sel = selectedBilag === b ? ' selected' : '';
          html += `<option value="${esc(b)}"${sel}>Bilag ${esc(formatBilagDisplayId(b))}</option>`;
        });
        html += `</select>`;
        html += `</div>`;

        // Filter rules based on selected bilag
        const filteredRules = selectedBilag
          ? decisionNode.content.rules.filter(rule => {
              const bilagVal = rule?.[bilagInputId];
              return bilagVal !== null && bilagVal !== undefined && String(bilagVal).trim() === selectedBilag;
            })
          : decisionNode.content.rules;

        const totalRules = decisionNode.content.rules.length;
        const filteredCount = filteredRules.length;
        
        if (selectedBilag) {
          html += `<div class="muted" style="margin:10px 0 16px;">Viser <strong>${esc(String(filteredCount))}</strong> regler for bilag ${esc(formatBilagDisplayId(selectedBilag))} &nbsp;•&nbsp; <strong>${esc(String(totalRules))}</strong> regler i alt</div>`;
        } else {
          html += `<div class="muted" style="margin:10px 0 16px;"><strong>${esc(String(totalRules))}</strong> regler i Krav.json</div>`;
        }

        // Track running checklist index per kravId so indices are stable and don't overwrite
        // when the same kravId appears multiple times.
        const checklistOffsetByKravId = {};

        filteredRules.forEach((rule, origIdx) => {
          const idx = decisionNode.content.rules.indexOf(rule);
          const ruleId = `${decisionNode.id}_rule_${idx}`;
          const ruleNo = idx + 1;

          const out = {};
          Object.keys(outputsMap).forEach(field => {
            const oid = outputsMap[field];
            out[field] = cleanModelString(rule?.[oid]);
          });
          out._matched_rule_id = ruleId;
          out._matched_rule_number = ruleNo;
          out._matched_node_name = decisionNode?.name || 'Designkrav';

          const rawKravId = pick(out, ['Krav_id']) || `krav_${ruleNo}`;
          const cleanedKravId = cleanModelString(rawKravId);
          const kravId = normalizeKravId(cleanedKravId || rawKravId) || String(cleanedKravId || rawKravId).trim();
          const title = pick(out, ['Krav_Titel']) || 'Krav';
          const type = pick(out, ['Krav_Undertitel']);
          const beskrivelse = pick(out, ['Krav_Beskrivelse']);
          const tjekliste = pick(out, ['Krav_Tjekliste']);
          const dim = pick(out, ['Krav_Korrekt_Dimensionering']);

          const key = resolveKravValidationKey(kravId);
          
          // Initialize validation structure if needed
          if (!validationData.krav[key]) {
            validationData.krav[key] = {
              beskrivelse: false,
              tjekliste: {},
              dimensionering: false,
              comment: ''
            };
          }
          
          const kravValidation = validationData.krav[key];
          const comment = kravValidation.comment || '';

          const offset = Number(checklistOffsetByKravId[key] || 0) || 0;

          const domId = `krav_${makeDomSafe(kravId)}_${ruleNo}`;

          html += `<div class="validation-item">`;
          html += `<div class="validation-item-header">`;
          html += `<div class="validation-item-title">`;
          html += `Krav ${esc(kravId)}: ${esc(title)}`;
          html += `</div>`;
          html += `</div>`;

          if (type) html += `<div style="margin-bottom:8px;"><strong>Undertitel:</strong> ${escWithNewlines(type)}</div>`;
          
          // Beskrivelse with individual validation
          if (beskrivelse) {
            const beskrivelseValidated = kravBeskrivelseValidated(kravValidation);
            html += `<div style="margin-bottom:10px; padding:16px; background:var(--c-surface); border-radius:8px; border:1px solid var(--c-border);">`;
            html += `<div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">`;
            html += `<div style="font-weight:600; color:var(--c-text);">Beskrivelse</div>`;
            html += `<label style="display:flex; align-items:center; justify-content:flex-end; cursor:pointer; width:24px; flex-shrink:0;">`;
            html += `<input type="checkbox" class="validation-item-checkbox" data-key="${esc(key)}" data-type="beskrivelse" ${beskrivelseValidated ? 'checked' : ''} style="width:20px; height:20px; cursor:pointer; accent-color:var(--c-accent); margin:0;">`;
            html += `</label>`;
            html += `</div>`;
            html += `<div style="white-space:pre-wrap; color:var(--c-text-muted); line-height:1.6;">${escWithNewlines(beskrivelse)}</div>`;
            html += `</div>`;
          }
          
          // Tjekliste with individual validation per item
          if (tjekliste) {
            const tlist = parseChecklistItemsForValidation(tjekliste);
            if (tlist.length > 0) {
              html += `<details open style="margin-bottom:10px;">`;
              html += `<summary style="cursor:pointer; font-weight:600; margin-bottom:12px; color:var(--c-text);">Tjekliste (${tlist.length} punkter)</summary>`;
              html += `<div style="background:var(--c-surface); border-radius:8px; border:1px solid var(--c-border); padding:12px;">`;
              tlist.forEach((item, idx) => {
                const globalIdx = offset + idx;
                const itemKey = makeChecklistValidationKey(item);
                const itemValidated = kravChecklistTextValidated(kravValidation, item, globalIdx);
                html += `<div style="display:flex; align-items:center; justify-content:space-between; gap:12px; padding:8px 0; ${idx < tlist.length - 1 ? 'border-bottom:1px solid var(--c-border);' : ''}">`;
                html += `<span style="flex:1; color:var(--c-text-muted); line-height:1.6;">${esc(item)}</span>`;
                html += `<label style="display:flex; align-items:center; justify-content:flex-end; cursor:pointer; width:24px; flex-shrink:0;">`;
                html += `<input type="checkbox" class="validation-item-checkbox" data-key="${esc(key)}" data-type="tjekliste" data-index="${esc(itemKey || String(globalIdx))}" data-fallback-index="${globalIdx}" ${itemValidated ? 'checked' : ''} style="width:20px; height:20px; cursor:pointer; accent-color:var(--c-accent); margin:0;">`;
                html += `</label>`;
                html += `</div>`;
              });
              html += `</div>`;
              html += `</details>`;

              // Advance offset for this kravId so next rule (same key) continues indices
              checklistOffsetByKravId[key] = offset + tlist.length;
            }
          }
          
          // Dimensionering with individual validation
          if (dim) {
            const dimValidated = kravDimensioneringValidated(kravValidation);
            html += `<details open style="margin-bottom:10px;">`;
            html += `<summary style="cursor:pointer; font-weight:600; margin-bottom:12px; color:var(--c-text); display:flex; align-items:center; justify-content:space-between;">`;
            html += `<span>Korrekt dimensionering</span>`;
            html += `<label style="display:flex; align-items:center; justify-content:flex-end; cursor:pointer; width:24px; flex-shrink:0;" onclick="event.stopPropagation();">`;
            html += `<input type="checkbox" class="validation-item-checkbox" data-key="${esc(key)}" data-type="dimensionering" ${dimValidated ? 'checked' : ''} style="width:20px; height:20px; cursor:pointer; accent-color:var(--c-accent); margin:0;">`;
            html += `</label>`;
            html += `</summary>`;
            html += `<div style="padding:16px; background:var(--c-surface); border-radius:8px; border:1px solid var(--c-border);">`;
            html += `<div style="white-space:pre-wrap; color:var(--c-text-muted); line-height:1.6;">${escWithNewlines(dim)}</div>`;
            html += `</div>`;
            html += `</details>`;
          }

          html += `<textarea class="validation-comment" placeholder="Tilføj kommentarer..." data-key="${esc(key)}">${esc(comment)}</textarea>`;
          html += `</div>`;
        });
        
        container.innerHTML = html;
        
        // Add event listener for bilag filter
        const bilagFilterSelect = container.querySelector('#bilag-filter');
        if (bilagFilterSelect) {
          bilagFilterSelect.addEventListener('change', (e) => {
            const selected = e.target.value || null;
            renderKravValidation(selected);
          });
        }
        
        // Add event listeners for individual validation checkboxes
        container.querySelectorAll('.validation-item-checkbox').forEach(checkbox => {
          checkbox.addEventListener('change', (e) => {
            const key = e.target.dataset.key;
            const type = e.target.dataset.type;
            const index = e.target.dataset.index;
            const fallbackIndexRaw = e.target.dataset.fallbackIndex;
            const fallbackIndex = (fallbackIndexRaw !== undefined && fallbackIndexRaw !== null && String(fallbackIndexRaw).trim() !== '')
              ? Number(fallbackIndexRaw)
              : null;
            
            if (!validationData.krav[key]) {
              validationData.krav[key] = {
                beskrivelse: false,
                tjekliste: {},
                dimensionering: false,
                comment: ''
              };
            }
            
            if (type === 'beskrivelse') {
              validationData.krav[key].beskrivelse = e.target.checked;
            } else if (type === 'tjekliste') {
              if (!validationData.krav[key].tjekliste) {
                validationData.krav[key].tjekliste = {};
              }
              validationData.krav[key].tjekliste[index] = e.target.checked;
              if (fallbackIndex !== null && Number.isFinite(fallbackIndex)) {
                validationData.krav[key].tjekliste[String(fallbackIndex)] = e.target.checked;
              }
            } else if (type === 'dimensionering') {
              validationData.krav[key].dimensionering = e.target.checked;
            }
          });
        });
        
        container.querySelectorAll('textarea').forEach(ta => {
          ta.addEventListener('change', (e) => {
            const key = e.target.dataset.key;
            if (!validationData.krav[key]) {
              validationData.krav[key] = {
                beskrivelse: false,
                tjekliste: {},
                dimensionering: false,
                comment: ''
              };
            }
            validationData.krav[key].comment = e.target.value;
          });
        });
        
      } catch(e) {
        container.innerHTML = '<div style="color:var(--c-primary); padding:20px;">Fejl ved indlæsning af krav: ' + e.message + '</div>';
      }
    }

    // Export validation
    document.getElementById('export-validation').addEventListener('click', () => {
      // Update metadata before export
      const today = new Date().toISOString().split('T')[0];
      validationData.version = "1.0";
      validationData.lastUpdated = today;
      if (!validationData.validatedBy) {
        validationData.validatedBy = prompt("Indtast navn på brandrådgiver (valgfrit):") || "";
      }
      
      const dataStr = JSON.stringify(validationData, null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `validation.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      alert('Validering eksporteret! 📦\n\nGem denne fil som "validation.json" i mappen "frontend/validation/" for at aktivere den på hjemmesiden.');
    });

    // Import validation
    document.getElementById('import-validation').addEventListener('click', () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (file) {
          try {
            const text = await file.text();
            validationData = JSON.parse(text);
            invalidateKravValidationIndex();
            await renderValidationContent();
            alert('Validering importeret! ✅');
          } catch(err) {
            alert('Fejl ved import: ' + err.message);
          }
        }
      };
      input.click();
    });

    // ============================================
    // PROJECT SAVE/LOAD FUNCTIONALITY
    // ============================================

    function _collectAllStep3DocMetasAcrossBuildings(){
      const out = [];
      const buildingCount = Number.isFinite(Number(buildingsState?.count)) ? Number(buildingsState.count) : 0;
      for (let b = 0; b < buildingCount; b++) {
        const st = buildingsState?.buildings?.[b];
        if (!st) continue;
        const sectionCount = Number.isFinite(Number(st.count)) ? Number(st.count) : 0;
        for (let s = 0; s < sectionCount; s++) {
          const docsByCat = st.kravCategoryDocs?.[String(s)] || {};
          for (const [cat, list] of Object.entries(docsByCat || {})) {
            const arr = Array.isArray(list) ? list : [];
            for (const meta of arr) {
              out.push({ buildingIndex: b, sectionIndex: s, category: String(cat || '').trim(), meta });
            }
          }
        }
      }
      return out;
    }

    async function _buildKravDocFilesPayloadForSave(){
      // Persist Step 3 uploaded bilag so exports still embed after reload.
      // Shape: { schema: 'dataUrl-v1', byId: { [docId]: { dataUrl, name, type, lastModified } }, stats: {...} }
      const store = getKravDocFileStore();
      const seen = new Set();
      const byId = {};
      let totalUnique = 0;
      let included = 0;
      let missing = 0;
      let failed = 0;

      const metas = _collectAllStep3DocMetasAcrossBuildings();
      for (const it of metas) {
        const id = String(it?.meta?.id || '').trim();
        if (!id || seen.has(id)) continue;
        seen.add(id);
        totalUnique++;

        const file = store[id] || null;
        if (!file) { missing++; continue; }
        try {
          const dataUrl = await fileToDataUrlLocal(file);
          if (!dataUrl || !/^data:/i.test(String(dataUrl))) {
            failed++;
            continue;
          }
          byId[id] = {
            dataUrl: String(dataUrl),
            name: String(file.name || it?.meta?.name || 'fil'),
            type: String(file.type || it?.meta?.type || ''),
            lastModified: Number.isFinite(Number(file.lastModified)) ? Number(file.lastModified) : (Number.isFinite(Number(it?.meta?.lastModified)) ? Number(it.meta.lastModified) : null)
          };
          included++;
        } catch (e) {
          failed++;
        }
      }

      return {
        schema: 'dataUrl-v1',
        byId,
        stats: { totalUnique, included, missing, failed }
      };
    }

    function _dataUrlToFile(dataUrl, fileName, opts){
      const options = opts && typeof opts === 'object' ? opts : {};
      const raw = String(dataUrl || '');
      const m = raw.match(/^data:([^;,]+)?;base64,(.*)$/s);
      if (!m) return null;
      const mime = String(m[1] || options.type || '');
      const b64 = String(m[2] || '');
      let bin = '';
      try { bin = atob(b64); } catch (_) { return null; }
      const bytes = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
      const blob = new Blob([bytes], { type: mime || '' });
      const lm = Number.isFinite(Number(options.lastModified)) ? Number(options.lastModified) : Date.now();
      try {
        return new File([blob], String(fileName || 'fil'), { type: mime || '', lastModified: lm });
      } catch (_) {
        return new File([blob], String(fileName || 'fil'), { type: mime || '' });
      }
    }

    function _syncKravDocMetasFromStore(){
      const store = getKravDocFileStore();
      const metas = _collectAllStep3DocMetasAcrossBuildings();
      for (const it of metas) {
        const meta = it?.meta;
        const id = String(meta?.id || '').trim();
        if (!id) continue;
        const f = store[id];
        if (!f) continue;
        meta.name = String(f.name || meta.name || 'fil');
        meta.type = String(f.type || meta.type || '');
        meta.size = Number.isFinite(Number(f.size)) ? Number(f.size) : (Number.isFinite(Number(meta.size)) ? Number(meta.size) : null);
        meta.lastModified = Number.isFinite(Number(f.lastModified)) ? Number(f.lastModified) : (Number.isFinite(Number(meta.lastModified)) ? Number(meta.lastModified) : null);
      }
    }

    function _rehydrateKravDocFilesFromLoadedProject(projectData){
      // Returns { ok, failed }.
      const payload = projectData?.kravDocFiles;
      const byId = payload?.byId && typeof payload.byId === 'object' ? payload.byId : null;
      if (!byId) return { ok: 0, failed: 0 };

      const store = getKravDocFileStore();
      try {
        for (const k of Object.keys(store)) delete store[k];
      } catch (_) {}

      let ok = 0;
      let failed = 0;
      for (const [idRaw, rec] of Object.entries(byId)) {
        const id = String(idRaw || '').trim();
        if (!id) continue;
        const dataUrl = String(rec?.dataUrl || '');
        const name = String(rec?.name || 'fil');
        const type = String(rec?.type || '');
        const lastModified = rec?.lastModified;
        const f = _dataUrlToFile(dataUrl, name, { type, lastModified });
        if (f) {
          try { store[id] = f; ok++; } catch (_) { failed++; }
        } else {
          failed++;
        }
      }

      try { _syncKravDocMetasFromStore(); } catch (_) {}
      return { ok, failed };
    }

    function mergeEvaluationPreservePrereqs(previous, result){
      const prev = (previous && typeof previous === 'object') ? previous : {};
      const res = (result && typeof result === 'object') ? result : {};
      const merged = { ...prev, ...res };
      // Preserve prerequisites if the refreshed result omits them.
      if (!('anvendelseskategori' in res) && prev.anvendelseskategori !== undefined) merged.anvendelseskategori = prev.anvendelseskategori;
      if (!('risikoklasse' in res) && prev.risikoklasse !== undefined) merged.risikoklasse = prev.risikoklasse;
      if (!('relevant_bilag' in res) && prev.relevant_bilag !== undefined) merged.relevant_bilag = prev.relevant_bilag;
      if (!('bilag' in res) && prev.bilag !== undefined) merged.bilag = prev.bilag;
      if (!('bilag_outputs' in res) && prev.bilag_outputs !== undefined) merged.bilag_outputs = prev.bilag_outputs;
      return merged;
    }

    async function refreshEvaluationForBuildingSection(bIdx, sIdx){
      const b = buildingsState?.buildings?.[bIdx];
      if (!b) return null;
      const inputs = b?.inputs?.[sIdx];
      if (!inputs || typeof inputs !== 'object' || Object.keys(inputs).length === 0) return null;

      const extras = (b?.bilagExtras && b.bilagExtras[sIdx] && typeof b.bilagExtras[sIdx] === 'object') ? b.bilagExtras[sIdx] : {};
      const data = { ...canonicalizeInputData(inputs), ...extras };

      const response = await fetch(`${API_BASE}/evaluate-complete`, {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify(data)
      });
      if (!response.ok) throw new Error('BK API request failed');
      const result = await response.json();

      const previous = b?.evaluations?.[sIdx] ?? {};
      const merged = mergeEvaluationPreservePrereqs(previous, result);

      if (!b.evaluations || typeof b.evaluations !== 'object') b.evaluations = {};
      b.evaluations[sIdx] = merged;

      if (!b.inputData || typeof b.inputData !== 'object') b.inputData = {};
      b.inputData[sIdx] = data;

      if (!b.progress || typeof b.progress !== 'object') b.progress = {};
      b.progress[sIdx] = { ...(b.progress[sIdx] || {}), evaluated: true };

      // If this is the active building/section, keep latestEvaluation in sync.
      try {
        if (getActiveBuildingIndex() === bIdx && getActiveSectionIndex() === sIdx) {
          latestEvaluation = merged;
        }
      } catch(_) {}

      return merged;
    }

    async function refreshProjectAfterLoad(){
      // Clear Step 2 captions cache so newly added/updated captions.json is picked up.
      try { step2CaptionsCache = null; } catch(_) {}

      const activeB = getActiveBuildingIndex();
      const activeS = getActiveSectionIndex();
      // 1) Refresh active section immediately (so the user sees updated figures right away)
      try {
        await refreshEvaluationForBuildingSection(activeB, activeS);
      } catch (e) {
        console.warn('Project load refresh: could not refresh active evaluation', e);
      }

      // Update the currently visible step, if relevant.
      try {
        const step = getCurrentStep();
        if (step === 2) await updateStep2Display();
        if (step === 3) await updateStep3Display();
        if (step === 1) {
          const idx = getActiveSectionIndex();
          const existing = sectionsState?.evaluations?.[idx];
          if (existing) {
            latestEvaluation = existing;
            try { displayResults(existing); } catch(_) {}
            try { updateStep1BrandklasseCard(); } catch(_) {}
          }
        }
      } catch(_) {}

      // 2) Refresh remaining sections in the background (keeps multi-building projects up-to-date).
      setTimeout(async () => {
        try {
          for (let bIdx = 0; bIdx < (buildingsState.count || 1); bIdx++) {
            const b = buildingsState?.buildings?.[bIdx];
            const sectionCount = Math.max(1, Number(b?.count ?? 1) || 1);
            for (let sIdx = 0; sIdx < sectionCount; sIdx++) {
              if (bIdx === activeB && sIdx === activeS) continue;
              try {
                await refreshEvaluationForBuildingSection(bIdx, sIdx);
              } catch (_) {
                // Keep old evaluation if refresh fails.
              }
              // Yield to keep UI responsive.
              await new Promise(r => setTimeout(r, 0));
            }
          }
        } catch (_) {}
      }, 0);
    }

    function normalizeLoadedSectionsState(rawSections){
      const raw = rawSections && typeof rawSections === 'object' ? rawSections : {};
      const count = Math.max(1, Number(raw.count ?? 1) || 1);
      const normalized = {
        count,
        titles: Array.isArray(raw.titles) ? raw.titles : [],
        inputs: (raw.inputs && typeof raw.inputs === 'object') ? raw.inputs : {},
        inputData: (raw.inputData && typeof raw.inputData === 'object') ? raw.inputData : {},
        bilagExtras: (raw.bilagExtras && typeof raw.bilagExtras === 'object') ? raw.bilagExtras : {},
        evaluations: (raw.evaluations && typeof raw.evaluations === 'object') ? raw.evaluations : {},
        progress: (raw.progress && typeof raw.progress === 'object') ? raw.progress : {},
        lastStep: (raw.lastStep && typeof raw.lastStep === 'object') ? raw.lastStep : {},
        kravChecks: (raw.kravChecks && typeof raw.kravChecks === 'object') ? raw.kravChecks : (raw.kravChecks ? raw.kravChecks : undefined),
        kravExcluded: (raw.kravExcluded && typeof raw.kravExcluded === 'object') ? raw.kravExcluded : (raw.kravExcluded ? raw.kravExcluded : undefined),
        kravNotes: (raw.kravNotes && typeof raw.kravNotes === 'object') ? raw.kravNotes : (raw.kravNotes ? raw.kravNotes : undefined),
        kravResults: (raw.kravResults && typeof raw.kravResults === 'object') ? raw.kravResults : (raw.kravResults ? raw.kravResults : undefined),
        kravCategoryOrder: (raw.kravCategoryOrder && typeof raw.kravCategoryOrder === 'object') ? raw.kravCategoryOrder : {},
        kravCategoryDocs: (raw.kravCategoryDocs && typeof raw.kravCategoryDocs === 'object') ? raw.kravCategoryDocs : {}
      };

      // Ensure progress defaults exist (used by tabs and summary).
      for (let i = 0; i < count; i++) {
        if (!normalized.progress[i]) normalized.progress[i] = { evaluated: false, requirementsViewed: false };
      }

      return normalized;
    }

    function normalizeLoadedBuildingsState(rawBuildings){
      const raw = rawBuildings && typeof rawBuildings === 'object' ? rawBuildings : {};
      const count = Math.max(1, Number(raw.count ?? 1) || 1);
      const titles = Array.isArray(raw.titles) ? raw.titles : [];
      const buildingsRaw = (raw.buildings && typeof raw.buildings === 'object') ? raw.buildings : {};
      const lastActiveSection = (raw.lastActiveSection && typeof raw.lastActiveSection === 'object') ? raw.lastActiveSection : {};

      const buildings = {};
      for (let i = 0; i < count; i++) {
        buildings[i] = normalizeLoadedSectionsState(buildingsRaw[i] || buildingsRaw[String(i)] || {});
      }

      return { count, titles, buildings, lastActiveSection };
    }

    // Save entire project (buildings, sections, inputs, validations, evaluations)
    document.getElementById('save-project-btn').addEventListener('click', async () => {
      const saveBtn = document.getElementById('save-project-btn');
      const prevSaveLabel = saveBtn ? String(saveBtn.textContent || '') : '';
      try {
        if (saveBtn) {
          saveBtn.disabled = true;
          saveBtn.textContent = '⏳ Gemmer…';
        }
        // Capture current active section's form data before saving
        try { captureInputsToSection(getActiveSectionIndex()); } catch(_) {}
        try { buildingsState.lastActiveSection[getActiveBuildingIndex()] = getActiveSectionIndex(); } catch(_) {}

        const allSectionCount = (() => {
          try {
            let total = 0;
            for (let i = 0; i < buildingsState.count; i++) {
              total += Math.max(1, Number(buildingsState.buildings?.[i]?.count ?? 1) || 1);
            }
            return total;
          } catch(_) {
            return sectionsState.count;
          }
        })();
        
        const kravDocFiles = await _buildKravDocFilesPayloadForSave();

        const projectData = {
          version: "1.0",
          savedAt: new Date().toISOString(),
          kravDocFiles,
          buildings: {
            count: buildingsState.count,
            titles: buildingsState.titles,
            buildings: buildingsState.buildings,
            lastActiveSection: buildingsState.lastActiveSection
          },
          currentActiveBuilding: getActiveBuildingIndex(),
          sections: {
            count: sectionsState.count,
            titles: sectionsState.titles,
            inputs: sectionsState.inputs,
            inputData: sectionsState.inputData,
            bilagExtras: sectionsState.bilagExtras,
            evaluations: sectionsState.evaluations,
            progress: sectionsState.progress,
            lastStep: sectionsState.lastStep,
            kravChecks: sectionsState.kravChecks,
            kravExcluded: sectionsState.kravExcluded,
            kravNotes: sectionsState.kravNotes,
            kravResults: sectionsState.kravResults,
            kravCategoryOrder: sectionsState.kravCategoryOrder,
            kravCategoryDocs: sectionsState.kravCategoryDocs
          },
          validation: validationData,
          currentActiveSection: getActiveSectionIndex(),
          currentStep: getCurrentStep()
        };
        
        const blob = new Blob([JSON.stringify(projectData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
        a.download = `BR18_Projekt_${timestamp}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        const savedFilesCount = Number.isFinite(Number(kravDocFiles?.stats?.included)) ? Number(kravDocFiles.stats.included) : 0;
        alert('✅ Projekt gemt!\n\nDit projekt er gemt med:\n' +
              `• ${buildingsState.count} bygning(er)\n` +
              `• ${allSectionCount} bygningsafsnit\n` +
              (savedFilesCount ? (`• ${savedFilesCount} bilag-filer fra trin 3 (til PDF eksport)\n`) : '') +
              `• Alle inputs og valideringer\n` +
              `• Nuværende progress\n\n` +
              'Gem denne fil et sikkert sted og upload den igen for at fortsætte dit arbejde.');
      } catch(err) {
        alert('❌ Fejl ved gemning af projekt: ' + err.message);
        console.error('Save project error:', err);
      } finally {
        if (saveBtn) {
          saveBtn.disabled = false;
          saveBtn.textContent = prevSaveLabel || 'Gem projekt';
        }
      }
    });

    // Load project from file
    document.getElementById('load-project-input').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        const text = await file.text();
        const projectData = JSON.parse(text);
        
        // Validate project data structure
        if (!projectData.version || (!projectData.sections && !projectData.buildings)) {
          throw new Error('Ugyldig projekt fil - mangler nødvendig struktur');
        }

        // Restore buildings + sections state (supports both new and legacy save files)
        if (projectData.buildings) {
          const normalizedBuildings = normalizeLoadedBuildingsState(projectData.buildings);
          buildingsState.count = normalizedBuildings.count;
          buildingsState.titles = normalizedBuildings.titles;
          buildingsState.buildings = normalizedBuildings.buildings;
          buildingsState.lastActiveSection = normalizedBuildings.lastActiveSection;
        } else {
          // Legacy: single building stored under projectData.sections
          buildingsState.count = 1;
          buildingsState.titles = [];
          buildingsState.buildings = {};
          buildingsState.lastActiveSection = {};
          buildingsState.buildings[0] = normalizeLoadedSectionsState(projectData.sections);
        }

        // Restore Step 3 uploaded bilag file bytes (so exports can embed after reload)
        const rehydrated = _rehydrateKravDocFilesFromLoadedProject(projectData);
        
        // Restore validation data
        if (projectData.validation) {
          validationData = projectData.validation;
          updateValidationStatus();
        }
        
        // Restore active building/section and step
        const targetBuilding = projectData.currentActiveBuilding || 0;
        const targetSection = projectData.currentActiveSection || 0;
        const targetStep = projectData.currentStep || 1;

        // Activate target building (this also renders tabs and restores last active section)
        setActiveBuildingIndex(Math.max(0, Math.min(targetBuilding, buildingsState.count - 1)));

        // Ensure the requested section is active
        setActiveSectionIndex(targetSection);
        
        // Navigate to saved step
        goToStep(targetStep);

        // Auto-refresh derived results (evaluations + Step 2 figures) using newest logic/assets.
        await refreshProjectAfterLoad();
        
        // Update status
        updateStatus();
        
        // Compute total sections across buildings
        const allSectionCount = (() => {
          try {
            let total = 0;
            for (let i = 0; i < buildingsState.count; i++) {
              total += Math.max(1, Number(buildingsState.buildings?.[i]?.count ?? 1) || 1);
            }
            return total;
          } catch(_) {
            return sectionsState.count;
          }
        })();

          alert(`✅ Projekt indlæst!\n\n` +
              `• ${buildingsState.count} bygning(er) gendannet\n` +
              `• ${allSectionCount} bygningsafsnit gendannet\n` +
              `• Alle inputs og valideringer gendannet\n` +
            ((rehydrated && (rehydrated.ok || rehydrated.failed)) ? (`• Trin 3 bilag gendannet: ${rehydrated.ok || 0}${rehydrated.failed ? ` (manglede/fejlede: ${rehydrated.failed})` : ''}\n`) : '') +
              `• Fortsætter fra trin ${targetStep}\n\n` +
              `Du kan nu fortsætte dit arbejde hvor du slap.`);
              
        // Clear file input so the same file can be loaded again
        e.target.value = '';
        
      } catch(err) {
        alert('❌ Fejl ved indlæsning af projekt: ' + err.message);
        console.error('Load project error:', err);
        e.target.value = '';
      }
    });

    // Helper function to get current step
    function getCurrentStep() {
      if (document.getElementById('wizard-step-1').style.display !== 'none') return 1;
      if (document.getElementById('wizard-step-2').style.display !== 'none') return 2;
      if (document.getElementById('wizard-step-3').style.display !== 'none') return 3;
      if (document.getElementById('wizard-step-4').style.display !== 'none') return 4;
      return 1;
    }

  </script>
</body>
</html>
